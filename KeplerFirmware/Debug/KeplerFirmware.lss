
KeplerFirmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000af74  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0040af74  0040af74  0001af74  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000009f4  20000000  0040af7c  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00007fd0  200009f8  0040b978  000209f8  2**3
                  ALLOC
  4 .stack        00003000  200089c8  00413948  000209f8  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  000209f4  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020a22  2**0
                  CONTENTS, READONLY
  7 .debug_info   00034574  00000000  00000000  00020a7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000062ee  00000000  00000000  00054fef  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000b776  00000000  00000000  0005b2dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001618  00000000  00000000  00066a53  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000014b0  00000000  00000000  0006806b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000235ca  00000000  00000000  0006951b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001e1de  00000000  00000000  0008cae5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006f476  00000000  00000000  000aacc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00005c7c  00000000  00000000  0011a13c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	c8 b9 00 20 6d 84 40 00 dd 83 40 00 dd 83 40 00     ... m.@...@...@.
  400010:	dd 83 40 00 dd 83 40 00 dd 83 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	dd 83 40 00 dd 83 40 00 00 00 00 00 dd 83 40 00     ..@...@.......@.
  40003c:	dd 83 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     ..@...@...@...@.
  40004c:	dd 83 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     ..@...@...@...@.
  40005c:	dd 83 40 00 dd 83 40 00 75 52 40 00 8d 52 40 00     ..@...@.uR@..R@.
  40006c:	a5 52 40 00 bd 52 40 00 d5 52 40 00 dd 83 40 00     .R@..R@..R@...@.
  40007c:	dd 83 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     ..@...@...@...@.
  40008c:	dd 83 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     ..@...@...@...@.
  40009c:	95 13 40 00 6d 2b 40 00 dd 83 40 00 dd 83 40 00     ..@.m+@...@...@.
  4000ac:	dd 83 40 00 dd 83 40 00 dd 83 40 00 25 0c 40 00     ..@...@...@.%.@.
  4000bc:	3d 0c 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     =.@...@...@...@.
  4000cc:	dd 54 40 00 dd 83 40 00 c1 2b 40 00 dd 83 40 00     .T@...@..+@...@.
  4000dc:	dd 83 40 00 dd 83 40 00 dd 83 40 00 dd 83 40 00     ..@...@...@...@.
  4000ec:	dd 83 40 00 dd 83 40 00 dd 83 40 00                 ..@...@...@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	200009f8 	.word	0x200009f8
  400114:	00000000 	.word	0x00000000
  400118:	0040af7c 	.word	0x0040af7c

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	0040af7c 	.word	0x0040af7c
  400158:	200009fc 	.word	0x200009fc
  40015c:	0040af7c 	.word	0x0040af7c
  400160:	00000000 	.word	0x00000000

00400164 <afec_ch_sanity_check>:
 * \param channel  AFEC channel number.
 *
 */
static inline void afec_ch_sanity_check(Afec *const afec,
		const enum afec_channel_num channel)
{
  400164:	b480      	push	{r7}
  400166:	b083      	sub	sp, #12
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
  40016c:	460b      	mov	r3, r1
  40016e:	807b      	strh	r3, [r7, #2]
	#endif
	} else if (afec == AFEC1) {
		Assert(channel < NB_CH_AFE1);
	}
	UNUSED(channel);
}
  400170:	bf00      	nop
  400172:	370c      	adds	r7, #12
  400174:	46bd      	mov	sp, r7
  400176:	f85d 7b04 	ldr.w	r7, [sp], #4
  40017a:	4770      	bx	lr

0040017c <afec_set_trigger>:
 * \param trigger Conversion trigger.
 *
 */
static inline void afec_set_trigger(Afec *const afec,
		const enum afec_trigger trigger)
{
  40017c:	b480      	push	{r7}
  40017e:	b085      	sub	sp, #20
  400180:	af00      	add	r7, sp, #0
  400182:	6078      	str	r0, [r7, #4]
  400184:	460b      	mov	r3, r1
  400186:	70fb      	strb	r3, [r7, #3]
	uint32_t reg;

	reg = afec->AFEC_MR;
  400188:	687b      	ldr	r3, [r7, #4]
  40018a:	685b      	ldr	r3, [r3, #4]
  40018c:	60fb      	str	r3, [r7, #12]

	if (trigger == AFEC_TRIG_FREERUN) {
  40018e:	78fb      	ldrb	r3, [r7, #3]
  400190:	2bff      	cmp	r3, #255	; 0xff
  400192:	d104      	bne.n	40019e <afec_set_trigger+0x22>
		reg |= AFEC_MR_FREERUN_ON;
  400194:	68fb      	ldr	r3, [r7, #12]
  400196:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40019a:	60fb      	str	r3, [r7, #12]
  40019c:	e007      	b.n	4001ae <afec_set_trigger+0x32>
	} else {
		reg &= ~(AFEC_MR_TRGSEL_Msk | AFEC_MR_TRGEN | AFEC_MR_FREERUN_ON);
  40019e:	68fb      	ldr	r3, [r7, #12]
  4001a0:	f023 038f 	bic.w	r3, r3, #143	; 0x8f
  4001a4:	60fb      	str	r3, [r7, #12]
		reg |= trigger;
  4001a6:	78fb      	ldrb	r3, [r7, #3]
  4001a8:	68fa      	ldr	r2, [r7, #12]
  4001aa:	4313      	orrs	r3, r2
  4001ac:	60fb      	str	r3, [r7, #12]
	}

	afec->AFEC_MR = reg;
  4001ae:	687b      	ldr	r3, [r7, #4]
  4001b0:	68fa      	ldr	r2, [r7, #12]
  4001b2:	605a      	str	r2, [r3, #4]
}
  4001b4:	bf00      	nop
  4001b6:	3714      	adds	r7, #20
  4001b8:	46bd      	mov	sp, r7
  4001ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001be:	4770      	bx	lr

004001c0 <afec_start_software_conversion>:
 * this function can NOT start analog to digital conversion.
 *
 * \param afec  Base address of the AFEC.
 */
static inline void afec_start_software_conversion(Afec *const afec)
{
  4001c0:	b480      	push	{r7}
  4001c2:	b083      	sub	sp, #12
  4001c4:	af00      	add	r7, sp, #0
  4001c6:	6078      	str	r0, [r7, #4]
	afec->AFEC_CR = AFEC_CR_START;
  4001c8:	687b      	ldr	r3, [r7, #4]
  4001ca:	2202      	movs	r2, #2
  4001cc:	601a      	str	r2, [r3, #0]
}
  4001ce:	bf00      	nop
  4001d0:	370c      	adds	r7, #12
  4001d2:	46bd      	mov	sp, r7
  4001d4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001d8:	4770      	bx	lr
	...

004001dc <afec_channel_enable>:
 * \param afec  Base address of the AFEC.
 * \param afec_ch AFEC channel number.
 */
static inline void afec_channel_enable(Afec *const afec,
		const enum afec_channel_num afec_ch)
{
  4001dc:	b580      	push	{r7, lr}
  4001de:	b082      	sub	sp, #8
  4001e0:	af00      	add	r7, sp, #0
  4001e2:	6078      	str	r0, [r7, #4]
  4001e4:	460b      	mov	r3, r1
  4001e6:	807b      	strh	r3, [r7, #2]
	if (afec_ch != AFEC_CHANNEL_ALL) {
  4001e8:	887b      	ldrh	r3, [r7, #2]
  4001ea:	f248 023f 	movw	r2, #32831	; 0x803f
  4001ee:	4293      	cmp	r3, r2
  4001f0:	d004      	beq.n	4001fc <afec_channel_enable+0x20>
		afec_ch_sanity_check(afec, afec_ch);
  4001f2:	887b      	ldrh	r3, [r7, #2]
  4001f4:	4619      	mov	r1, r3
  4001f6:	6878      	ldr	r0, [r7, #4]
  4001f8:	4b0a      	ldr	r3, [pc, #40]	; (400224 <afec_channel_enable+0x48>)
  4001fa:	4798      	blx	r3
	}

	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
			AFEC_CHANNEL_ALL : 1 << afec_ch;
  4001fc:	887b      	ldrh	r3, [r7, #2]
  4001fe:	f248 023f 	movw	r2, #32831	; 0x803f
  400202:	4293      	cmp	r3, r2
  400204:	d005      	beq.n	400212 <afec_channel_enable+0x36>
  400206:	887b      	ldrh	r3, [r7, #2]
  400208:	2201      	movs	r2, #1
  40020a:	fa02 f303 	lsl.w	r3, r2, r3
  40020e:	461a      	mov	r2, r3
  400210:	e001      	b.n	400216 <afec_channel_enable+0x3a>
  400212:	f248 023f 	movw	r2, #32831	; 0x803f
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  400216:	687b      	ldr	r3, [r7, #4]
  400218:	615a      	str	r2, [r3, #20]
}
  40021a:	bf00      	nop
  40021c:	3708      	adds	r7, #8
  40021e:	46bd      	mov	sp, r7
  400220:	bd80      	pop	{r7, pc}
  400222:	bf00      	nop
  400224:	00400165 	.word	0x00400165

00400228 <afec_channel_get_value>:
 *
 * \return AFEC converted value of the selected channel.
 */
static inline uint32_t afec_channel_get_value(Afec *const afec,
		enum afec_channel_num afec_ch)
{
  400228:	b580      	push	{r7, lr}
  40022a:	b082      	sub	sp, #8
  40022c:	af00      	add	r7, sp, #0
  40022e:	6078      	str	r0, [r7, #4]
  400230:	460b      	mov	r3, r1
  400232:	807b      	strh	r3, [r7, #2]
	afec_ch_sanity_check(afec, afec_ch);
  400234:	887b      	ldrh	r3, [r7, #2]
  400236:	4619      	mov	r1, r3
  400238:	6878      	ldr	r0, [r7, #4]
  40023a:	4b05      	ldr	r3, [pc, #20]	; (400250 <afec_channel_get_value+0x28>)
  40023c:	4798      	blx	r3

	afec->AFEC_CSELR = afec_ch;
  40023e:	887a      	ldrh	r2, [r7, #2]
  400240:	687b      	ldr	r3, [r7, #4]
  400242:	665a      	str	r2, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  400244:	687b      	ldr	r3, [r7, #4]
  400246:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
  400248:	4618      	mov	r0, r3
  40024a:	3708      	adds	r7, #8
  40024c:	46bd      	mov	sp, r7
  40024e:	bd80      	pop	{r7, pc}
  400250:	00400165 	.word	0x00400165

00400254 <afec_channel_set_analog_offset>:
 * \param afec_ch AFEC channel number.
 * \param aoffset  Analog offset value.
 */
static inline void afec_channel_set_analog_offset(Afec *const afec,
		enum afec_channel_num afec_ch, uint16_t aoffset)
{
  400254:	b580      	push	{r7, lr}
  400256:	b082      	sub	sp, #8
  400258:	af00      	add	r7, sp, #0
  40025a:	6078      	str	r0, [r7, #4]
  40025c:	460b      	mov	r3, r1
  40025e:	807b      	strh	r3, [r7, #2]
  400260:	4613      	mov	r3, r2
  400262:	803b      	strh	r3, [r7, #0]
	afec_ch_sanity_check(afec, afec_ch);
  400264:	887b      	ldrh	r3, [r7, #2]
  400266:	4619      	mov	r1, r3
  400268:	6878      	ldr	r0, [r7, #4]
  40026a:	4b07      	ldr	r3, [pc, #28]	; (400288 <afec_channel_set_analog_offset+0x34>)
  40026c:	4798      	blx	r3

	afec->AFEC_CSELR = afec_ch;
  40026e:	887a      	ldrh	r2, [r7, #2]
  400270:	687b      	ldr	r3, [r7, #4]
  400272:	665a      	str	r2, [r3, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  400274:	883b      	ldrh	r3, [r7, #0]
  400276:	f3c3 020b 	ubfx	r2, r3, #0, #12
  40027a:	687b      	ldr	r3, [r7, #4]
  40027c:	66da      	str	r2, [r3, #108]	; 0x6c
}
  40027e:	bf00      	nop
  400280:	3708      	adds	r7, #8
  400282:	46bd      	mov	sp, r7
  400284:	bd80      	pop	{r7, pc}
  400286:	bf00      	nop
  400288:	00400165 	.word	0x00400165

0040028c <afec_get_latest_value>:
 * \param afec  Base address of the AFEC.
 *
 * \return AFEC latest converted value.
 */
static inline uint32_t afec_get_latest_value(Afec *const afec)
{
  40028c:	b480      	push	{r7}
  40028e:	b083      	sub	sp, #12
  400290:	af00      	add	r7, sp, #0
  400292:	6078      	str	r0, [r7, #4]
	return afec->AFEC_LCDR & AFEC_LCDR_LDATA_Msk;
  400294:	687b      	ldr	r3, [r7, #4]
  400296:	6a1b      	ldr	r3, [r3, #32]
  400298:	b29b      	uxth	r3, r3
}
  40029a:	4618      	mov	r0, r3
  40029c:	370c      	adds	r7, #12
  40029e:	46bd      	mov	sp, r7
  4002a0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002a4:	4770      	bx	lr

004002a6 <afec_get_interrupt_status>:
 * \param afec  Base address of the AFEC.
 *
 * \return The interrupt status value.
 */
static inline uint32_t afec_get_interrupt_status(Afec *const afec)
{
  4002a6:	b480      	push	{r7}
  4002a8:	b083      	sub	sp, #12
  4002aa:	af00      	add	r7, sp, #0
  4002ac:	6078      	str	r0, [r7, #4]
	return afec->AFEC_ISR;
  4002ae:	687b      	ldr	r3, [r7, #4]
  4002b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  4002b2:	4618      	mov	r0, r3
  4002b4:	370c      	adds	r7, #12
  4002b6:	46bd      	mov	sp, r7
  4002b8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002bc:	4770      	bx	lr

004002be <afec_start_calibration>:
 * \retval STATUS_OK  An automatic calibration is launched.
 * \retval STATUS_ERR_BUSY  Automatic calibration can not be launched because
 *         the AFEC is in freerun mode.
 */
static inline enum status_code afec_start_calibration(Afec *const afec)
{
  4002be:	b480      	push	{r7}
  4002c0:	b085      	sub	sp, #20
  4002c2:	af00      	add	r7, sp, #0
  4002c4:	6078      	str	r0, [r7, #4]
	uint32_t reg;

	reg = afec->AFEC_CHSR;
  4002c6:	687b      	ldr	r3, [r7, #4]
  4002c8:	69db      	ldr	r3, [r3, #28]
  4002ca:	60fb      	str	r3, [r7, #12]
	afec->AFEC_CDOR = reg;
  4002cc:	687b      	ldr	r3, [r7, #4]
  4002ce:	68fa      	ldr	r2, [r7, #12]
  4002d0:	65da      	str	r2, [r3, #92]	; 0x5c

	if ((afec->AFEC_MR & AFEC_MR_FREERUN) == AFEC_MR_FREERUN_ON) {
  4002d2:	687b      	ldr	r3, [r7, #4]
  4002d4:	685b      	ldr	r3, [r3, #4]
  4002d6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4002da:	2b80      	cmp	r3, #128	; 0x80
  4002dc:	d101      	bne.n	4002e2 <afec_start_calibration+0x24>
		return STATUS_ERR_BUSY;
  4002de:	2319      	movs	r3, #25
  4002e0:	e003      	b.n	4002ea <afec_start_calibration+0x2c>
	}
	afec->AFEC_CR = AFEC_CR_AUTOCAL;
  4002e2:	687b      	ldr	r3, [r7, #4]
  4002e4:	2208      	movs	r2, #8
  4002e6:	601a      	str	r2, [r3, #0]
	return STATUS_OK;
  4002e8:	2300      	movs	r3, #0
}
  4002ea:	4618      	mov	r0, r3
  4002ec:	3714      	adds	r7, #20
  4002ee:	46bd      	mov	sp, r7
  4002f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002f4:	4770      	bx	lr
	...

004002f8 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  4002f8:	b580      	push	{r7, lr}
  4002fa:	b082      	sub	sp, #8
  4002fc:	af00      	add	r7, sp, #0
  4002fe:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400300:	6878      	ldr	r0, [r7, #4]
  400302:	4b03      	ldr	r3, [pc, #12]	; (400310 <sysclk_enable_peripheral_clock+0x18>)
  400304:	4798      	blx	r3
}
  400306:	bf00      	nop
  400308:	3708      	adds	r7, #8
  40030a:	46bd      	mov	sp, r7
  40030c:	bd80      	pop	{r7, pc}
  40030e:	bf00      	nop
  400310:	0040823d 	.word	0x0040823d

00400314 <adcInit>:
#include "adc.h"

int ul_mode = 0; //0 - sw trig ; 1 - tc trig
 
 void adcInit()
 {
  400314:	b590      	push	{r4, r7, lr}
  400316:	b089      	sub	sp, #36	; 0x24
  400318:	af00      	add	r7, sp, #0
	 sysclk_enable_peripheral_clock(ID_AFEC0);
  40031a:	201e      	movs	r0, #30
  40031c:	4b2c      	ldr	r3, [pc, #176]	; (4003d0 <adcInit+0xbc>)
  40031e:	4798      	blx	r3
	 struct afec_config afec_cfg;
	 afec_get_config_defaults(&afec_cfg);
  400320:	1d3b      	adds	r3, r7, #4
  400322:	4618      	mov	r0, r3
  400324:	4b2b      	ldr	r3, [pc, #172]	; (4003d4 <adcInit+0xc0>)
  400326:	4798      	blx	r3
	 afec_enable(AFEC0);
  400328:	482b      	ldr	r0, [pc, #172]	; (4003d8 <adcInit+0xc4>)
  40032a:	4b2c      	ldr	r3, [pc, #176]	; (4003dc <adcInit+0xc8>)
  40032c:	4798      	blx	r3
	 afec_init(AFEC0, &afec_cfg);
  40032e:	1d3b      	adds	r3, r7, #4
  400330:	4619      	mov	r1, r3
  400332:	4829      	ldr	r0, [pc, #164]	; (4003d8 <adcInit+0xc4>)
  400334:	4b2a      	ldr	r3, [pc, #168]	; (4003e0 <adcInit+0xcc>)
  400336:	4798      	blx	r3
	 afec_set_trigger(AFEC0, AFEC_TRIG_SW);
  400338:	2100      	movs	r1, #0
  40033a:	4827      	ldr	r0, [pc, #156]	; (4003d8 <adcInit+0xc4>)
  40033c:	4b29      	ldr	r3, [pc, #164]	; (4003e4 <adcInit+0xd0>)
  40033e:	4798      	blx	r3

	 afec_ch_set_config(AFEC0, CHANNEL_A, &afec_cfg);
  400340:	1d3b      	adds	r3, r7, #4
  400342:	461a      	mov	r2, r3
  400344:	2103      	movs	r1, #3
  400346:	4824      	ldr	r0, [pc, #144]	; (4003d8 <adcInit+0xc4>)
  400348:	4b27      	ldr	r3, [pc, #156]	; (4003e8 <adcInit+0xd4>)
  40034a:	4798      	blx	r3
	 afec_ch_set_config(AFEC0, CHANNEL_B, &afec_cfg);
  40034c:	1d3b      	adds	r3, r7, #4
  40034e:	461a      	mov	r2, r3
  400350:	2104      	movs	r1, #4
  400352:	4821      	ldr	r0, [pc, #132]	; (4003d8 <adcInit+0xc4>)
  400354:	4b24      	ldr	r3, [pc, #144]	; (4003e8 <adcInit+0xd4>)
  400356:	4798      	blx	r3
	 afec_ch_set_config(AFEC0, CHANNEL_C, &afec_cfg);
  400358:	1d3b      	adds	r3, r7, #4
  40035a:	461a      	mov	r2, r3
  40035c:	2105      	movs	r1, #5
  40035e:	481e      	ldr	r0, [pc, #120]	; (4003d8 <adcInit+0xc4>)
  400360:	4b21      	ldr	r3, [pc, #132]	; (4003e8 <adcInit+0xd4>)
  400362:	4798      	blx	r3

	 afec_channel_set_analog_offset(AFEC0, CHANNEL_A, 0x800);
  400364:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400368:	2103      	movs	r1, #3
  40036a:	481b      	ldr	r0, [pc, #108]	; (4003d8 <adcInit+0xc4>)
  40036c:	4b1f      	ldr	r3, [pc, #124]	; (4003ec <adcInit+0xd8>)
  40036e:	4798      	blx	r3
	 afec_channel_set_analog_offset(AFEC0, CHANNEL_B, 0x800);
  400370:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400374:	2104      	movs	r1, #4
  400376:	4818      	ldr	r0, [pc, #96]	; (4003d8 <adcInit+0xc4>)
  400378:	4b1c      	ldr	r3, [pc, #112]	; (4003ec <adcInit+0xd8>)
  40037a:	4798      	blx	r3
	 afec_channel_set_analog_offset(AFEC0, CHANNEL_C, 0x800);
  40037c:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400380:	2105      	movs	r1, #5
  400382:	4815      	ldr	r0, [pc, #84]	; (4003d8 <adcInit+0xc4>)
  400384:	4b19      	ldr	r3, [pc, #100]	; (4003ec <adcInit+0xd8>)
  400386:	4798      	blx	r3

	 afec_channel_enable(AFEC0, CHANNEL_A);
  400388:	2103      	movs	r1, #3
  40038a:	4813      	ldr	r0, [pc, #76]	; (4003d8 <adcInit+0xc4>)
  40038c:	4b18      	ldr	r3, [pc, #96]	; (4003f0 <adcInit+0xdc>)
  40038e:	4798      	blx	r3
	 afec_channel_enable(AFEC0, CHANNEL_B);
  400390:	2104      	movs	r1, #4
  400392:	4811      	ldr	r0, [pc, #68]	; (4003d8 <adcInit+0xc4>)
  400394:	4b16      	ldr	r3, [pc, #88]	; (4003f0 <adcInit+0xdc>)
  400396:	4798      	blx	r3
	 afec_channel_enable(AFEC0, CHANNEL_C);
  400398:	2105      	movs	r1, #5
  40039a:	480f      	ldr	r0, [pc, #60]	; (4003d8 <adcInit+0xc4>)
  40039c:	4b14      	ldr	r3, [pc, #80]	; (4003f0 <adcInit+0xdc>)
  40039e:	4798      	blx	r3


	 afec_set_callback(AFEC0, AFEC_INTERRUPT_DATA_READY, ADCDataReadyCallback, 14);
  4003a0:	230e      	movs	r3, #14
  4003a2:	4a14      	ldr	r2, [pc, #80]	; (4003f4 <adcInit+0xe0>)
  4003a4:	2107      	movs	r1, #7
  4003a6:	480c      	ldr	r0, [pc, #48]	; (4003d8 <adcInit+0xc4>)
  4003a8:	4c13      	ldr	r4, [pc, #76]	; (4003f8 <adcInit+0xe4>)
  4003aa:	47a0      	blx	r4

	 afec_start_calibration(AFEC0);
  4003ac:	480a      	ldr	r0, [pc, #40]	; (4003d8 <adcInit+0xc4>)
  4003ae:	4b13      	ldr	r3, [pc, #76]	; (4003fc <adcInit+0xe8>)
  4003b0:	4798      	blx	r3
	 while((afec_get_interrupt_status(AFEC0) & AFEC_ISR_EOCAL) != AFEC_ISR_EOCAL);
  4003b2:	bf00      	nop
  4003b4:	4808      	ldr	r0, [pc, #32]	; (4003d8 <adcInit+0xc4>)
  4003b6:	4b12      	ldr	r3, [pc, #72]	; (400400 <adcInit+0xec>)
  4003b8:	4798      	blx	r3
  4003ba:	4603      	mov	r3, r0
  4003bc:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
  4003c0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
  4003c4:	d1f6      	bne.n	4003b4 <adcInit+0xa0>

	 
 }
  4003c6:	bf00      	nop
  4003c8:	3724      	adds	r7, #36	; 0x24
  4003ca:	46bd      	mov	sp, r7
  4003cc:	bd90      	pop	{r4, r7, pc}
  4003ce:	bf00      	nop
  4003d0:	004002f9 	.word	0x004002f9
  4003d4:	004008f9 	.word	0x004008f9
  4003d8:	400b0000 	.word	0x400b0000
  4003dc:	00400c55 	.word	0x00400c55
  4003e0:	00400961 	.word	0x00400961
  4003e4:	0040017d 	.word	0x0040017d
  4003e8:	00400865 	.word	0x00400865
  4003ec:	00400255 	.word	0x00400255
  4003f0:	004001dd 	.word	0x004001dd
  4003f4:	00400405 	.word	0x00400405
  4003f8:	004009f9 	.word	0x004009f9
  4003fc:	004002bf 	.word	0x004002bf
  400400:	004002a7 	.word	0x004002a7

00400404 <ADCDataReadyCallback>:

 afec_callback_t ADCDataReadyCallback(void)
 {
  400404:	b580      	push	{r7, lr}
  400406:	b08a      	sub	sp, #40	; 0x28
  400408:	af00      	add	r7, sp, #0
	 
	 int value = afec_get_latest_value(AFEC0);
  40040a:	4821      	ldr	r0, [pc, #132]	; (400490 <ADCDataReadyCallback+0x8c>)
  40040c:	4b21      	ldr	r3, [pc, #132]	; (400494 <ADCDataReadyCallback+0x90>)
  40040e:	4798      	blx	r3
  400410:	4603      	mov	r3, r0
  400412:	627b      	str	r3, [r7, #36]	; 0x24
	 
	 int chA = afec_channel_get_value(AFEC0, CHANNEL_A);
  400414:	2103      	movs	r1, #3
  400416:	481e      	ldr	r0, [pc, #120]	; (400490 <ADCDataReadyCallback+0x8c>)
  400418:	4b1f      	ldr	r3, [pc, #124]	; (400498 <ADCDataReadyCallback+0x94>)
  40041a:	4798      	blx	r3
  40041c:	4603      	mov	r3, r0
  40041e:	623b      	str	r3, [r7, #32]
	 int chB = afec_channel_get_value(AFEC0, CHANNEL_B);
  400420:	2104      	movs	r1, #4
  400422:	481b      	ldr	r0, [pc, #108]	; (400490 <ADCDataReadyCallback+0x8c>)
  400424:	4b1c      	ldr	r3, [pc, #112]	; (400498 <ADCDataReadyCallback+0x94>)
  400426:	4798      	blx	r3
  400428:	4603      	mov	r3, r0
  40042a:	61fb      	str	r3, [r7, #28]
	 int chC = afec_channel_get_value(AFEC0, CHANNEL_C);
  40042c:	2105      	movs	r1, #5
  40042e:	4818      	ldr	r0, [pc, #96]	; (400490 <ADCDataReadyCallback+0x8c>)
  400430:	4b19      	ldr	r3, [pc, #100]	; (400498 <ADCDataReadyCallback+0x94>)
  400432:	4798      	blx	r3
  400434:	4603      	mov	r3, r0
  400436:	61bb      	str	r3, [r7, #24]

	 char ADCMessageBuffer[] = {START_BYTE, 0x00,0x07, READ_ADC_VALUE ,0x00,0x00,0x00,0x00,0x00,0x00};
  400438:	4a18      	ldr	r2, [pc, #96]	; (40049c <ADCDataReadyCallback+0x98>)
  40043a:	f107 030c 	add.w	r3, r7, #12
  40043e:	ca07      	ldmia	r2, {r0, r1, r2}
  400440:	c303      	stmia	r3!, {r0, r1}
  400442:	801a      	strh	r2, [r3, #0]

	 ADCMessageBuffer[4] = ( (chA & 0xFF00) >> 8);
  400444:	6a3b      	ldr	r3, [r7, #32]
  400446:	121b      	asrs	r3, r3, #8
  400448:	b2db      	uxtb	r3, r3
  40044a:	743b      	strb	r3, [r7, #16]
	 ADCMessageBuffer[5] =	(chA & 0x00FF);
  40044c:	6a3b      	ldr	r3, [r7, #32]
  40044e:	b2db      	uxtb	r3, r3
  400450:	747b      	strb	r3, [r7, #17]

	 ADCMessageBuffer[6] = ( (chB & 0xFF00) >> 8);
  400452:	69fb      	ldr	r3, [r7, #28]
  400454:	121b      	asrs	r3, r3, #8
  400456:	b2db      	uxtb	r3, r3
  400458:	74bb      	strb	r3, [r7, #18]
	 ADCMessageBuffer[7] =	(chB & 0x00FF);
  40045a:	69fb      	ldr	r3, [r7, #28]
  40045c:	b2db      	uxtb	r3, r3
  40045e:	74fb      	strb	r3, [r7, #19]

	 ADCMessageBuffer[8] = ( (chC & 0xFF00) >> 8);
  400460:	69bb      	ldr	r3, [r7, #24]
  400462:	121b      	asrs	r3, r3, #8
  400464:	b2db      	uxtb	r3, r3
  400466:	753b      	strb	r3, [r7, #20]
	 ADCMessageBuffer[9] =	(chC & 0x00FF);
  400468:	69bb      	ldr	r3, [r7, #24]
  40046a:	b2db      	uxtb	r3, r3
  40046c:	757b      	strb	r3, [r7, #21]

	 //WriteBufferOut(ADCMessage, 10);
	 Message_t ADCMessage;
	 ADCMessage.buf = ADCMessage.buf = ADCMessageBuffer;
  40046e:	f107 030c 	add.w	r3, r7, #12
  400472:	607b      	str	r3, [r7, #4]
  400474:	687b      	ldr	r3, [r7, #4]
  400476:	607b      	str	r3, [r7, #4]
	 ADCMessage.Size = 10;
  400478:	230a      	movs	r3, #10
  40047a:	813b      	strh	r3, [r7, #8]
	 
	 WriteMessage(&ADCMessage);
  40047c:	1d3b      	adds	r3, r7, #4
  40047e:	4618      	mov	r0, r3
  400480:	4b07      	ldr	r3, [pc, #28]	; (4004a0 <ADCDataReadyCallback+0x9c>)
  400482:	4798      	blx	r3
 }
  400484:	bf00      	nop
  400486:	4618      	mov	r0, r3
  400488:	3728      	adds	r7, #40	; 0x28
  40048a:	46bd      	mov	sp, r7
  40048c:	bd80      	pop	{r7, pc}
  40048e:	bf00      	nop
  400490:	400b0000 	.word	0x400b0000
  400494:	0040028d 	.word	0x0040028d
  400498:	00400229 	.word	0x00400229
  40049c:	0040abcc 	.word	0x0040abcc
  4004a0:	00401a3d 	.word	0x00401a3d

004004a4 <ReadADCValues>:

 uint32_t ReadADCValues (void)
 {
  4004a4:	b580      	push	{r7, lr}
  4004a6:	af00      	add	r7, sp, #0
	 if(ul_mode == 0)
  4004a8:	4b04      	ldr	r3, [pc, #16]	; (4004bc <ReadADCValues+0x18>)
  4004aa:	681b      	ldr	r3, [r3, #0]
  4004ac:	2b00      	cmp	r3, #0
  4004ae:	d102      	bne.n	4004b6 <ReadADCValues+0x12>
	 {
		 afec_start_software_conversion(AFEC0);
  4004b0:	4803      	ldr	r0, [pc, #12]	; (4004c0 <ReadADCValues+0x1c>)
  4004b2:	4b04      	ldr	r3, [pc, #16]	; (4004c4 <ReadADCValues+0x20>)
  4004b4:	4798      	blx	r3
	 {
		// uint8_t ADCError[] = {START_BYTE, 0x00,0x03,ERROR_RESPONSE, 0x00, ADC_MANUAL_TRIGGER_ERROR};
		 //WriteBufferOut(ADCError,6);
	 }

 }
  4004b6:	bf00      	nop
  4004b8:	4618      	mov	r0, r3
  4004ba:	bd80      	pop	{r7, pc}
  4004bc:	20000a14 	.word	0x20000a14
  4004c0:	400b0000 	.word	0x400b0000
  4004c4:	004001c1 	.word	0x004001c1

004004c8 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  4004c8:	b480      	push	{r7}
  4004ca:	b083      	sub	sp, #12
  4004cc:	af00      	add	r7, sp, #0
  4004ce:	4603      	mov	r3, r0
  4004d0:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4004d2:	4909      	ldr	r1, [pc, #36]	; (4004f8 <NVIC_EnableIRQ+0x30>)
  4004d4:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4004d8:	095b      	lsrs	r3, r3, #5
  4004da:	79fa      	ldrb	r2, [r7, #7]
  4004dc:	f002 021f 	and.w	r2, r2, #31
  4004e0:	2001      	movs	r0, #1
  4004e2:	fa00 f202 	lsl.w	r2, r0, r2
  4004e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  4004ea:	bf00      	nop
  4004ec:	370c      	adds	r7, #12
  4004ee:	46bd      	mov	sp, r7
  4004f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004f4:	4770      	bx	lr
  4004f6:	bf00      	nop
  4004f8:	e000e100 	.word	0xe000e100

004004fc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  4004fc:	b480      	push	{r7}
  4004fe:	b083      	sub	sp, #12
  400500:	af00      	add	r7, sp, #0
  400502:	4603      	mov	r3, r0
  400504:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  400506:	4909      	ldr	r1, [pc, #36]	; (40052c <NVIC_ClearPendingIRQ+0x30>)
  400508:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40050c:	095b      	lsrs	r3, r3, #5
  40050e:	79fa      	ldrb	r2, [r7, #7]
  400510:	f002 021f 	and.w	r2, r2, #31
  400514:	2001      	movs	r0, #1
  400516:	fa00 f202 	lsl.w	r2, r0, r2
  40051a:	3360      	adds	r3, #96	; 0x60
  40051c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  400520:	bf00      	nop
  400522:	370c      	adds	r7, #12
  400524:	46bd      	mov	sp, r7
  400526:	f85d 7b04 	ldr.w	r7, [sp], #4
  40052a:	4770      	bx	lr
  40052c:	e000e100 	.word	0xe000e100

00400530 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  400530:	b480      	push	{r7}
  400532:	b083      	sub	sp, #12
  400534:	af00      	add	r7, sp, #0
  400536:	4603      	mov	r3, r0
  400538:	6039      	str	r1, [r7, #0]
  40053a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  40053c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400540:	2b00      	cmp	r3, #0
  400542:	da0b      	bge.n	40055c <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  400544:	490d      	ldr	r1, [pc, #52]	; (40057c <NVIC_SetPriority+0x4c>)
  400546:	79fb      	ldrb	r3, [r7, #7]
  400548:	f003 030f 	and.w	r3, r3, #15
  40054c:	3b04      	subs	r3, #4
  40054e:	683a      	ldr	r2, [r7, #0]
  400550:	b2d2      	uxtb	r2, r2
  400552:	0112      	lsls	r2, r2, #4
  400554:	b2d2      	uxtb	r2, r2
  400556:	440b      	add	r3, r1
  400558:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
  40055a:	e009      	b.n	400570 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  40055c:	4908      	ldr	r1, [pc, #32]	; (400580 <NVIC_SetPriority+0x50>)
  40055e:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400562:	683a      	ldr	r2, [r7, #0]
  400564:	b2d2      	uxtb	r2, r2
  400566:	0112      	lsls	r2, r2, #4
  400568:	b2d2      	uxtb	r2, r2
  40056a:	440b      	add	r3, r1
  40056c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  400570:	bf00      	nop
  400572:	370c      	adds	r7, #12
  400574:	46bd      	mov	sp, r7
  400576:	f85d 7b04 	ldr.w	r7, [sp], #4
  40057a:	4770      	bx	lr
  40057c:	e000ed00 	.word	0xe000ed00
  400580:	e000e100 	.word	0xe000e100

00400584 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  400584:	b480      	push	{r7}
  400586:	b083      	sub	sp, #12
  400588:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40058a:	f3ef 8310 	mrs	r3, PRIMASK
  40058e:	607b      	str	r3, [r7, #4]
  return(result);
  400590:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  400592:	2b00      	cmp	r3, #0
  400594:	bf0c      	ite	eq
  400596:	2301      	moveq	r3, #1
  400598:	2300      	movne	r3, #0
  40059a:	b2db      	uxtb	r3, r3
  40059c:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40059e:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4005a0:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4005a4:	4b04      	ldr	r3, [pc, #16]	; (4005b8 <cpu_irq_save+0x34>)
  4005a6:	2200      	movs	r2, #0
  4005a8:	701a      	strb	r2, [r3, #0]
	return flags;
  4005aa:	683b      	ldr	r3, [r7, #0]
}
  4005ac:	4618      	mov	r0, r3
  4005ae:	370c      	adds	r7, #12
  4005b0:	46bd      	mov	sp, r7
  4005b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005b6:	4770      	bx	lr
  4005b8:	200001aa 	.word	0x200001aa

004005bc <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  4005bc:	b480      	push	{r7}
  4005be:	b083      	sub	sp, #12
  4005c0:	af00      	add	r7, sp, #0
  4005c2:	6078      	str	r0, [r7, #4]
	return (flags);
  4005c4:	687b      	ldr	r3, [r7, #4]
  4005c6:	2b00      	cmp	r3, #0
  4005c8:	bf14      	ite	ne
  4005ca:	2301      	movne	r3, #1
  4005cc:	2300      	moveq	r3, #0
  4005ce:	b2db      	uxtb	r3, r3
}
  4005d0:	4618      	mov	r0, r3
  4005d2:	370c      	adds	r7, #12
  4005d4:	46bd      	mov	sp, r7
  4005d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005da:	4770      	bx	lr

004005dc <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  4005dc:	b580      	push	{r7, lr}
  4005de:	b082      	sub	sp, #8
  4005e0:	af00      	add	r7, sp, #0
  4005e2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4005e4:	6878      	ldr	r0, [r7, #4]
  4005e6:	4b07      	ldr	r3, [pc, #28]	; (400604 <cpu_irq_restore+0x28>)
  4005e8:	4798      	blx	r3
  4005ea:	4603      	mov	r3, r0
  4005ec:	2b00      	cmp	r3, #0
  4005ee:	d005      	beq.n	4005fc <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4005f0:	4b05      	ldr	r3, [pc, #20]	; (400608 <cpu_irq_restore+0x2c>)
  4005f2:	2201      	movs	r2, #1
  4005f4:	701a      	strb	r2, [r3, #0]
  4005f6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4005fa:	b662      	cpsie	i
}
  4005fc:	bf00      	nop
  4005fe:	3708      	adds	r7, #8
  400600:	46bd      	mov	sp, r7
  400602:	bd80      	pop	{r7, pc}
  400604:	004005bd 	.word	0x004005bd
  400608:	200001aa 	.word	0x200001aa

0040060c <afec_ch_sanity_check>:
{
  40060c:	b480      	push	{r7}
  40060e:	b083      	sub	sp, #12
  400610:	af00      	add	r7, sp, #0
  400612:	6078      	str	r0, [r7, #4]
  400614:	460b      	mov	r3, r1
  400616:	807b      	strh	r3, [r7, #2]
}
  400618:	bf00      	nop
  40061a:	370c      	adds	r7, #12
  40061c:	46bd      	mov	sp, r7
  40061e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400622:	4770      	bx	lr

00400624 <afec_get_interrupt_status>:
{
  400624:	b480      	push	{r7}
  400626:	b083      	sub	sp, #12
  400628:	af00      	add	r7, sp, #0
  40062a:	6078      	str	r0, [r7, #4]
	return afec->AFEC_ISR;
  40062c:	687b      	ldr	r3, [r7, #4]
  40062e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  400630:	4618      	mov	r0, r3
  400632:	370c      	adds	r7, #12
  400634:	46bd      	mov	sp, r7
  400636:	f85d 7b04 	ldr.w	r7, [sp], #4
  40063a:	4770      	bx	lr

0040063c <afec_get_interrupt_mask>:
{
  40063c:	b480      	push	{r7}
  40063e:	b083      	sub	sp, #12
  400640:	af00      	add	r7, sp, #0
  400642:	6078      	str	r0, [r7, #4]
	return afec->AFEC_IMR;
  400644:	687b      	ldr	r3, [r7, #4]
  400646:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  400648:	4618      	mov	r0, r3
  40064a:	370c      	adds	r7, #12
  40064c:	46bd      	mov	sp, r7
  40064e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400652:	4770      	bx	lr

00400654 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
  400654:	b580      	push	{r7, lr}
  400656:	b084      	sub	sp, #16
  400658:	af00      	add	r7, sp, #0
  40065a:	4603      	mov	r3, r0
  40065c:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  40065e:	79fb      	ldrb	r3, [r7, #7]
  400660:	4a0a      	ldr	r2, [pc, #40]	; (40068c <sleepmgr_lock_mode+0x38>)
  400662:	5cd3      	ldrb	r3, [r2, r3]
  400664:	2bff      	cmp	r3, #255	; 0xff
  400666:	d100      	bne.n	40066a <sleepmgr_lock_mode+0x16>
		while (true) {
  400668:	e7fe      	b.n	400668 <sleepmgr_lock_mode+0x14>
			// Check APP or change the data type to uint16_t.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  40066a:	4b09      	ldr	r3, [pc, #36]	; (400690 <sleepmgr_lock_mode+0x3c>)
  40066c:	4798      	blx	r3
  40066e:	60f8      	str	r0, [r7, #12]

	++sleepmgr_locks[mode];
  400670:	79fb      	ldrb	r3, [r7, #7]
  400672:	4a06      	ldr	r2, [pc, #24]	; (40068c <sleepmgr_lock_mode+0x38>)
  400674:	5cd2      	ldrb	r2, [r2, r3]
  400676:	3201      	adds	r2, #1
  400678:	b2d1      	uxtb	r1, r2
  40067a:	4a04      	ldr	r2, [pc, #16]	; (40068c <sleepmgr_lock_mode+0x38>)
  40067c:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  40067e:	68f8      	ldr	r0, [r7, #12]
  400680:	4b04      	ldr	r3, [pc, #16]	; (400694 <sleepmgr_lock_mode+0x40>)
  400682:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  400684:	bf00      	nop
  400686:	3710      	adds	r7, #16
  400688:	46bd      	mov	sp, r7
  40068a:	bd80      	pop	{r7, pc}
  40068c:	20008964 	.word	0x20008964
  400690:	00400585 	.word	0x00400585
  400694:	004005dd 	.word	0x004005dd

00400698 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400698:	b480      	push	{r7}
  40069a:	b083      	sub	sp, #12
  40069c:	af00      	add	r7, sp, #0
  40069e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4006a0:	687b      	ldr	r3, [r7, #4]
  4006a2:	2b07      	cmp	r3, #7
  4006a4:	d825      	bhi.n	4006f2 <osc_get_rate+0x5a>
  4006a6:	a201      	add	r2, pc, #4	; (adr r2, 4006ac <osc_get_rate+0x14>)
  4006a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4006ac:	004006cd 	.word	0x004006cd
  4006b0:	004006d3 	.word	0x004006d3
  4006b4:	004006d9 	.word	0x004006d9
  4006b8:	004006df 	.word	0x004006df
  4006bc:	004006e3 	.word	0x004006e3
  4006c0:	004006e7 	.word	0x004006e7
  4006c4:	004006eb 	.word	0x004006eb
  4006c8:	004006ef 	.word	0x004006ef
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  4006cc:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  4006d0:	e010      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  4006d2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4006d6:	e00d      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  4006d8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4006dc:	e00a      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  4006de:	4b08      	ldr	r3, [pc, #32]	; (400700 <osc_get_rate+0x68>)
  4006e0:	e008      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  4006e2:	4b08      	ldr	r3, [pc, #32]	; (400704 <osc_get_rate+0x6c>)
  4006e4:	e006      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  4006e6:	4b08      	ldr	r3, [pc, #32]	; (400708 <osc_get_rate+0x70>)
  4006e8:	e004      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  4006ea:	4b07      	ldr	r3, [pc, #28]	; (400708 <osc_get_rate+0x70>)
  4006ec:	e002      	b.n	4006f4 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  4006ee:	4b06      	ldr	r3, [pc, #24]	; (400708 <osc_get_rate+0x70>)
  4006f0:	e000      	b.n	4006f4 <osc_get_rate+0x5c>
	}

	return 0;
  4006f2:	2300      	movs	r3, #0
}
  4006f4:	4618      	mov	r0, r3
  4006f6:	370c      	adds	r7, #12
  4006f8:	46bd      	mov	sp, r7
  4006fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4006fe:	4770      	bx	lr
  400700:	003d0900 	.word	0x003d0900
  400704:	007a1200 	.word	0x007a1200
  400708:	00b71b00 	.word	0x00b71b00

0040070c <sysclk_get_main_hz>:
{
  40070c:	b580      	push	{r7, lr}
  40070e:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  400710:	2006      	movs	r0, #6
  400712:	4b03      	ldr	r3, [pc, #12]	; (400720 <sysclk_get_main_hz+0x14>)
  400714:	4798      	blx	r3
  400716:	4603      	mov	r3, r0
  400718:	011b      	lsls	r3, r3, #4
}
  40071a:	4618      	mov	r0, r3
  40071c:	bd80      	pop	{r7, pc}
  40071e:	bf00      	nop
  400720:	00400699 	.word	0x00400699

00400724 <sysclk_get_cpu_hz>:
{
  400724:	b580      	push	{r7, lr}
  400726:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  400728:	4b02      	ldr	r3, [pc, #8]	; (400734 <sysclk_get_cpu_hz+0x10>)
  40072a:	4798      	blx	r3
  40072c:	4603      	mov	r3, r0
  40072e:	085b      	lsrs	r3, r3, #1
}
  400730:	4618      	mov	r0, r3
  400732:	bd80      	pop	{r7, pc}
  400734:	0040070d 	.word	0x0040070d

00400738 <afec_find_inst_num>:
 * \param afec  Base address of the AFEC
 *
 * \return   AFEC instance number
 */
static uint32_t afec_find_inst_num(Afec *const afec)
{
  400738:	b480      	push	{r7}
  40073a:	b083      	sub	sp, #12
  40073c:	af00      	add	r7, sp, #0
  40073e:	6078      	str	r0, [r7, #4]
#if defined(AFEC1)
	if (afec == AFEC1) {
  400740:	687b      	ldr	r3, [r7, #4]
  400742:	4a09      	ldr	r2, [pc, #36]	; (400768 <afec_find_inst_num+0x30>)
  400744:	4293      	cmp	r3, r2
  400746:	d101      	bne.n	40074c <afec_find_inst_num+0x14>
		return 1;
  400748:	2301      	movs	r3, #1
  40074a:	e006      	b.n	40075a <afec_find_inst_num+0x22>
	}
#endif
#if defined(AFEC0)
	if (afec == AFEC0) {
  40074c:	687b      	ldr	r3, [r7, #4]
  40074e:	4a07      	ldr	r2, [pc, #28]	; (40076c <afec_find_inst_num+0x34>)
  400750:	4293      	cmp	r3, r2
  400752:	d101      	bne.n	400758 <afec_find_inst_num+0x20>
		return 0;
  400754:	2300      	movs	r3, #0
  400756:	e000      	b.n	40075a <afec_find_inst_num+0x22>
	}
#endif
	return 0;
  400758:	2300      	movs	r3, #0
}
  40075a:	4618      	mov	r0, r3
  40075c:	370c      	adds	r7, #12
  40075e:	46bd      	mov	sp, r7
  400760:	f85d 7b04 	ldr.w	r7, [sp], #4
  400764:	4770      	bx	lr
  400766:	bf00      	nop
  400768:	400b4000 	.word	0x400b4000
  40076c:	400b0000 	.word	0x400b0000

00400770 <afec_find_pid>:
 * \param afec  Base address of the AFEC
 *
 * \return   AFEC Peripheral ID
 */
static uint32_t afec_find_pid(Afec *const afec)
{
  400770:	b480      	push	{r7}
  400772:	b083      	sub	sp, #12
  400774:	af00      	add	r7, sp, #0
  400776:	6078      	str	r0, [r7, #4]
#if defined(ID_AFEC1)
	if (afec == AFEC1) {
  400778:	687b      	ldr	r3, [r7, #4]
  40077a:	4a09      	ldr	r2, [pc, #36]	; (4007a0 <afec_find_pid+0x30>)
  40077c:	4293      	cmp	r3, r2
  40077e:	d101      	bne.n	400784 <afec_find_pid+0x14>
		return ID_AFEC1;
  400780:	231f      	movs	r3, #31
  400782:	e006      	b.n	400792 <afec_find_pid+0x22>
	}
#endif
#if defined(ID_AFEC0)
	if (afec == AFEC0) {
  400784:	687b      	ldr	r3, [r7, #4]
  400786:	4a07      	ldr	r2, [pc, #28]	; (4007a4 <afec_find_pid+0x34>)
  400788:	4293      	cmp	r3, r2
  40078a:	d101      	bne.n	400790 <afec_find_pid+0x20>
		return ID_AFEC0;
  40078c:	231e      	movs	r3, #30
  40078e:	e000      	b.n	400792 <afec_find_pid+0x22>
	}
#endif
	return ID_AFEC0;
  400790:	231e      	movs	r3, #30
}
  400792:	4618      	mov	r0, r3
  400794:	370c      	adds	r7, #12
  400796:	46bd      	mov	sp, r7
  400798:	f85d 7b04 	ldr.w	r7, [sp], #4
  40079c:	4770      	bx	lr
  40079e:	bf00      	nop
  4007a0:	400b4000 	.word	0x400b4000
  4007a4:	400b0000 	.word	0x400b0000

004007a8 <afec_set_config>:
 *
 * \param afec  Base address of the AFEC
 * \param config   Configuration for the AFEC
 */
static void afec_set_config(Afec *const afec, struct afec_config *config)
{
  4007a8:	b480      	push	{r7}
  4007aa:	b085      	sub	sp, #20
  4007ac:	af00      	add	r7, sp, #0
  4007ae:	6078      	str	r0, [r7, #4]
  4007b0:	6039      	str	r1, [r7, #0]
	uint32_t reg = 0;
  4007b2:	2300      	movs	r3, #0
  4007b4:	60fb      	str	r3, [r7, #12]

	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4007b6:	683b      	ldr	r3, [r7, #0]
  4007b8:	7ddb      	ldrb	r3, [r3, #23]
  4007ba:	2b00      	cmp	r3, #0
  4007bc:	d002      	beq.n	4007c4 <afec_set_config+0x1c>
  4007be:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  4007c2:	e000      	b.n	4007c6 <afec_set_config+0x1e>
  4007c4:	2200      	movs	r2, #0
		#if (SAMV71 || SAMV70 || SAME70 || SAMS70)
			AFEC_MR_PRESCAL((config->mck / config->afec_clock )- 1) |
			AFEC_MR_ONE |
		#else
			(config->anach ? AFEC_MR_ANACH_ALLOWED : 0) |
  4007c6:	683b      	ldr	r3, [r7, #0]
  4007c8:	7d9b      	ldrb	r3, [r3, #22]
  4007ca:	2b00      	cmp	r3, #0
  4007cc:	d002      	beq.n	4007d4 <afec_set_config+0x2c>
  4007ce:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  4007d2:	e000      	b.n	4007d6 <afec_set_config+0x2e>
  4007d4:	2300      	movs	r3, #0
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4007d6:	431a      	orrs	r2, r3
			AFEC_MR_PRESCAL(config->mck / (2 * config->afec_clock) - 1) |
  4007d8:	683b      	ldr	r3, [r7, #0]
  4007da:	6859      	ldr	r1, [r3, #4]
  4007dc:	683b      	ldr	r3, [r7, #0]
  4007de:	689b      	ldr	r3, [r3, #8]
  4007e0:	005b      	lsls	r3, r3, #1
  4007e2:	fbb1 f3f3 	udiv	r3, r1, r3
  4007e6:	3b01      	subs	r3, #1
  4007e8:	021b      	lsls	r3, r3, #8
  4007ea:	b29b      	uxth	r3, r3
			(config->anach ? AFEC_MR_ANACH_ALLOWED : 0) |
  4007ec:	431a      	orrs	r2, r3
			(config->settling_time) |		
  4007ee:	683b      	ldr	r3, [r7, #0]
  4007f0:	691b      	ldr	r3, [r3, #16]
			AFEC_MR_PRESCAL(config->mck / (2 * config->afec_clock) - 1) |
  4007f2:	431a      	orrs	r2, r3
		#endif
			AFEC_MR_TRACKTIM(config->tracktim) |
  4007f4:	683b      	ldr	r3, [r7, #0]
  4007f6:	7d1b      	ldrb	r3, [r3, #20]
  4007f8:	061b      	lsls	r3, r3, #24
  4007fa:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
			(config->settling_time) |		
  4007fe:	431a      	orrs	r2, r3
			AFEC_MR_TRANSFER(config->transfer) |
  400800:	683b      	ldr	r3, [r7, #0]
  400802:	7d5b      	ldrb	r3, [r3, #21]
  400804:	071b      	lsls	r3, r3, #28
  400806:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
			AFEC_MR_TRACKTIM(config->tracktim) |
  40080a:	431a      	orrs	r2, r3
			(config->startup_time);
  40080c:	683b      	ldr	r3, [r7, #0]
  40080e:	68db      	ldr	r3, [r3, #12]
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  400810:	4313      	orrs	r3, r2
  400812:	60fb      	str	r3, [r7, #12]

	afec->AFEC_MR = reg;
  400814:	687b      	ldr	r3, [r7, #4]
  400816:	68fa      	ldr	r2, [r7, #12]
  400818:	605a      	str	r2, [r3, #4]

	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  40081a:	683b      	ldr	r3, [r7, #0]
  40081c:	7e1b      	ldrb	r3, [r3, #24]
  40081e:	2b00      	cmp	r3, #0
  400820:	d002      	beq.n	400828 <afec_set_config+0x80>
  400822:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  400826:	e000      	b.n	40082a <afec_set_config+0x82>
  400828:	2200      	movs	r2, #0
			(config->resolution) |
  40082a:	683b      	ldr	r3, [r7, #0]
  40082c:	681b      	ldr	r3, [r3, #0]
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  40082e:	431a      	orrs	r2, r3
			(config->stm ? AFEC_EMR_STM : 0);
  400830:	683b      	ldr	r3, [r7, #0]
  400832:	7e5b      	ldrb	r3, [r3, #25]
  400834:	2b00      	cmp	r3, #0
  400836:	d002      	beq.n	40083e <afec_set_config+0x96>
  400838:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  40083c:	e000      	b.n	400840 <afec_set_config+0x98>
  40083e:	2300      	movs	r3, #0
			(config->resolution) |
  400840:	431a      	orrs	r2, r3
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  400842:	687b      	ldr	r3, [r7, #4]
  400844:	609a      	str	r2, [r3, #8]
  #if (SAMV71 || SAMV70 || SAME70 || SAMS70)
	afec->AFEC_ACR = AFEC_ACR_IBCTL(config->ibctl) | AFEC_ACR_PGA0EN | AFEC_ACR_PGA1EN;
  #else
    afec->AFEC_ACR = AFEC_ACR_IBCTL(config->ibctl);
  400846:	683b      	ldr	r3, [r7, #0]
  400848:	7e9b      	ldrb	r3, [r3, #26]
  40084a:	021b      	lsls	r3, r3, #8
  40084c:	f403 7240 	and.w	r2, r3, #768	; 0x300
  400850:	687b      	ldr	r3, [r7, #4]
  400852:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  #endif
}
  400856:	bf00      	nop
  400858:	3714      	adds	r7, #20
  40085a:	46bd      	mov	sp, r7
  40085c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400860:	4770      	bx	lr
	...

00400864 <afec_ch_set_config>:
 * \param channel The channel number
 * \param config   Configuration for the AFEC channel
 */
void afec_ch_set_config(Afec *const afec, const enum afec_channel_num channel,
		struct afec_ch_config *config)
{
  400864:	b580      	push	{r7, lr}
  400866:	b086      	sub	sp, #24
  400868:	af00      	add	r7, sp, #0
  40086a:	60f8      	str	r0, [r7, #12]
  40086c:	460b      	mov	r3, r1
  40086e:	607a      	str	r2, [r7, #4]
  400870:	817b      	strh	r3, [r7, #10]
	afec_ch_sanity_check(afec, channel);
  400872:	897b      	ldrh	r3, [r7, #10]
  400874:	4619      	mov	r1, r3
  400876:	68f8      	ldr	r0, [r7, #12]
  400878:	4b1e      	ldr	r3, [pc, #120]	; (4008f4 <afec_ch_set_config+0x90>)
  40087a:	4798      	blx	r3
	uint32_t reg = 0;
  40087c:	2300      	movs	r3, #0
  40087e:	617b      	str	r3, [r7, #20]

	reg = afec->AFEC_DIFFR;
  400880:	68fb      	ldr	r3, [r7, #12]
  400882:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  400884:	617b      	str	r3, [r7, #20]
	reg &= ~(0x1u << channel);
  400886:	897b      	ldrh	r3, [r7, #10]
  400888:	2201      	movs	r2, #1
  40088a:	fa02 f303 	lsl.w	r3, r2, r3
  40088e:	43db      	mvns	r3, r3
  400890:	697a      	ldr	r2, [r7, #20]
  400892:	4013      	ands	r3, r2
  400894:	617b      	str	r3, [r7, #20]
	reg |= (config->diff) ? (0x1u << channel) : 0;
  400896:	687b      	ldr	r3, [r7, #4]
  400898:	781b      	ldrb	r3, [r3, #0]
  40089a:	2b00      	cmp	r3, #0
  40089c:	d004      	beq.n	4008a8 <afec_ch_set_config+0x44>
  40089e:	897b      	ldrh	r3, [r7, #10]
  4008a0:	2201      	movs	r2, #1
  4008a2:	fa02 f303 	lsl.w	r3, r2, r3
  4008a6:	e000      	b.n	4008aa <afec_ch_set_config+0x46>
  4008a8:	2300      	movs	r3, #0
  4008aa:	697a      	ldr	r2, [r7, #20]
  4008ac:	4313      	orrs	r3, r2
  4008ae:	617b      	str	r3, [r7, #20]
	afec->AFEC_DIFFR = reg;
  4008b0:	68fb      	ldr	r3, [r7, #12]
  4008b2:	697a      	ldr	r2, [r7, #20]
  4008b4:	661a      	str	r2, [r3, #96]	; 0x60

	reg = afec->AFEC_CGR;
  4008b6:	68fb      	ldr	r3, [r7, #12]
  4008b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  4008ba:	617b      	str	r3, [r7, #20]
	reg &= ~(0x03u << (2 * channel));
  4008bc:	897b      	ldrh	r3, [r7, #10]
  4008be:	005b      	lsls	r3, r3, #1
  4008c0:	2203      	movs	r2, #3
  4008c2:	fa02 f303 	lsl.w	r3, r2, r3
  4008c6:	43db      	mvns	r3, r3
  4008c8:	697a      	ldr	r2, [r7, #20]
  4008ca:	4013      	ands	r3, r2
  4008cc:	617b      	str	r3, [r7, #20]
	reg |= (config->gain) << (2 * channel);
  4008ce:	687b      	ldr	r3, [r7, #4]
  4008d0:	785b      	ldrb	r3, [r3, #1]
  4008d2:	461a      	mov	r2, r3
  4008d4:	897b      	ldrh	r3, [r7, #10]
  4008d6:	005b      	lsls	r3, r3, #1
  4008d8:	fa02 f303 	lsl.w	r3, r2, r3
  4008dc:	461a      	mov	r2, r3
  4008de:	697b      	ldr	r3, [r7, #20]
  4008e0:	4313      	orrs	r3, r2
  4008e2:	617b      	str	r3, [r7, #20]
	afec->AFEC_CGR = reg;
  4008e4:	68fb      	ldr	r3, [r7, #12]
  4008e6:	697a      	ldr	r2, [r7, #20]
  4008e8:	655a      	str	r2, [r3, #84]	; 0x54
}
  4008ea:	bf00      	nop
  4008ec:	3718      	adds	r7, #24
  4008ee:	46bd      	mov	sp, r7
  4008f0:	bd80      	pop	{r7, pc}
  4008f2:	bf00      	nop
  4008f4:	0040060d 	.word	0x0040060d

004008f8 <afec_get_config_defaults>:
 * - AFE Bias Current Control value is 1
 *
 * \param cfg Pointer to configuration structure to be initiated.
 */
void afec_get_config_defaults(struct afec_config *const cfg)
{
  4008f8:	b580      	push	{r7, lr}
  4008fa:	b082      	sub	sp, #8
  4008fc:	af00      	add	r7, sp, #0
  4008fe:	6078      	str	r0, [r7, #4]
	/* Sanity check argument. */
	Assert(cfg);

	cfg->resolution = AFEC_12_BITS;
  400900:	687b      	ldr	r3, [r7, #4]
  400902:	2200      	movs	r2, #0
  400904:	601a      	str	r2, [r3, #0]
	cfg->mck = sysclk_get_cpu_hz();
  400906:	4b14      	ldr	r3, [pc, #80]	; (400958 <afec_get_config_defaults+0x60>)
  400908:	4798      	blx	r3
  40090a:	4602      	mov	r2, r0
  40090c:	687b      	ldr	r3, [r7, #4]
  40090e:	605a      	str	r2, [r3, #4]
		cfg->afec_clock = 6000000UL;
  400910:	687b      	ldr	r3, [r7, #4]
  400912:	4a12      	ldr	r2, [pc, #72]	; (40095c <afec_get_config_defaults+0x64>)
  400914:	609a      	str	r2, [r3, #8]
		cfg->startup_time = AFEC_STARTUP_TIME_4;
  400916:	687b      	ldr	r3, [r7, #4]
  400918:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  40091c:	60da      	str	r2, [r3, #12]
	#if !(SAMV71 || SAMV70 || SAME70 || SAMS70)
		cfg->settling_time = AFEC_SETTLING_TIME_0;
  40091e:	687b      	ldr	r3, [r7, #4]
  400920:	2200      	movs	r2, #0
  400922:	611a      	str	r2, [r3, #16]
	#endif	
		cfg->tracktim = 2;
  400924:	687b      	ldr	r3, [r7, #4]
  400926:	2202      	movs	r2, #2
  400928:	751a      	strb	r2, [r3, #20]
		cfg->transfer = 1;
  40092a:	687b      	ldr	r3, [r7, #4]
  40092c:	2201      	movs	r2, #1
  40092e:	755a      	strb	r2, [r3, #21]
		cfg->anach = true;
  400930:	687b      	ldr	r3, [r7, #4]
  400932:	2201      	movs	r2, #1
  400934:	759a      	strb	r2, [r3, #22]
		cfg->useq = false;
  400936:	687b      	ldr	r3, [r7, #4]
  400938:	2200      	movs	r2, #0
  40093a:	75da      	strb	r2, [r3, #23]
		cfg->tag = true;
  40093c:	687b      	ldr	r3, [r7, #4]
  40093e:	2201      	movs	r2, #1
  400940:	761a      	strb	r2, [r3, #24]
		cfg->stm = true;
  400942:	687b      	ldr	r3, [r7, #4]
  400944:	2201      	movs	r2, #1
  400946:	765a      	strb	r2, [r3, #25]
		cfg->ibctl = 1;
  400948:	687b      	ldr	r3, [r7, #4]
  40094a:	2201      	movs	r2, #1
  40094c:	769a      	strb	r2, [r3, #26]
}
  40094e:	bf00      	nop
  400950:	3708      	adds	r7, #8
  400952:	46bd      	mov	sp, r7
  400954:	bd80      	pop	{r7, pc}
  400956:	bf00      	nop
  400958:	00400725 	.word	0x00400725
  40095c:	005b8d80 	.word	0x005b8d80

00400960 <afec_init>:
 *
 * \retval STATUS_OK  Initialization is finished.
 * \retval STATUS_ERR_BUSY  Initialization failed.
 */
enum status_code afec_init(Afec *const afec, struct afec_config *config)
{
  400960:	b580      	push	{r7, lr}
  400962:	b084      	sub	sp, #16
  400964:	af00      	add	r7, sp, #0
  400966:	6078      	str	r0, [r7, #4]
  400968:	6039      	str	r1, [r7, #0]
	Assert(afec);
	Assert(config);

	if ((afec_get_interrupt_status(afec) & AFEC_ISR_DRDY) == AFEC_ISR_DRDY) {
  40096a:	6878      	ldr	r0, [r7, #4]
  40096c:	4b1d      	ldr	r3, [pc, #116]	; (4009e4 <afec_init+0x84>)
  40096e:	4798      	blx	r3
  400970:	4603      	mov	r3, r0
  400972:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  400976:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  40097a:	d101      	bne.n	400980 <afec_init+0x20>
		return STATUS_ERR_BUSY;
  40097c:	2319      	movs	r3, #25
  40097e:	e02c      	b.n	4009da <afec_init+0x7a>
	}

	/* Reset and configure the AFEC module */
	afec->AFEC_CR = AFEC_CR_SWRST;
  400980:	687b      	ldr	r3, [r7, #4]
  400982:	2201      	movs	r2, #1
  400984:	601a      	str	r2, [r3, #0]
	afec_set_config(afec, config);
  400986:	6839      	ldr	r1, [r7, #0]
  400988:	6878      	ldr	r0, [r7, #4]
  40098a:	4b17      	ldr	r3, [pc, #92]	; (4009e8 <afec_init+0x88>)
  40098c:	4798      	blx	r3

	uint32_t i;
	if(afec == AFEC0) {
  40098e:	687b      	ldr	r3, [r7, #4]
  400990:	4a16      	ldr	r2, [pc, #88]	; (4009ec <afec_init+0x8c>)
  400992:	4293      	cmp	r3, r2
  400994:	d10d      	bne.n	4009b2 <afec_init+0x52>
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  400996:	2300      	movs	r3, #0
  400998:	60fb      	str	r3, [r7, #12]
  40099a:	e007      	b.n	4009ac <afec_init+0x4c>
			afec_callback_pointer[0][i] = 0;
  40099c:	4a14      	ldr	r2, [pc, #80]	; (4009f0 <afec_init+0x90>)
  40099e:	68fb      	ldr	r3, [r7, #12]
  4009a0:	2100      	movs	r1, #0
  4009a2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  4009a6:	68fb      	ldr	r3, [r7, #12]
  4009a8:	3301      	adds	r3, #1
  4009aa:	60fb      	str	r3, [r7, #12]
  4009ac:	68fb      	ldr	r3, [r7, #12]
  4009ae:	2b0d      	cmp	r3, #13
  4009b0:	d9f4      	bls.n	40099c <afec_init+0x3c>
		}
	}
	if(afec == AFEC1) {
  4009b2:	687b      	ldr	r3, [r7, #4]
  4009b4:	4a0f      	ldr	r2, [pc, #60]	; (4009f4 <afec_init+0x94>)
  4009b6:	4293      	cmp	r3, r2
  4009b8:	d10e      	bne.n	4009d8 <afec_init+0x78>
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  4009ba:	2300      	movs	r3, #0
  4009bc:	60fb      	str	r3, [r7, #12]
  4009be:	e008      	b.n	4009d2 <afec_init+0x72>
			afec_callback_pointer[1][i] = 0;
  4009c0:	4a0b      	ldr	r2, [pc, #44]	; (4009f0 <afec_init+0x90>)
  4009c2:	68fb      	ldr	r3, [r7, #12]
  4009c4:	330e      	adds	r3, #14
  4009c6:	2100      	movs	r1, #0
  4009c8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  4009cc:	68fb      	ldr	r3, [r7, #12]
  4009ce:	3301      	adds	r3, #1
  4009d0:	60fb      	str	r3, [r7, #12]
  4009d2:	68fb      	ldr	r3, [r7, #12]
  4009d4:	2b0d      	cmp	r3, #13
  4009d6:	d9f3      	bls.n	4009c0 <afec_init+0x60>
		}
	}

	return STATUS_OK;
  4009d8:	2300      	movs	r3, #0
}
  4009da:	4618      	mov	r0, r3
  4009dc:	3710      	adds	r7, #16
  4009de:	46bd      	mov	sp, r7
  4009e0:	bd80      	pop	{r7, pc}
  4009e2:	bf00      	nop
  4009e4:	00400625 	.word	0x00400625
  4009e8:	004007a9 	.word	0x004007a9
  4009ec:	400b0000 	.word	0x400b0000
  4009f0:	200088bc 	.word	0x200088bc
  4009f4:	400b4000 	.word	0x400b4000

004009f8 <afec_set_callback>:
 * \param callback  Callback function pointer
 * \param irq_level Interrupt level
 */
void afec_set_callback(Afec *const afec, enum afec_interrupt_source source,
		afec_callback_t callback, uint8_t irq_level)
{
  4009f8:	b580      	push	{r7, lr}
  4009fa:	b086      	sub	sp, #24
  4009fc:	af00      	add	r7, sp, #0
  4009fe:	60f8      	str	r0, [r7, #12]
  400a00:	60b9      	str	r1, [r7, #8]
  400a02:	607a      	str	r2, [r7, #4]
  400a04:	70fb      	strb	r3, [r7, #3]
	Assert(afec);
	Assert(callback);

	uint32_t i = afec_find_inst_num(afec);
  400a06:	68f8      	ldr	r0, [r7, #12]
  400a08:	4b19      	ldr	r3, [pc, #100]	; (400a70 <afec_set_callback+0x78>)
  400a0a:	4798      	blx	r3
  400a0c:	6178      	str	r0, [r7, #20]
	afec_callback_pointer[i][source] = callback;
  400a0e:	4919      	ldr	r1, [pc, #100]	; (400a74 <afec_set_callback+0x7c>)
  400a10:	697a      	ldr	r2, [r7, #20]
  400a12:	4613      	mov	r3, r2
  400a14:	00db      	lsls	r3, r3, #3
  400a16:	1a9b      	subs	r3, r3, r2
  400a18:	005b      	lsls	r3, r3, #1
  400a1a:	68ba      	ldr	r2, [r7, #8]
  400a1c:	4413      	add	r3, r2
  400a1e:	687a      	ldr	r2, [r7, #4]
  400a20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	if (!i) {
  400a24:	697b      	ldr	r3, [r7, #20]
  400a26:	2b00      	cmp	r3, #0
  400a28:	d10b      	bne.n	400a42 <afec_set_callback+0x4a>
		irq_register_handler(AFEC0_IRQn, irq_level);
  400a2a:	201e      	movs	r0, #30
  400a2c:	4b12      	ldr	r3, [pc, #72]	; (400a78 <afec_set_callback+0x80>)
  400a2e:	4798      	blx	r3
  400a30:	78fb      	ldrb	r3, [r7, #3]
  400a32:	4619      	mov	r1, r3
  400a34:	201e      	movs	r0, #30
  400a36:	4b11      	ldr	r3, [pc, #68]	; (400a7c <afec_set_callback+0x84>)
  400a38:	4798      	blx	r3
  400a3a:	201e      	movs	r0, #30
  400a3c:	4b10      	ldr	r3, [pc, #64]	; (400a80 <afec_set_callback+0x88>)
  400a3e:	4798      	blx	r3
  400a40:	e00d      	b.n	400a5e <afec_set_callback+0x66>
	} else if (i == 1) {
  400a42:	697b      	ldr	r3, [r7, #20]
  400a44:	2b01      	cmp	r3, #1
  400a46:	d10a      	bne.n	400a5e <afec_set_callback+0x66>
		irq_register_handler(AFEC1_IRQn, irq_level);
  400a48:	201f      	movs	r0, #31
  400a4a:	4b0b      	ldr	r3, [pc, #44]	; (400a78 <afec_set_callback+0x80>)
  400a4c:	4798      	blx	r3
  400a4e:	78fb      	ldrb	r3, [r7, #3]
  400a50:	4619      	mov	r1, r3
  400a52:	201f      	movs	r0, #31
  400a54:	4b09      	ldr	r3, [pc, #36]	; (400a7c <afec_set_callback+0x84>)
  400a56:	4798      	blx	r3
  400a58:	201f      	movs	r0, #31
  400a5a:	4b09      	ldr	r3, [pc, #36]	; (400a80 <afec_set_callback+0x88>)
  400a5c:	4798      	blx	r3
	}
	/* Enable the specified interrupt source */
	afec_enable_interrupt(afec, source);
  400a5e:	68b9      	ldr	r1, [r7, #8]
  400a60:	68f8      	ldr	r0, [r7, #12]
  400a62:	4b08      	ldr	r3, [pc, #32]	; (400a84 <afec_set_callback+0x8c>)
  400a64:	4798      	blx	r3
}
  400a66:	bf00      	nop
  400a68:	3718      	adds	r7, #24
  400a6a:	46bd      	mov	sp, r7
  400a6c:	bd80      	pop	{r7, pc}
  400a6e:	bf00      	nop
  400a70:	00400739 	.word	0x00400739
  400a74:	200088bc 	.word	0x200088bc
  400a78:	004004fd 	.word	0x004004fd
  400a7c:	00400531 	.word	0x00400531
  400a80:	004004c9 	.word	0x004004c9
  400a84:	00400a89 	.word	0x00400a89

00400a88 <afec_enable_interrupt>:
 * \param afec  Base address of the AFEC.
 * \param interrupt_source Interrupts to be enabled.
 */
void afec_enable_interrupt(Afec *const afec,
		enum afec_interrupt_source interrupt_source)
{
  400a88:	b480      	push	{r7}
  400a8a:	b083      	sub	sp, #12
  400a8c:	af00      	add	r7, sp, #0
  400a8e:	6078      	str	r0, [r7, #4]
  400a90:	6039      	str	r1, [r7, #0]
	if (interrupt_source == AFEC_INTERRUPT_ALL) {
  400a92:	683b      	ldr	r3, [r7, #0]
  400a94:	4a19      	ldr	r2, [pc, #100]	; (400afc <afec_enable_interrupt+0x74>)
  400a96:	4293      	cmp	r3, r2
  400a98:	d103      	bne.n	400aa2 <afec_enable_interrupt+0x1a>
		afec->AFEC_IER = AFEC_INTERRUPT_ALL;
  400a9a:	687b      	ldr	r3, [r7, #4]
  400a9c:	4a17      	ldr	r2, [pc, #92]	; (400afc <afec_enable_interrupt+0x74>)
  400a9e:	625a      	str	r2, [r3, #36]	; 0x24
		return;
  400aa0:	e026      	b.n	400af0 <afec_enable_interrupt+0x68>
	}

	if (interrupt_source < AFEC_INTERRUPT_DATA_READY) {
  400aa2:	683b      	ldr	r3, [r7, #0]
  400aa4:	2b06      	cmp	r3, #6
  400aa6:	d80f      	bhi.n	400ac8 <afec_enable_interrupt+0x40>
	  #if (SAMV71 || SAMV70 || SAME70 || SAMS70)
		if (interrupt_source == AFEC_INTERRUPT_EOC_11) {
			afec->AFEC_IER = 1 << AFEC_TEMP_INT_SOURCE_NUM;
	  #else
		if (interrupt_source == AFEC_INTERRUPT_EOC_15) {
  400aa8:	683b      	ldr	r3, [r7, #0]
  400aaa:	2b06      	cmp	r3, #6
  400aac:	d104      	bne.n	400ab8 <afec_enable_interrupt+0x30>
			afec->AFEC_IER = 1 << AFEC_TEMP_INT_SOURCE_NUM;	  
  400aae:	687b      	ldr	r3, [r7, #4]
  400ab0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  400ab4:	625a      	str	r2, [r3, #36]	; 0x24
  400ab6:	e01b      	b.n	400af0 <afec_enable_interrupt+0x68>
	  #endif 
		} else {
			afec->AFEC_IER = 1 << interrupt_source;
  400ab8:	2201      	movs	r2, #1
  400aba:	683b      	ldr	r3, [r7, #0]
  400abc:	fa02 f303 	lsl.w	r3, r2, r3
  400ac0:	461a      	mov	r2, r3
  400ac2:	687b      	ldr	r3, [r7, #4]
  400ac4:	625a      	str	r2, [r3, #36]	; 0x24
  400ac6:	e013      	b.n	400af0 <afec_enable_interrupt+0x68>
		}
	} else if (interrupt_source < AFEC_INTERRUPT_TEMP_CHANGE) {
  400ac8:	683b      	ldr	r3, [r7, #0]
  400aca:	2b0b      	cmp	r3, #11
  400acc:	d808      	bhi.n	400ae0 <afec_enable_interrupt+0x58>
		afec->AFEC_IER = 1 << (interrupt_source + AFEC_INTERRUPT_GAP1);
  400ace:	683b      	ldr	r3, [r7, #0]
  400ad0:	3311      	adds	r3, #17
  400ad2:	2201      	movs	r2, #1
  400ad4:	fa02 f303 	lsl.w	r3, r2, r3
  400ad8:	461a      	mov	r2, r3
  400ada:	687b      	ldr	r3, [r7, #4]
  400adc:	625a      	str	r2, [r3, #36]	; 0x24
  400ade:	e007      	b.n	400af0 <afec_enable_interrupt+0x68>
	} else {
		afec->AFEC_IER = 1 << (interrupt_source + AFEC_INTERRUPT_GAP1
				+ AFEC_INTERRUPT_GAP2);
  400ae0:	683b      	ldr	r3, [r7, #0]
  400ae2:	3312      	adds	r3, #18
		afec->AFEC_IER = 1 << (interrupt_source + AFEC_INTERRUPT_GAP1
  400ae4:	2201      	movs	r2, #1
  400ae6:	fa02 f303 	lsl.w	r3, r2, r3
  400aea:	461a      	mov	r2, r3
  400aec:	687b      	ldr	r3, [r7, #4]
  400aee:	625a      	str	r2, [r3, #36]	; 0x24
	}
}
  400af0:	370c      	adds	r7, #12
  400af2:	46bd      	mov	sp, r7
  400af4:	f85d 7b04 	ldr.w	r7, [sp], #4
  400af8:	4770      	bx	lr
  400afa:	bf00      	nop
  400afc:	df00803f 	.word	0xdf00803f

00400b00 <afec_interrupt>:
 * \param inst_num AFEC instance number to handle interrupt for
 * \param source   Interrupt source number
 */
static void afec_interrupt(uint8_t inst_num,
		enum afec_interrupt_source source)
{
  400b00:	b580      	push	{r7, lr}
  400b02:	b082      	sub	sp, #8
  400b04:	af00      	add	r7, sp, #0
  400b06:	4603      	mov	r3, r0
  400b08:	6039      	str	r1, [r7, #0]
  400b0a:	71fb      	strb	r3, [r7, #7]
	if (afec_callback_pointer[inst_num][source]) {
  400b0c:	79fa      	ldrb	r2, [r7, #7]
  400b0e:	490d      	ldr	r1, [pc, #52]	; (400b44 <afec_interrupt+0x44>)
  400b10:	4613      	mov	r3, r2
  400b12:	00db      	lsls	r3, r3, #3
  400b14:	1a9b      	subs	r3, r3, r2
  400b16:	005b      	lsls	r3, r3, #1
  400b18:	683a      	ldr	r2, [r7, #0]
  400b1a:	4413      	add	r3, r2
  400b1c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  400b20:	2b00      	cmp	r3, #0
  400b22:	d00a      	beq.n	400b3a <afec_interrupt+0x3a>
		afec_callback_pointer[inst_num][source]();
  400b24:	79fa      	ldrb	r2, [r7, #7]
  400b26:	4907      	ldr	r1, [pc, #28]	; (400b44 <afec_interrupt+0x44>)
  400b28:	4613      	mov	r3, r2
  400b2a:	00db      	lsls	r3, r3, #3
  400b2c:	1a9b      	subs	r3, r3, r2
  400b2e:	005b      	lsls	r3, r3, #1
  400b30:	683a      	ldr	r2, [r7, #0]
  400b32:	4413      	add	r3, r2
  400b34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  400b38:	4798      	blx	r3
	}
}
  400b3a:	bf00      	nop
  400b3c:	3708      	adds	r7, #8
  400b3e:	46bd      	mov	sp, r7
  400b40:	bd80      	pop	{r7, pc}
  400b42:	bf00      	nop
  400b44:	200088bc 	.word	0x200088bc

00400b48 <afec_process_callback>:
 * \brief Call the callback function if the corresponding interrupt is asserted
 *
 * \param afec  Base address of the AFEC.
 */
static void afec_process_callback(Afec *const afec)
{
  400b48:	b590      	push	{r4, r7, lr}
  400b4a:	b087      	sub	sp, #28
  400b4c:	af00      	add	r7, sp, #0
  400b4e:	6078      	str	r0, [r7, #4]
	volatile uint32_t status;
	uint32_t cnt, inst_num;

	status = afec_get_interrupt_status(afec) & afec_get_interrupt_mask(afec);
  400b50:	6878      	ldr	r0, [r7, #4]
  400b52:	4b30      	ldr	r3, [pc, #192]	; (400c14 <afec_process_callback+0xcc>)
  400b54:	4798      	blx	r3
  400b56:	4604      	mov	r4, r0
  400b58:	6878      	ldr	r0, [r7, #4]
  400b5a:	4b2f      	ldr	r3, [pc, #188]	; (400c18 <afec_process_callback+0xd0>)
  400b5c:	4798      	blx	r3
  400b5e:	4603      	mov	r3, r0
  400b60:	4023      	ands	r3, r4
  400b62:	60fb      	str	r3, [r7, #12]
	inst_num = afec_find_inst_num(afec);
  400b64:	6878      	ldr	r0, [r7, #4]
  400b66:	4b2d      	ldr	r3, [pc, #180]	; (400c1c <afec_process_callback+0xd4>)
  400b68:	4798      	blx	r3
  400b6a:	6138      	str	r0, [r7, #16]

	for (cnt = 0; cnt < _AFEC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  400b6c:	2300      	movs	r3, #0
  400b6e:	617b      	str	r3, [r7, #20]
  400b70:	e048      	b.n	400c04 <afec_process_callback+0xbc>
		if (cnt < AFEC_INTERRUPT_DATA_READY) {
  400b72:	697b      	ldr	r3, [r7, #20]
  400b74:	2b06      	cmp	r3, #6
  400b76:	d81e      	bhi.n	400bb6 <afec_process_callback+0x6e>
		#if defined __SAM4E8C__  || defined __SAM4E16C__ || defined __SAM4E8CB__  || defined __SAM4E16CB__
			if(cnt == AFEC_INTERRUPT_EOC_15) {
  400b78:	697b      	ldr	r3, [r7, #20]
  400b7a:	2b06      	cmp	r3, #6
  400b7c:	d10b      	bne.n	400b96 <afec_process_callback+0x4e>
				if (status & (1 << AFEC_TEMP_INT_SOURCE_NUM)) {
  400b7e:	68fb      	ldr	r3, [r7, #12]
  400b80:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  400b84:	2b00      	cmp	r3, #0
  400b86:	d03a      	beq.n	400bfe <afec_process_callback+0xb6>
					afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
  400b88:	693b      	ldr	r3, [r7, #16]
  400b8a:	b2db      	uxtb	r3, r3
  400b8c:	6979      	ldr	r1, [r7, #20]
  400b8e:	4618      	mov	r0, r3
  400b90:	4b23      	ldr	r3, [pc, #140]	; (400c20 <afec_process_callback+0xd8>)
  400b92:	4798      	blx	r3
  400b94:	e033      	b.n	400bfe <afec_process_callback+0xb6>
				}
			} else {
				if (status & (1 << cnt)) {
  400b96:	2201      	movs	r2, #1
  400b98:	697b      	ldr	r3, [r7, #20]
  400b9a:	fa02 f303 	lsl.w	r3, r2, r3
  400b9e:	461a      	mov	r2, r3
  400ba0:	68fb      	ldr	r3, [r7, #12]
  400ba2:	4013      	ands	r3, r2
  400ba4:	2b00      	cmp	r3, #0
  400ba6:	d02a      	beq.n	400bfe <afec_process_callback+0xb6>
					afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
  400ba8:	693b      	ldr	r3, [r7, #16]
  400baa:	b2db      	uxtb	r3, r3
  400bac:	6979      	ldr	r1, [r7, #20]
  400bae:	4618      	mov	r0, r3
  400bb0:	4b1b      	ldr	r3, [pc, #108]	; (400c20 <afec_process_callback+0xd8>)
  400bb2:	4798      	blx	r3
  400bb4:	e023      	b.n	400bfe <afec_process_callback+0xb6>
		#elif defined __SAM4E8E__  || defined __SAM4E16E__ || SAMV71 || SAMV70 || SAMS70 || SAME70
			if (status & (1 << cnt)) {
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
			}
		#endif
		} else if (cnt < AFEC_INTERRUPT_TEMP_CHANGE) {
  400bb6:	697b      	ldr	r3, [r7, #20]
  400bb8:	2b0b      	cmp	r3, #11
  400bba:	d810      	bhi.n	400bde <afec_process_callback+0x96>
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1))) {
  400bbc:	697b      	ldr	r3, [r7, #20]
  400bbe:	3311      	adds	r3, #17
  400bc0:	2201      	movs	r2, #1
  400bc2:	fa02 f303 	lsl.w	r3, r2, r3
  400bc6:	461a      	mov	r2, r3
  400bc8:	68fb      	ldr	r3, [r7, #12]
  400bca:	4013      	ands	r3, r2
  400bcc:	2b00      	cmp	r3, #0
  400bce:	d016      	beq.n	400bfe <afec_process_callback+0xb6>
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
  400bd0:	693b      	ldr	r3, [r7, #16]
  400bd2:	b2db      	uxtb	r3, r3
  400bd4:	6979      	ldr	r1, [r7, #20]
  400bd6:	4618      	mov	r0, r3
  400bd8:	4b11      	ldr	r3, [pc, #68]	; (400c20 <afec_process_callback+0xd8>)
  400bda:	4798      	blx	r3
  400bdc:	e00f      	b.n	400bfe <afec_process_callback+0xb6>
			}
		} else {
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1 + AFEC_INTERRUPT_GAP2))) {
  400bde:	697b      	ldr	r3, [r7, #20]
  400be0:	3312      	adds	r3, #18
  400be2:	2201      	movs	r2, #1
  400be4:	fa02 f303 	lsl.w	r3, r2, r3
  400be8:	461a      	mov	r2, r3
  400bea:	68fb      	ldr	r3, [r7, #12]
  400bec:	4013      	ands	r3, r2
  400bee:	2b00      	cmp	r3, #0
  400bf0:	d005      	beq.n	400bfe <afec_process_callback+0xb6>
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
  400bf2:	693b      	ldr	r3, [r7, #16]
  400bf4:	b2db      	uxtb	r3, r3
  400bf6:	6979      	ldr	r1, [r7, #20]
  400bf8:	4618      	mov	r0, r3
  400bfa:	4b09      	ldr	r3, [pc, #36]	; (400c20 <afec_process_callback+0xd8>)
  400bfc:	4798      	blx	r3
	for (cnt = 0; cnt < _AFEC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  400bfe:	697b      	ldr	r3, [r7, #20]
  400c00:	3301      	adds	r3, #1
  400c02:	617b      	str	r3, [r7, #20]
  400c04:	697b      	ldr	r3, [r7, #20]
  400c06:	2b0d      	cmp	r3, #13
  400c08:	d9b3      	bls.n	400b72 <afec_process_callback+0x2a>
			}
		}
	}
}
  400c0a:	bf00      	nop
  400c0c:	371c      	adds	r7, #28
  400c0e:	46bd      	mov	sp, r7
  400c10:	bd90      	pop	{r4, r7, pc}
  400c12:	bf00      	nop
  400c14:	00400625 	.word	0x00400625
  400c18:	0040063d 	.word	0x0040063d
  400c1c:	00400739 	.word	0x00400739
  400c20:	00400b01 	.word	0x00400b01

00400c24 <AFEC0_Handler>:

/**
 * \brief Interrupt handler for AFEC0.
 */
void AFEC0_Handler(void)
{
  400c24:	b580      	push	{r7, lr}
  400c26:	af00      	add	r7, sp, #0
	afec_process_callback(AFEC0);
  400c28:	4802      	ldr	r0, [pc, #8]	; (400c34 <AFEC0_Handler+0x10>)
  400c2a:	4b03      	ldr	r3, [pc, #12]	; (400c38 <AFEC0_Handler+0x14>)
  400c2c:	4798      	blx	r3
}
  400c2e:	bf00      	nop
  400c30:	bd80      	pop	{r7, pc}
  400c32:	bf00      	nop
  400c34:	400b0000 	.word	0x400b0000
  400c38:	00400b49 	.word	0x00400b49

00400c3c <AFEC1_Handler>:

/**
 * \brief Interrupt handler for AFEC1.
 */
void AFEC1_Handler(void)
{
  400c3c:	b580      	push	{r7, lr}
  400c3e:	af00      	add	r7, sp, #0
	afec_process_callback(AFEC1);
  400c40:	4802      	ldr	r0, [pc, #8]	; (400c4c <AFEC1_Handler+0x10>)
  400c42:	4b03      	ldr	r3, [pc, #12]	; (400c50 <AFEC1_Handler+0x14>)
  400c44:	4798      	blx	r3
}
  400c46:	bf00      	nop
  400c48:	bd80      	pop	{r7, pc}
  400c4a:	bf00      	nop
  400c4c:	400b4000 	.word	0x400b4000
  400c50:	00400b49 	.word	0x00400b49

00400c54 <afec_enable>:
 * \brief Enable AFEC Module.
 *
 * \param afec  Base address of the AFEC
 */
void afec_enable(Afec *const afec)
{
  400c54:	b580      	push	{r7, lr}
  400c56:	b084      	sub	sp, #16
  400c58:	af00      	add	r7, sp, #0
  400c5a:	6078      	str	r0, [r7, #4]
	Assert(afec);
	uint32_t pid;

	pid = afec_find_pid(afec);
  400c5c:	6878      	ldr	r0, [r7, #4]
  400c5e:	4b06      	ldr	r3, [pc, #24]	; (400c78 <afec_enable+0x24>)
  400c60:	4798      	blx	r3
  400c62:	60f8      	str	r0, [r7, #12]
	/* Enable peripheral clock. */
	pmc_enable_periph_clk(pid);
  400c64:	68f8      	ldr	r0, [r7, #12]
  400c66:	4b05      	ldr	r3, [pc, #20]	; (400c7c <afec_enable+0x28>)
  400c68:	4798      	blx	r3
	sleepmgr_lock_mode(SLEEPMGR_SLEEP_WFI);
  400c6a:	2002      	movs	r0, #2
  400c6c:	4b04      	ldr	r3, [pc, #16]	; (400c80 <afec_enable+0x2c>)
  400c6e:	4798      	blx	r3
}
  400c70:	bf00      	nop
  400c72:	3710      	adds	r7, #16
  400c74:	46bd      	mov	sp, r7
  400c76:	bd80      	pop	{r7, pc}
  400c78:	00400771 	.word	0x00400771
  400c7c:	0040823d 	.word	0x0040823d
  400c80:	00400655 	.word	0x00400655

00400c84 <can_set_baudrate>:
 *
 * \retval Set the baudrate successfully or not.
 */
static uint32_t can_set_baudrate(Can *p_can, uint32_t ul_mck,
		uint32_t ul_baudrate)
{
  400c84:	b580      	push	{r7, lr}
  400c86:	b08a      	sub	sp, #40	; 0x28
  400c88:	af00      	add	r7, sp, #0
  400c8a:	60f8      	str	r0, [r7, #12]
  400c8c:	60b9      	str	r1, [r7, #8]
  400c8e:	607a      	str	r2, [r7, #4]
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  400c90:	687b      	ldr	r3, [r7, #4]
  400c92:	f246 12a8 	movw	r2, #25000	; 0x61a8
  400c96:	fb02 f203 	mul.w	r2, r2, r3
  400c9a:	68bb      	ldr	r3, [r7, #8]
  400c9c:	4413      	add	r3, r2
  400c9e:	1e5a      	subs	r2, r3, #1
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
  400ca0:	687b      	ldr	r3, [r7, #4]
  400ca2:	f246 11a8 	movw	r1, #25000	; 0x61a8
  400ca6:	fb01 f303 	mul.w	r3, r1, r3
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  400caa:	fbb2 f3f3 	udiv	r3, r2, r3
  400cae:	2b80      	cmp	r3, #128	; 0x80
  400cb0:	d901      	bls.n	400cb6 <can_set_baudrate+0x32>
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
  400cb2:	2300      	movs	r3, #0
  400cb4:	e086      	b.n	400dc4 <can_set_baudrate+0x140>
	}

	/* Check whether the input MCK is too small. */
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  400cb6:	68bb      	ldr	r3, [r7, #8]
  400cb8:	085a      	lsrs	r2, r3, #1
  400cba:	687b      	ldr	r3, [r7, #4]
  400cbc:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  400cc0:	fb01 f303 	mul.w	r3, r1, r3
  400cc4:	429a      	cmp	r2, r3
  400cc6:	d201      	bcs.n	400ccc <can_set_baudrate+0x48>
		return 0;
  400cc8:	2300      	movs	r3, #0
  400cca:	e07b      	b.n	400dc4 <can_set_baudrate+0x140>
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;
  400ccc:	2308      	movs	r3, #8
  400cce:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
  400cd2:	f04f 33ff 	mov.w	r3, #4294967295
  400cd6:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  400cd8:	2308      	movs	r3, #8
  400cda:	77fb      	strb	r3, [r7, #31]
  400cdc:	e02a      	b.n	400d34 <can_set_baudrate+0xb0>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  400cde:	7ffb      	ldrb	r3, [r7, #31]
  400ce0:	687a      	ldr	r2, [r7, #4]
  400ce2:	fb02 f303 	mul.w	r3, r2, r3
  400ce6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  400cea:	fb02 f303 	mul.w	r3, r2, r3
  400cee:	68ba      	ldr	r2, [r7, #8]
  400cf0:	fbb2 f3f3 	udiv	r3, r2, r3
  400cf4:	2b80      	cmp	r3, #128	; 0x80
  400cf6:	d81a      	bhi.n	400d2e <can_set_baudrate+0xaa>
				CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  400cf8:	7ffb      	ldrb	r3, [r7, #31]
  400cfa:	687a      	ldr	r2, [r7, #4]
  400cfc:	fb02 f303 	mul.w	r3, r2, r3
  400d00:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  400d04:	fb02 f203 	mul.w	r2, r2, r3
  400d08:	68bb      	ldr	r3, [r7, #8]
  400d0a:	fbb3 f1f2 	udiv	r1, r3, r2
  400d0e:	fb02 f201 	mul.w	r2, r2, r1
  400d12:	1a9b      	subs	r3, r3, r2
  400d14:	61bb      	str	r3, [r7, #24]
			if (ul_cur_mod < ul_mod) {
  400d16:	69ba      	ldr	r2, [r7, #24]
  400d18:	6a3b      	ldr	r3, [r7, #32]
  400d1a:	429a      	cmp	r2, r3
  400d1c:	d207      	bcs.n	400d2e <can_set_baudrate+0xaa>
				ul_mod = ul_cur_mod;
  400d1e:	69bb      	ldr	r3, [r7, #24]
  400d20:	623b      	str	r3, [r7, #32]
				uc_tq = i;
  400d22:	7ffb      	ldrb	r3, [r7, #31]
  400d24:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!ul_mod) {
  400d28:	6a3b      	ldr	r3, [r7, #32]
  400d2a:	2b00      	cmp	r3, #0
  400d2c:	d006      	beq.n	400d3c <can_set_baudrate+0xb8>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  400d2e:	7ffb      	ldrb	r3, [r7, #31]
  400d30:	3301      	adds	r3, #1
  400d32:	77fb      	strb	r3, [r7, #31]
  400d34:	7ffb      	ldrb	r3, [r7, #31]
  400d36:	2b19      	cmp	r3, #25
  400d38:	d9d1      	bls.n	400cde <can_set_baudrate+0x5a>
  400d3a:	e000      	b.n	400d3e <can_set_baudrate+0xba>
					break;
  400d3c:	bf00      	nop
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  400d3e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  400d42:	687a      	ldr	r2, [r7, #4]
  400d44:	fb02 f303 	mul.w	r3, r2, r3
  400d48:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  400d4c:	fb02 f303 	mul.w	r3, r2, r3
  400d50:	68ba      	ldr	r2, [r7, #8]
  400d52:	fbb2 f3f3 	udiv	r3, r2, r3
  400d56:	75fb      	strb	r3, [r7, #23]
	if (uc_prescale < 2) {
  400d58:	7dfb      	ldrb	r3, [r7, #23]
  400d5a:	2b01      	cmp	r3, #1
  400d5c:	d801      	bhi.n	400d62 <can_set_baudrate+0xde>
		return 0;
  400d5e:	2300      	movs	r3, #0
  400d60:	e030      	b.n	400dc4 <can_set_baudrate+0x140>
	}

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  400d62:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  400d66:	f1a3 0208 	sub.w	r2, r3, #8
  400d6a:	4613      	mov	r3, r2
  400d6c:	005b      	lsls	r3, r3, #1
  400d6e:	4413      	add	r3, r2
  400d70:	005b      	lsls	r3, r3, #1
  400d72:	4a16      	ldr	r2, [pc, #88]	; (400dcc <can_set_baudrate+0x148>)
  400d74:	4413      	add	r3, r2
  400d76:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);
  400d78:	68f8      	ldr	r0, [r7, #12]
  400d7a:	4b15      	ldr	r3, [pc, #84]	; (400dd0 <can_set_baudrate+0x14c>)
  400d7c:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  400d7e:	693b      	ldr	r3, [r7, #16]
  400d80:	78db      	ldrb	r3, [r3, #3]
  400d82:	3b01      	subs	r3, #1
  400d84:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  400d88:	693b      	ldr	r3, [r7, #16]
  400d8a:	789b      	ldrb	r3, [r3, #2]
  400d8c:	3b01      	subs	r3, #1
  400d8e:	011b      	lsls	r3, r3, #4
  400d90:	f003 0370 	and.w	r3, r3, #112	; 0x70
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  400d94:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  400d96:	693b      	ldr	r3, [r7, #16]
  400d98:	785b      	ldrb	r3, [r3, #1]
  400d9a:	3b01      	subs	r3, #1
  400d9c:	021b      	lsls	r3, r3, #8
  400d9e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  400da2:	431a      	orrs	r2, r3
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  400da4:	693b      	ldr	r3, [r7, #16]
  400da6:	791b      	ldrb	r3, [r3, #4]
  400da8:	3b01      	subs	r3, #1
  400daa:	031b      	lsls	r3, r3, #12
  400dac:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  400db0:	431a      	orrs	r2, r3
			CAN_BR_BRP(uc_prescale - 1);
  400db2:	7dfb      	ldrb	r3, [r7, #23]
  400db4:	3b01      	subs	r3, #1
  400db6:	041b      	lsls	r3, r3, #16
  400db8:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  400dbc:	431a      	orrs	r2, r3
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  400dbe:	68fb      	ldr	r3, [r7, #12]
  400dc0:	615a      	str	r2, [r3, #20]
	return 1;
  400dc2:	2301      	movs	r3, #1
}
  400dc4:	4618      	mov	r0, r3
  400dc6:	3728      	adds	r7, #40	; 0x28
  400dc8:	46bd      	mov	sp, r7
  400dca:	bd80      	pop	{r7, pc}
  400dcc:	0040abe8 	.word	0x0040abe8
  400dd0:	00400e71 	.word	0x00400e71

00400dd4 <can_init>:
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this
 *function.
 */
uint32_t can_init(Can *p_can, uint32_t ul_mck, uint32_t ul_baudrate)
{
  400dd4:	b580      	push	{r7, lr}
  400dd6:	b086      	sub	sp, #24
  400dd8:	af00      	add	r7, sp, #0
  400dda:	60f8      	str	r0, [r7, #12]
  400ddc:	60b9      	str	r1, [r7, #8]
  400dde:	607a      	str	r2, [r7, #4]
	uint32_t ul_flag;
	uint32_t ul_tick;

	/* Initialize the baudrate for CAN module. */
	ul_flag = can_set_baudrate(p_can, ul_mck, ul_baudrate);
  400de0:	687a      	ldr	r2, [r7, #4]
  400de2:	68b9      	ldr	r1, [r7, #8]
  400de4:	68f8      	ldr	r0, [r7, #12]
  400de6:	4b15      	ldr	r3, [pc, #84]	; (400e3c <can_init+0x68>)
  400de8:	4798      	blx	r3
  400dea:	6178      	str	r0, [r7, #20]
	if (ul_flag == 0) {
  400dec:	697b      	ldr	r3, [r7, #20]
  400dee:	2b00      	cmp	r3, #0
  400df0:	d101      	bne.n	400df6 <can_init+0x22>
		return 0;
  400df2:	2300      	movs	r3, #0
  400df4:	e01e      	b.n	400e34 <can_init+0x60>

	/* Reset the CAN eight message mailbox. */
	//can_reset_all_mailbox(p_can);

	/* Enable the CAN controller. */
	can_enable(p_can);
  400df6:	68f8      	ldr	r0, [r7, #12]
  400df8:	4b11      	ldr	r3, [pc, #68]	; (400e40 <can_init+0x6c>)
  400dfa:	4798      	blx	r3

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
  400dfc:	2300      	movs	r3, #0
  400dfe:	617b      	str	r3, [r7, #20]
	ul_tick = 0;
  400e00:	2300      	movs	r3, #0
  400e02:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  400e04:	e006      	b.n	400e14 <can_init+0x40>
		ul_flag = can_get_status(p_can);
  400e06:	68f8      	ldr	r0, [r7, #12]
  400e08:	4b0e      	ldr	r3, [pc, #56]	; (400e44 <can_init+0x70>)
  400e0a:	4798      	blx	r3
  400e0c:	6178      	str	r0, [r7, #20]
		ul_tick++;
  400e0e:	693b      	ldr	r3, [r7, #16]
  400e10:	3301      	adds	r3, #1
  400e12:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  400e14:	697b      	ldr	r3, [r7, #20]
  400e16:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  400e1a:	2b00      	cmp	r3, #0
  400e1c:	d103      	bne.n	400e26 <can_init+0x52>
  400e1e:	693b      	ldr	r3, [r7, #16]
  400e20:	4a09      	ldr	r2, [pc, #36]	; (400e48 <can_init+0x74>)
  400e22:	4293      	cmp	r3, r2
  400e24:	d9ef      	bls.n	400e06 <can_init+0x32>
	}

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
  400e26:	693b      	ldr	r3, [r7, #16]
  400e28:	4a08      	ldr	r2, [pc, #32]	; (400e4c <can_init+0x78>)
  400e2a:	4293      	cmp	r3, r2
  400e2c:	d101      	bne.n	400e32 <can_init+0x5e>
		return 0;
  400e2e:	2300      	movs	r3, #0
  400e30:	e000      	b.n	400e34 <can_init+0x60>
	} else {
		return 1;
  400e32:	2301      	movs	r3, #1
	}
}
  400e34:	4618      	mov	r0, r3
  400e36:	3718      	adds	r7, #24
  400e38:	46bd      	mov	sp, r7
  400e3a:	bd80      	pop	{r7, pc}
  400e3c:	00400c85 	.word	0x00400c85
  400e40:	00400e51 	.word	0x00400e51
  400e44:	00400ec9 	.word	0x00400ec9
  400e48:	0001869f 	.word	0x0001869f
  400e4c:	000186a0 	.word	0x000186a0

00400e50 <can_enable>:
 * \brief Enable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_enable(Can *p_can)
{
  400e50:	b480      	push	{r7}
  400e52:	b083      	sub	sp, #12
  400e54:	af00      	add	r7, sp, #0
  400e56:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR |= CAN_MR_CANEN;
  400e58:	687b      	ldr	r3, [r7, #4]
  400e5a:	681b      	ldr	r3, [r3, #0]
  400e5c:	f043 0201 	orr.w	r2, r3, #1
  400e60:	687b      	ldr	r3, [r7, #4]
  400e62:	601a      	str	r2, [r3, #0]
}
  400e64:	bf00      	nop
  400e66:	370c      	adds	r7, #12
  400e68:	46bd      	mov	sp, r7
  400e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  400e6e:	4770      	bx	lr

00400e70 <can_disable>:
 * \brief Disable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_disable(Can *p_can)
{
  400e70:	b480      	push	{r7}
  400e72:	b083      	sub	sp, #12
  400e74:	af00      	add	r7, sp, #0
  400e76:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  400e78:	687b      	ldr	r3, [r7, #4]
  400e7a:	681b      	ldr	r3, [r3, #0]
  400e7c:	f023 0201 	bic.w	r2, r3, #1
  400e80:	687b      	ldr	r3, [r7, #4]
  400e82:	601a      	str	r2, [r3, #0]
}
  400e84:	bf00      	nop
  400e86:	370c      	adds	r7, #12
  400e88:	46bd      	mov	sp, r7
  400e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  400e8e:	4770      	bx	lr

00400e90 <can_enable_interrupt>:
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be enabled.
 */
void can_enable_interrupt(Can *p_can, uint32_t dw_mask)
{
  400e90:	b480      	push	{r7}
  400e92:	b083      	sub	sp, #12
  400e94:	af00      	add	r7, sp, #0
  400e96:	6078      	str	r0, [r7, #4]
  400e98:	6039      	str	r1, [r7, #0]
	p_can->CAN_IER = dw_mask;
  400e9a:	687b      	ldr	r3, [r7, #4]
  400e9c:	683a      	ldr	r2, [r7, #0]
  400e9e:	605a      	str	r2, [r3, #4]
}
  400ea0:	bf00      	nop
  400ea2:	370c      	adds	r7, #12
  400ea4:	46bd      	mov	sp, r7
  400ea6:	f85d 7b04 	ldr.w	r7, [sp], #4
  400eaa:	4770      	bx	lr

00400eac <can_disable_interrupt>:
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be disabled.
 */
void can_disable_interrupt(Can *p_can, uint32_t dw_mask)
{
  400eac:	b480      	push	{r7}
  400eae:	b083      	sub	sp, #12
  400eb0:	af00      	add	r7, sp, #0
  400eb2:	6078      	str	r0, [r7, #4]
  400eb4:	6039      	str	r1, [r7, #0]
	p_can->CAN_IDR = dw_mask;
  400eb6:	687b      	ldr	r3, [r7, #4]
  400eb8:	683a      	ldr	r2, [r7, #0]
  400eba:	609a      	str	r2, [r3, #8]
}
  400ebc:	bf00      	nop
  400ebe:	370c      	adds	r7, #12
  400ec0:	46bd      	mov	sp, r7
  400ec2:	f85d 7b04 	ldr.w	r7, [sp], #4
  400ec6:	4770      	bx	lr

00400ec8 <can_get_status>:
 * \param p_can Pointer to a CAN peripheral instance.
 *
 * \retval CAN status.
 */
uint32_t can_get_status(Can *p_can)
{
  400ec8:	b480      	push	{r7}
  400eca:	b083      	sub	sp, #12
  400ecc:	af00      	add	r7, sp, #0
  400ece:	6078      	str	r0, [r7, #4]
	return (p_can->CAN_SR);
  400ed0:	687b      	ldr	r3, [r7, #4]
  400ed2:	691b      	ldr	r3, [r3, #16]
}
  400ed4:	4618      	mov	r0, r3
  400ed6:	370c      	adds	r7, #12
  400ed8:	46bd      	mov	sp, r7
  400eda:	f85d 7b04 	ldr.w	r7, [sp], #4
  400ede:	4770      	bx	lr

00400ee0 <can_global_send_transfer_cmd>:
 *
 * \param p_can   Pointer to a CAN peripheral instance.
 * \param uc_mask Mask for mailboxes that are requested to transfer.
 */
void can_global_send_transfer_cmd(Can *p_can, uint8_t uc_mask)
{
  400ee0:	b480      	push	{r7}
  400ee2:	b085      	sub	sp, #20
  400ee4:	af00      	add	r7, sp, #0
  400ee6:	6078      	str	r0, [r7, #4]
  400ee8:	460b      	mov	r3, r1
  400eea:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_reg;

	ul_reg = p_can->CAN_TCR & ((uint32_t) ~GLOBAL_MAILBOX_MASK);
  400eec:	687b      	ldr	r3, [r7, #4]
  400eee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  400ef0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  400ef4:	60fb      	str	r3, [r7, #12]
	p_can->CAN_TCR = ul_reg | uc_mask;
  400ef6:	78fa      	ldrb	r2, [r7, #3]
  400ef8:	68fb      	ldr	r3, [r7, #12]
  400efa:	431a      	orrs	r2, r3
  400efc:	687b      	ldr	r3, [r7, #4]
  400efe:	625a      	str	r2, [r3, #36]	; 0x24
}
  400f00:	bf00      	nop
  400f02:	3714      	adds	r7, #20
  400f04:	46bd      	mov	sp, r7
  400f06:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f0a:	4770      	bx	lr

00400f0c <can_mailbox_get_status>:
 * \param uc_index Indicate which mailbox is to be read.
 *
 * \retval The mailbox status.
 */
uint32_t can_mailbox_get_status(Can *p_can, uint8_t uc_index)
{
  400f0c:	b480      	push	{r7}
  400f0e:	b083      	sub	sp, #12
  400f10:	af00      	add	r7, sp, #0
  400f12:	6078      	str	r0, [r7, #4]
  400f14:	460b      	mov	r3, r1
  400f16:	70fb      	strb	r3, [r7, #3]
	return (p_can->CAN_MB[uc_index].CAN_MSR);
  400f18:	78fb      	ldrb	r3, [r7, #3]
  400f1a:	687a      	ldr	r2, [r7, #4]
  400f1c:	015b      	lsls	r3, r3, #5
  400f1e:	4413      	add	r3, r2
  400f20:	f503 7304 	add.w	r3, r3, #528	; 0x210
  400f24:	681b      	ldr	r3, [r3, #0]
}
  400f26:	4618      	mov	r0, r3
  400f28:	370c      	adds	r7, #12
  400f2a:	46bd      	mov	sp, r7
  400f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f30:	4770      	bx	lr

00400f32 <can_mailbox_send_transfer_cmd>:
 *
 * \param p_can   Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_send_transfer_cmd(Can *p_can, can_mb_conf_t *p_mailbox)
{
  400f32:	b480      	push	{r7}
  400f34:	b085      	sub	sp, #20
  400f36:	af00      	add	r7, sp, #0
  400f38:	6078      	str	r0, [r7, #4]
  400f3a:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  400f3c:	683b      	ldr	r3, [r7, #0]
  400f3e:	681b      	ldr	r3, [r3, #0]
  400f40:	73fb      	strb	r3, [r7, #15]

	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
  400f42:	7bfb      	ldrb	r3, [r7, #15]
			CAN_MCR_MDLC(p_mailbox->uc_length);;
  400f44:	683a      	ldr	r2, [r7, #0]
  400f46:	7992      	ldrb	r2, [r2, #6]
  400f48:	0412      	lsls	r2, r2, #16
  400f4a:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
  400f4e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
  400f52:	6879      	ldr	r1, [r7, #4]
  400f54:	015b      	lsls	r3, r3, #5
  400f56:	440b      	add	r3, r1
  400f58:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  400f5c:	601a      	str	r2, [r3, #0]
}
  400f5e:	bf00      	nop
  400f60:	3714      	adds	r7, #20
  400f62:	46bd      	mov	sp, r7
  400f64:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f68:	4770      	bx	lr

00400f6a <can_mailbox_init>:
 *
 * \param p_can    Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
  400f6a:	b480      	push	{r7}
  400f6c:	b085      	sub	sp, #20
  400f6e:	af00      	add	r7, sp, #0
  400f70:	6078      	str	r0, [r7, #4]
  400f72:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  400f74:	683b      	ldr	r3, [r7, #0]
  400f76:	681b      	ldr	r3, [r3, #0]
  400f78:	73fb      	strb	r3, [r7, #15]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  400f7a:	683b      	ldr	r3, [r7, #0]
  400f7c:	791b      	ldrb	r3, [r3, #4]
  400f7e:	2b00      	cmp	r3, #0
  400f80:	d12f      	bne.n	400fe2 <can_mailbox_init+0x78>
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  400f82:	7bfb      	ldrb	r3, [r7, #15]
  400f84:	687a      	ldr	r2, [r7, #4]
  400f86:	3310      	adds	r3, #16
  400f88:	015b      	lsls	r3, r3, #5
  400f8a:	4413      	add	r3, r2
  400f8c:	2200      	movs	r2, #0
  400f8e:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  400f90:	7bfb      	ldrb	r3, [r7, #15]
  400f92:	687a      	ldr	r2, [r7, #4]
  400f94:	3310      	adds	r3, #16
  400f96:	015b      	lsls	r3, r3, #5
  400f98:	4413      	add	r3, r2
  400f9a:	3304      	adds	r3, #4
  400f9c:	2200      	movs	r2, #0
  400f9e:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  400fa0:	7bfb      	ldrb	r3, [r7, #15]
  400fa2:	687a      	ldr	r2, [r7, #4]
  400fa4:	015b      	lsls	r3, r3, #5
  400fa6:	4413      	add	r3, r2
  400fa8:	f503 7302 	add.w	r3, r3, #520	; 0x208
  400fac:	2200      	movs	r2, #0
  400fae:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  400fb0:	7bfb      	ldrb	r3, [r7, #15]
  400fb2:	687a      	ldr	r2, [r7, #4]
  400fb4:	015b      	lsls	r3, r3, #5
  400fb6:	4413      	add	r3, r2
  400fb8:	f503 7305 	add.w	r3, r3, #532	; 0x214
  400fbc:	2200      	movs	r2, #0
  400fbe:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  400fc0:	7bfb      	ldrb	r3, [r7, #15]
  400fc2:	687a      	ldr	r2, [r7, #4]
  400fc4:	015b      	lsls	r3, r3, #5
  400fc6:	4413      	add	r3, r2
  400fc8:	f503 7306 	add.w	r3, r3, #536	; 0x218
  400fcc:	2200      	movs	r2, #0
  400fce:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  400fd0:	7bfb      	ldrb	r3, [r7, #15]
  400fd2:	687a      	ldr	r2, [r7, #4]
  400fd4:	015b      	lsls	r3, r3, #5
  400fd6:	4413      	add	r3, r2
  400fd8:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  400fdc:	2200      	movs	r2, #0
  400fde:	601a      	str	r2, [r3, #0]
		return;
  400fe0:	e050      	b.n	401084 <can_mailbox_init+0x11a>
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  400fe2:	7bfb      	ldrb	r3, [r7, #15]
  400fe4:	7bfa      	ldrb	r2, [r7, #15]
  400fe6:	6879      	ldr	r1, [r7, #4]
  400fe8:	3210      	adds	r2, #16
  400fea:	0152      	lsls	r2, r2, #5
  400fec:	440a      	add	r2, r1
  400fee:	6812      	ldr	r2, [r2, #0]
  400ff0:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  400ff4:	6839      	ldr	r1, [r7, #0]
  400ff6:	79c9      	ldrb	r1, [r1, #7]
  400ff8:	0409      	lsls	r1, r1, #16
			~CAN_MMR_PRIOR_Msk) |
  400ffa:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  400ffc:	6879      	ldr	r1, [r7, #4]
  400ffe:	3310      	adds	r3, #16
  401000:	015b      	lsls	r3, r3, #5
  401002:	440b      	add	r3, r1
  401004:	601a      	str	r2, [r3, #0]

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  401006:	683b      	ldr	r3, [r7, #0]
  401008:	795b      	ldrb	r3, [r3, #5]
  40100a:	2b00      	cmp	r3, #0
  40100c:	d016      	beq.n	40103c <can_mailbox_init+0xd2>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  40100e:	7bfb      	ldrb	r3, [r7, #15]
  401010:	683a      	ldr	r2, [r7, #0]
  401012:	68d2      	ldr	r2, [r2, #12]
  401014:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  401018:	6879      	ldr	r1, [r7, #4]
  40101a:	3310      	adds	r3, #16
  40101c:	015b      	lsls	r3, r3, #5
  40101e:	440b      	add	r3, r1
  401020:	3304      	adds	r3, #4
  401022:	601a      	str	r2, [r3, #0]
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  401024:	7bfb      	ldrb	r3, [r7, #15]
  401026:	683a      	ldr	r2, [r7, #0]
  401028:	6912      	ldr	r2, [r2, #16]
  40102a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  40102e:	6879      	ldr	r1, [r7, #4]
  401030:	015b      	lsls	r3, r3, #5
  401032:	440b      	add	r3, r1
  401034:	f503 7302 	add.w	r3, r3, #520	; 0x208
  401038:	601a      	str	r2, [r3, #0]
  40103a:	e011      	b.n	401060 <can_mailbox_init+0xf6>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  40103c:	7bfb      	ldrb	r3, [r7, #15]
  40103e:	683a      	ldr	r2, [r7, #0]
  401040:	68d2      	ldr	r2, [r2, #12]
  401042:	6879      	ldr	r1, [r7, #4]
  401044:	3310      	adds	r3, #16
  401046:	015b      	lsls	r3, r3, #5
  401048:	440b      	add	r3, r1
  40104a:	3304      	adds	r3, #4
  40104c:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  40104e:	7bfb      	ldrb	r3, [r7, #15]
  401050:	683a      	ldr	r2, [r7, #0]
  401052:	6912      	ldr	r2, [r2, #16]
  401054:	6879      	ldr	r1, [r7, #4]
  401056:	015b      	lsls	r3, r3, #5
  401058:	440b      	add	r3, r1
  40105a:	f503 7302 	add.w	r3, r3, #520	; 0x208
  40105e:	601a      	str	r2, [r3, #0]
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  401060:	7bfb      	ldrb	r3, [r7, #15]
  401062:	7bfa      	ldrb	r2, [r7, #15]
  401064:	6879      	ldr	r1, [r7, #4]
  401066:	3210      	adds	r2, #16
  401068:	0152      	lsls	r2, r2, #5
  40106a:	440a      	add	r2, r1
  40106c:	6812      	ldr	r2, [r2, #0]
  40106e:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  401072:	6839      	ldr	r1, [r7, #0]
  401074:	7909      	ldrb	r1, [r1, #4]
  401076:	0609      	lsls	r1, r1, #24
			~CAN_MMR_MOT_Msk) |
  401078:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40107a:	6879      	ldr	r1, [r7, #4]
  40107c:	3310      	adds	r3, #16
  40107e:	015b      	lsls	r3, r3, #5
  401080:	440b      	add	r3, r1
  401082:	601a      	str	r2, [r3, #0]
}
  401084:	3714      	adds	r7, #20
  401086:	46bd      	mov	sp, r7
  401088:	f85d 7b04 	ldr.w	r7, [sp], #4
  40108c:	4770      	bx	lr
	...

00401090 <can_mailbox_read>:
 * \retval Different CAN mailbox transfer status.
 *
 * \note Read the mailbox status before calling this function.
 */
uint32_t can_mailbox_read(Can *p_can, can_mb_conf_t *p_mailbox)
{
  401090:	b580      	push	{r7, lr}
  401092:	b086      	sub	sp, #24
  401094:	af00      	add	r7, sp, #0
  401096:	6078      	str	r0, [r7, #4]
  401098:	6039      	str	r1, [r7, #0]
	uint32_t ul_status;
	uint8_t uc_index;
	uint32_t ul_retval;

	ul_retval = 0;
  40109a:	2300      	movs	r3, #0
  40109c:	617b      	str	r3, [r7, #20]
	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  40109e:	683b      	ldr	r3, [r7, #0]
  4010a0:	681b      	ldr	r3, [r3, #0]
  4010a2:	74fb      	strb	r3, [r7, #19]
	ul_status = p_mailbox->ul_status;
  4010a4:	683b      	ldr	r3, [r7, #0]
  4010a6:	689b      	ldr	r3, [r3, #8]
  4010a8:	60fb      	str	r3, [r7, #12]

	/* Check whether there is overwriting happening in Receive with
	 * Overwrite mode,
	 * or there're messages lost in Receive mode. */
	if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
  4010aa:	68fb      	ldr	r3, [r7, #12]
  4010ac:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  4010b0:	2b00      	cmp	r3, #0
  4010b2:	d006      	beq.n	4010c2 <can_mailbox_read+0x32>
  4010b4:	68fb      	ldr	r3, [r7, #12]
  4010b6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4010ba:	2b00      	cmp	r3, #0
  4010bc:	d001      	beq.n	4010c2 <can_mailbox_read+0x32>
		ul_retval = CAN_MAILBOX_RX_OVER;
  4010be:	2302      	movs	r3, #2
  4010c0:	617b      	str	r3, [r7, #20]
	}
	p_mailbox->ul_id= p_can->CAN_MB[uc_index].CAN_MID;
  4010c2:	7cfb      	ldrb	r3, [r7, #19]
  4010c4:	687a      	ldr	r2, [r7, #4]
  4010c6:	015b      	lsls	r3, r3, #5
  4010c8:	4413      	add	r3, r2
  4010ca:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4010ce:	681a      	ldr	r2, [r3, #0]
  4010d0:	683b      	ldr	r3, [r7, #0]
  4010d2:	611a      	str	r2, [r3, #16]
	p_mailbox->ul_id_msk= p_can->CAN_MB[uc_index].CAN_MMR;
  4010d4:	7cfb      	ldrb	r3, [r7, #19]
  4010d6:	687a      	ldr	r2, [r7, #4]
  4010d8:	3310      	adds	r3, #16
  4010da:	015b      	lsls	r3, r3, #5
  4010dc:	4413      	add	r3, r2
  4010de:	681a      	ldr	r2, [r3, #0]
  4010e0:	683b      	ldr	r3, [r7, #0]
  4010e2:	60da      	str	r2, [r3, #12]
	
	/* Read the message family ID. */
	p_mailbox->ul_fid = p_can->CAN_MB[uc_index].CAN_MFID &
  4010e4:	7cfb      	ldrb	r3, [r7, #19]
  4010e6:	687a      	ldr	r2, [r7, #4]
  4010e8:	015b      	lsls	r3, r3, #5
  4010ea:	4413      	add	r3, r2
  4010ec:	f503 7303 	add.w	r3, r3, #524	; 0x20c
  4010f0:	681b      	ldr	r3, [r3, #0]
  4010f2:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
  4010f6:	683b      	ldr	r3, [r7, #0]
  4010f8:	615a      	str	r2, [r3, #20]
			CAN_MFID_MFID_Msk;

	/* Read received data length. */
	p_mailbox->uc_length
		= (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
  4010fa:	68fb      	ldr	r3, [r7, #12]
  4010fc:	0c1b      	lsrs	r3, r3, #16
  4010fe:	b2db      	uxtb	r3, r3
  401100:	f003 030f 	and.w	r3, r3, #15
  401104:	b2da      	uxtb	r2, r3
  401106:	683b      	ldr	r3, [r7, #0]
  401108:	719a      	strb	r2, [r3, #6]
	p_mailbox->uc_length = 8;
  40110a:	683b      	ldr	r3, [r7, #0]
  40110c:	2208      	movs	r2, #8
  40110e:	719a      	strb	r2, [r3, #6]
	/* Read received data. */
	p_mailbox->ul_datal = p_can->CAN_MB[uc_index].CAN_MDL;
  401110:	7cfb      	ldrb	r3, [r7, #19]
  401112:	687a      	ldr	r2, [r7, #4]
  401114:	015b      	lsls	r3, r3, #5
  401116:	4413      	add	r3, r2
  401118:	f503 7305 	add.w	r3, r3, #532	; 0x214
  40111c:	681a      	ldr	r2, [r3, #0]
  40111e:	683b      	ldr	r3, [r7, #0]
  401120:	619a      	str	r2, [r3, #24]
	p_mailbox->ul_datah = p_can->CAN_MB[uc_index].CAN_MDH;
  401122:	7cfb      	ldrb	r3, [r7, #19]
  401124:	687a      	ldr	r2, [r7, #4]
  401126:	015b      	lsls	r3, r3, #5
  401128:	4413      	add	r3, r2
  40112a:	f503 7306 	add.w	r3, r3, #536	; 0x218
  40112e:	681a      	ldr	r2, [r3, #0]
  401130:	683b      	ldr	r3, [r7, #0]
  401132:	61da      	str	r2, [r3, #28]

	/* Read the mailbox status again to check whether the software needs to
	 * re-read mailbox data register. */
	p_mailbox->ul_status = p_can->CAN_MB[uc_index].CAN_MSR;
  401134:	7cfb      	ldrb	r3, [r7, #19]
  401136:	687a      	ldr	r2, [r7, #4]
  401138:	015b      	lsls	r3, r3, #5
  40113a:	4413      	add	r3, r2
  40113c:	f503 7304 	add.w	r3, r3, #528	; 0x210
  401140:	681a      	ldr	r2, [r3, #0]
  401142:	683b      	ldr	r3, [r7, #0]
  401144:	609a      	str	r2, [r3, #8]
	ul_status = p_mailbox->ul_status;
  401146:	683b      	ldr	r3, [r7, #0]
  401148:	689b      	ldr	r3, [r3, #8]
  40114a:	60fb      	str	r3, [r7, #12]
	if (ul_status & CAN_MSR_MMI) {
  40114c:	68fb      	ldr	r3, [r7, #12]
  40114e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401152:	2b00      	cmp	r3, #0
  401154:	d003      	beq.n	40115e <can_mailbox_read+0xce>
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
  401156:	697b      	ldr	r3, [r7, #20]
  401158:	f043 0304 	orr.w	r3, r3, #4
  40115c:	617b      	str	r3, [r7, #20]
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}

	/* Enable next receive process. */
	can_mailbox_send_transfer_cmd(p_can, p_mailbox);
  40115e:	6839      	ldr	r1, [r7, #0]
  401160:	6878      	ldr	r0, [r7, #4]
  401162:	4b03      	ldr	r3, [pc, #12]	; (401170 <can_mailbox_read+0xe0>)
  401164:	4798      	blx	r3

	return ul_retval;
  401166:	697b      	ldr	r3, [r7, #20]
}
  401168:	4618      	mov	r0, r3
  40116a:	3718      	adds	r7, #24
  40116c:	46bd      	mov	sp, r7
  40116e:	bd80      	pop	{r7, pc}
  401170:	00400f33 	.word	0x00400f33

00401174 <can_mailbox_write>:
 * \note After calling this function, the mailbox message won't be sent out
 *until
 * can_mailbox_send_transfer_cmd() is called.
 */
uint32_t can_mailbox_write(Can *p_can, can_mb_conf_t *p_mailbox)
{
  401174:	b580      	push	{r7, lr}
  401176:	b084      	sub	sp, #16
  401178:	af00      	add	r7, sp, #0
  40117a:	6078      	str	r0, [r7, #4]
  40117c:	6039      	str	r1, [r7, #0]
	uint32_t ul_status;
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  40117e:	683b      	ldr	r3, [r7, #0]
  401180:	681b      	ldr	r3, [r3, #0]
  401182:	73fb      	strb	r3, [r7, #15]
	/* Read the mailbox status firstly to check whether the mailbox is ready
	 *or not. */
	p_mailbox->ul_status = can_mailbox_get_status(p_can, uc_index);
  401184:	7bfb      	ldrb	r3, [r7, #15]
  401186:	4619      	mov	r1, r3
  401188:	6878      	ldr	r0, [r7, #4]
  40118a:	4b27      	ldr	r3, [pc, #156]	; (401228 <can_mailbox_write+0xb4>)
  40118c:	4798      	blx	r3
  40118e:	4602      	mov	r2, r0
  401190:	683b      	ldr	r3, [r7, #0]
  401192:	609a      	str	r2, [r3, #8]
	ul_status = p_mailbox->ul_status;
  401194:	683b      	ldr	r3, [r7, #0]
  401196:	689b      	ldr	r3, [r3, #8]
  401198:	60bb      	str	r3, [r7, #8]
	if (!(ul_status & CAN_MSR_MRDY)) {
  40119a:	68bb      	ldr	r3, [r7, #8]
  40119c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  4011a0:	2b00      	cmp	r3, #0
  4011a2:	d101      	bne.n	4011a8 <can_mailbox_write+0x34>
		return CAN_MAILBOX_NOT_READY;
  4011a4:	2301      	movs	r3, #1
  4011a6:	e03b      	b.n	401220 <can_mailbox_write+0xac>
	}

	/* Write transmit identifier. */
	if (p_mailbox->uc_id_ver) {
  4011a8:	683b      	ldr	r3, [r7, #0]
  4011aa:	795b      	ldrb	r3, [r3, #5]
  4011ac:	2b00      	cmp	r3, #0
  4011ae:	d00b      	beq.n	4011c8 <can_mailbox_write+0x54>
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  4011b0:	7bfb      	ldrb	r3, [r7, #15]
  4011b2:	683a      	ldr	r2, [r7, #0]
  4011b4:	6912      	ldr	r2, [r2, #16]
  4011b6:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4011ba:	6879      	ldr	r1, [r7, #4]
  4011bc:	015b      	lsls	r3, r3, #5
  4011be:	440b      	add	r3, r1
  4011c0:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4011c4:	601a      	str	r2, [r3, #0]
  4011c6:	e008      	b.n	4011da <can_mailbox_write+0x66>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  4011c8:	7bfb      	ldrb	r3, [r7, #15]
  4011ca:	683a      	ldr	r2, [r7, #0]
  4011cc:	6912      	ldr	r2, [r2, #16]
  4011ce:	6879      	ldr	r1, [r7, #4]
  4011d0:	015b      	lsls	r3, r3, #5
  4011d2:	440b      	add	r3, r1
  4011d4:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4011d8:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data into mailbox data register. */
	p_can->CAN_MB[uc_index].CAN_MDL = p_mailbox->ul_datal;
  4011da:	7bfb      	ldrb	r3, [r7, #15]
  4011dc:	683a      	ldr	r2, [r7, #0]
  4011de:	6992      	ldr	r2, [r2, #24]
  4011e0:	6879      	ldr	r1, [r7, #4]
  4011e2:	015b      	lsls	r3, r3, #5
  4011e4:	440b      	add	r3, r1
  4011e6:	f503 7305 	add.w	r3, r3, #532	; 0x214
  4011ea:	601a      	str	r2, [r3, #0]
	if (p_mailbox->uc_length > 4) {
  4011ec:	683b      	ldr	r3, [r7, #0]
  4011ee:	799b      	ldrb	r3, [r3, #6]
  4011f0:	2b04      	cmp	r3, #4
  4011f2:	d908      	bls.n	401206 <can_mailbox_write+0x92>
		p_can->CAN_MB[uc_index].CAN_MDH = p_mailbox->ul_datah;
  4011f4:	7bfb      	ldrb	r3, [r7, #15]
  4011f6:	683a      	ldr	r2, [r7, #0]
  4011f8:	69d2      	ldr	r2, [r2, #28]
  4011fa:	6879      	ldr	r1, [r7, #4]
  4011fc:	015b      	lsls	r3, r3, #5
  4011fe:	440b      	add	r3, r1
  401200:	f503 7306 	add.w	r3, r3, #536	; 0x218
  401204:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data length into mailbox control register. */
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MDLC(p_mailbox->uc_length);
  401206:	7bfb      	ldrb	r3, [r7, #15]
  401208:	683a      	ldr	r2, [r7, #0]
  40120a:	7992      	ldrb	r2, [r2, #6]
  40120c:	0412      	lsls	r2, r2, #16
  40120e:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  401212:	6879      	ldr	r1, [r7, #4]
  401214:	015b      	lsls	r3, r3, #5
  401216:	440b      	add	r3, r1
  401218:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  40121c:	601a      	str	r2, [r3, #0]

	return CAN_MAILBOX_TRANSFER_OK;
  40121e:	2300      	movs	r3, #0
}
  401220:	4618      	mov	r0, r3
  401222:	3710      	adds	r7, #16
  401224:	46bd      	mov	sp, r7
  401226:	bd80      	pop	{r7, pc}
  401228:	00400f0d 	.word	0x00400f0d

0040122c <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  40122c:	b580      	push	{r7, lr}
  40122e:	b08c      	sub	sp, #48	; 0x30
  401230:	af00      	add	r7, sp, #0
  401232:	6078      	str	r0, [r7, #4]
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  401234:	2300      	movs	r3, #0
  401236:	743b      	strb	r3, [r7, #16]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  401238:	2300      	movs	r3, #0
  40123a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40123e:	e00d      	b.n	40125c <can_reset_all_mailbox+0x30>
		mb_config_t.ul_mb_idx = i;
  401240:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  401244:	60fb      	str	r3, [r7, #12]
		can_mailbox_init(p_can, &mb_config_t);
  401246:	f107 030c 	add.w	r3, r7, #12
  40124a:	4619      	mov	r1, r3
  40124c:	6878      	ldr	r0, [r7, #4]
  40124e:	4b07      	ldr	r3, [pc, #28]	; (40126c <can_reset_all_mailbox+0x40>)
  401250:	4798      	blx	r3
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  401252:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  401256:	3301      	adds	r3, #1
  401258:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40125c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  401260:	2b07      	cmp	r3, #7
  401262:	d9ed      	bls.n	401240 <can_reset_all_mailbox+0x14>
	}
}
  401264:	bf00      	nop
  401266:	3730      	adds	r7, #48	; 0x30
  401268:	46bd      	mov	sp, r7
  40126a:	bd80      	pop	{r7, pc}
  40126c:	00400f6b 	.word	0x00400f6b

00401270 <efc_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
  401270:	b580      	push	{r7, lr}
  401272:	b084      	sub	sp, #16
  401274:	af00      	add	r7, sp, #0
  401276:	60f8      	str	r0, [r7, #12]
  401278:	60b9      	str	r1, [r7, #8]
  40127a:	607a      	str	r2, [r7, #4]
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws) | EEFC_FMR_CLOE);
  40127c:	687b      	ldr	r3, [r7, #4]
  40127e:	021b      	lsls	r3, r3, #8
  401280:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
  401284:	68bb      	ldr	r3, [r7, #8]
  401286:	4313      	orrs	r3, r2
  401288:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  40128c:	4619      	mov	r1, r3
  40128e:	68f8      	ldr	r0, [r7, #12]
  401290:	4b03      	ldr	r3, [pc, #12]	; (4012a0 <efc_init+0x30>)
  401292:	4798      	blx	r3
#else
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
#endif
	return EFC_RC_OK;
  401294:	2300      	movs	r3, #0
}
  401296:	4618      	mov	r0, r3
  401298:	3710      	adds	r7, #16
  40129a:	46bd      	mov	sp, r7
  40129c:	bd80      	pop	{r7, pc}
  40129e:	bf00      	nop
  4012a0:	200000af 	.word	0x200000af

004012a4 <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
  4012a4:	b580      	push	{r7, lr}
  4012a6:	b082      	sub	sp, #8
  4012a8:	af00      	add	r7, sp, #0
  4012aa:	6078      	str	r0, [r7, #4]
  4012ac:	6039      	str	r1, [r7, #0]
	efc_init(EFC, ul_mode, ul_fws);
  4012ae:	683a      	ldr	r2, [r7, #0]
  4012b0:	6879      	ldr	r1, [r7, #4]
  4012b2:	4804      	ldr	r0, [pc, #16]	; (4012c4 <flash_init+0x20>)
  4012b4:	4b04      	ldr	r3, [pc, #16]	; (4012c8 <flash_init+0x24>)
  4012b6:	4798      	blx	r3

#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
#endif

	return FLASH_RC_OK;
  4012b8:	2300      	movs	r3, #0
}
  4012ba:	4618      	mov	r0, r3
  4012bc:	3708      	adds	r7, #8
  4012be:	46bd      	mov	sp, r7
  4012c0:	bd80      	pop	{r7, pc}
  4012c2:	bf00      	nop
  4012c4:	400e0a00 	.word	0x400e0a00
  4012c8:	00401271 	.word	0x00401271

004012cc <flash_read_unique_id>:
 * \param ul_size Data buffer size in DWORD.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_read_unique_id(uint32_t *pul_data, uint32_t ul_size)
{
  4012cc:	b590      	push	{r4, r7, lr}
  4012ce:	b08b      	sub	sp, #44	; 0x2c
  4012d0:	af02      	add	r7, sp, #8
  4012d2:	6078      	str	r0, [r7, #4]
  4012d4:	6039      	str	r1, [r7, #0]
	uint32_t uid_buf[4];
	uint32_t ul_idx;

	if (FLASH_RC_OK != efc_perform_read_sequence(EFC, EFC_FCMD_STUI,
  4012d6:	f107 020c 	add.w	r2, r7, #12
  4012da:	2304      	movs	r3, #4
  4012dc:	9300      	str	r3, [sp, #0]
  4012de:	4613      	mov	r3, r2
  4012e0:	220f      	movs	r2, #15
  4012e2:	210e      	movs	r1, #14
  4012e4:	4813      	ldr	r0, [pc, #76]	; (401334 <flash_read_unique_id+0x68>)
  4012e6:	4c14      	ldr	r4, [pc, #80]	; (401338 <flash_read_unique_id+0x6c>)
  4012e8:	47a0      	blx	r4
  4012ea:	4603      	mov	r3, r0
  4012ec:	2b00      	cmp	r3, #0
  4012ee:	d001      	beq.n	4012f4 <flash_read_unique_id+0x28>
			EFC_FCMD_SPUI, uid_buf, 4)) {
		return FLASH_RC_ERROR;
  4012f0:	2310      	movs	r3, #16
  4012f2:	e01b      	b.n	40132c <flash_read_unique_id+0x60>
	}

	if (ul_size > 4) {
  4012f4:	683b      	ldr	r3, [r7, #0]
  4012f6:	2b04      	cmp	r3, #4
  4012f8:	d901      	bls.n	4012fe <flash_read_unique_id+0x32>
		/* Only 4 dword to store unique ID */
		ul_size = 4;
  4012fa:	2304      	movs	r3, #4
  4012fc:	603b      	str	r3, [r7, #0]
	}

	for (ul_idx = 0; ul_idx < ul_size; ul_idx++) {
  4012fe:	2300      	movs	r3, #0
  401300:	61fb      	str	r3, [r7, #28]
  401302:	e00e      	b.n	401322 <flash_read_unique_id+0x56>
		pul_data[ul_idx] = uid_buf[ul_idx];
  401304:	69fb      	ldr	r3, [r7, #28]
  401306:	009b      	lsls	r3, r3, #2
  401308:	687a      	ldr	r2, [r7, #4]
  40130a:	441a      	add	r2, r3
  40130c:	69fb      	ldr	r3, [r7, #28]
  40130e:	009b      	lsls	r3, r3, #2
  401310:	f107 0120 	add.w	r1, r7, #32
  401314:	440b      	add	r3, r1
  401316:	f853 3c14 	ldr.w	r3, [r3, #-20]
  40131a:	6013      	str	r3, [r2, #0]
	for (ul_idx = 0; ul_idx < ul_size; ul_idx++) {
  40131c:	69fb      	ldr	r3, [r7, #28]
  40131e:	3301      	adds	r3, #1
  401320:	61fb      	str	r3, [r7, #28]
  401322:	69fa      	ldr	r2, [r7, #28]
  401324:	683b      	ldr	r3, [r7, #0]
  401326:	429a      	cmp	r2, r3
  401328:	d3ec      	bcc.n	401304 <flash_read_unique_id+0x38>
	}

	return FLASH_RC_OK;
  40132a:	2300      	movs	r3, #0
}
  40132c:	4618      	mov	r0, r3
  40132e:	3724      	adds	r7, #36	; 0x24
  401330:	46bd      	mov	sp, r7
  401332:	bd90      	pop	{r4, r7, pc}
  401334:	400e0a00 	.word	0x400e0a00
  401338:	2000000b 	.word	0x2000000b

0040133c <InitalizeDebugConsole>:
//Uses a UART port as a debug console. Any information can be written out to the console for debugging. 
//The UART pins for this are hooked up to the ALDL hardware.


void InitalizeDebugConsole(void)
{
  40133c:	b480      	push	{r7}
  40133e:	af00      	add	r7, sp, #0
		};
		uint32_t EnableSuccess=uart_init(CONSOLE_UART, &uart_serial_options);
		uint32_t SendSuccess = 0;
		uart_enable(CONSOLE_UART);	
#endif
}
  401340:	bf00      	nop
  401342:	46bd      	mov	sp, r7
  401344:	f85d 7b04 	ldr.w	r7, [sp], #4
  401348:	4770      	bx	lr

0040134a <WriteLine>:
	
#endif
}

void WriteLine(uint8_t * string)
{
  40134a:	b480      	push	{r7}
  40134c:	b083      	sub	sp, #12
  40134e:	af00      	add	r7, sp, #0
  401350:	6078      	str	r0, [r7, #4]
	WriteString(string);
	while(!(CONSOLE_UART->UART_SR & UART_SR_TXRDY));
	uart_write(CONSOLE_UART,0x0A);
	
#endif
}
  401352:	bf00      	nop
  401354:	370c      	adds	r7, #12
  401356:	46bd      	mov	sp, r7
  401358:	f85d 7b04 	ldr.w	r7, [sp], #4
  40135c:	4770      	bx	lr
	...

00401360 <NVIC_ClearPendingIRQ>:
{
  401360:	b480      	push	{r7}
  401362:	b083      	sub	sp, #12
  401364:	af00      	add	r7, sp, #0
  401366:	4603      	mov	r3, r0
  401368:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40136a:	4909      	ldr	r1, [pc, #36]	; (401390 <NVIC_ClearPendingIRQ+0x30>)
  40136c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  401370:	095b      	lsrs	r3, r3, #5
  401372:	79fa      	ldrb	r2, [r7, #7]
  401374:	f002 021f 	and.w	r2, r2, #31
  401378:	2001      	movs	r0, #1
  40137a:	fa00 f202 	lsl.w	r2, r0, r2
  40137e:	3360      	adds	r3, #96	; 0x60
  401380:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  401384:	bf00      	nop
  401386:	370c      	adds	r7, #12
  401388:	46bd      	mov	sp, r7
  40138a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40138e:	4770      	bx	lr
  401390:	e000e100 	.word	0xe000e100

00401394 <TC2_Handler>:
 {
	 return RunTimeMilliseconds;
 }
//Timer interrupt.
 void TC2_Handler()
 {
  401394:	b598      	push	{r3, r4, r7, lr}
  401396:	af00      	add	r7, sp, #0
	if ((tc_get_status(RUN_TIMER, RUN_TIMER_CHANNEL) & TC_SR_CPCS) == TC_SR_CPCS)
  401398:	2102      	movs	r1, #2
  40139a:	480b      	ldr	r0, [pc, #44]	; (4013c8 <TC2_Handler+0x34>)
  40139c:	4b0b      	ldr	r3, [pc, #44]	; (4013cc <TC2_Handler+0x38>)
  40139e:	4798      	blx	r3
  4013a0:	4603      	mov	r3, r0
  4013a2:	f003 0310 	and.w	r3, r3, #16
  4013a6:	2b10      	cmp	r3, #16
  4013a8:	d10b      	bne.n	4013c2 <TC2_Handler+0x2e>
	{
		NVIC_ClearPendingIRQ(TC2_IRQn);
  4013aa:	2017      	movs	r0, #23
  4013ac:	4b08      	ldr	r3, [pc, #32]	; (4013d0 <TC2_Handler+0x3c>)
  4013ae:	4798      	blx	r3
		RunTimeMilliseconds++;
  4013b0:	4b08      	ldr	r3, [pc, #32]	; (4013d4 <TC2_Handler+0x40>)
  4013b2:	e9d3 3400 	ldrd	r3, r4, [r3]
  4013b6:	3301      	adds	r3, #1
  4013b8:	f144 0400 	adc.w	r4, r4, #0
  4013bc:	4a05      	ldr	r2, [pc, #20]	; (4013d4 <TC2_Handler+0x40>)
  4013be:	e9c2 3400 	strd	r3, r4, [r2]
	}
  4013c2:	bf00      	nop
  4013c4:	bd98      	pop	{r3, r4, r7, pc}
  4013c6:	bf00      	nop
  4013c8:	40090000 	.word	0x40090000
  4013cc:	0040160b 	.word	0x0040160b
  4013d0:	00401361 	.word	0x00401361
  4013d4:	20000a18 	.word	0x20000a18

004013d8 <GetUniqueID>:
 */ 
#include "security.h"

//Reads the flash ID as per the datasheet/ASF documentation and then sends it out to the user
uint32_t* GetUniqueID()
{
  4013d8:	b580      	push	{r7, lr}
  4013da:	b08c      	sub	sp, #48	; 0x30
  4013dc:	af00      	add	r7, sp, #0
	uint32_t unique_id[4];
	
	uint32_t ul_rc;
	
	/* Initialize Flash service */
	ul_rc = flash_init(FLASH_ACCESS_MODE_128, 4);
  4013de:	2104      	movs	r1, #4
  4013e0:	2000      	movs	r0, #0
  4013e2:	4b17      	ldr	r3, [pc, #92]	; (401440 <GetUniqueID+0x68>)
  4013e4:	4798      	blx	r3
  4013e6:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (ul_rc != FLASH_RC_OK)
  4013e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4013ea:	2b00      	cmp	r3, #0
  4013ec:	d00c      	beq.n	401408 <GetUniqueID+0x30>
	{
		Error_T FlashInitFailedError;
		FlashInitFailedError.ThrowerID = THROWER_ID_FLASH_SERVICE;
  4013ee:	2302      	movs	r3, #2
  4013f0:	613b      	str	r3, [r7, #16]
		FlashInitFailedError.ErrorMajor = FLASH_INIT_FAILED;
  4013f2:	230b      	movs	r3, #11
  4013f4:	617b      	str	r3, [r7, #20]
		FlashInitFailedError.ErrorMinor = ERROR_NO_MINOR_CODE;
  4013f6:	2300      	movs	r3, #0
  4013f8:	61bb      	str	r3, [r7, #24]
		ThrowError(&FlashInitFailedError);
  4013fa:	f107 0310 	add.w	r3, r7, #16
  4013fe:	4618      	mov	r0, r3
  401400:	4b10      	ldr	r3, [pc, #64]	; (401444 <GetUniqueID+0x6c>)
  401402:	4798      	blx	r3
		return NULL;
  401404:	2300      	movs	r3, #0
  401406:	e016      	b.n	401436 <GetUniqueID+0x5e>
	}

	/* Read the unique ID */
	ul_rc = flash_read_unique_id(unique_id, 4);
  401408:	f107 031c 	add.w	r3, r7, #28
  40140c:	2104      	movs	r1, #4
  40140e:	4618      	mov	r0, r3
  401410:	4b0d      	ldr	r3, [pc, #52]	; (401448 <GetUniqueID+0x70>)
  401412:	4798      	blx	r3
  401414:	62f8      	str	r0, [r7, #44]	; 0x2c
	
	if (ul_rc != FLASH_RC_OK)
  401416:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401418:	2b00      	cmp	r3, #0
  40141a:	d00b      	beq.n	401434 <GetUniqueID+0x5c>
	{
		Error_T FlashInitFailedError;
		FlashInitFailedError.ThrowerID = THROWER_ID_FLASH_SERVICE;
  40141c:	2302      	movs	r3, #2
  40141e:	607b      	str	r3, [r7, #4]
		FlashInitFailedError.ErrorMajor = FLASH_ID_READ_FAILED;
  401420:	230c      	movs	r3, #12
  401422:	60bb      	str	r3, [r7, #8]
		FlashInitFailedError.ErrorMinor = ERROR_NO_MINOR_CODE;
  401424:	2300      	movs	r3, #0
  401426:	60fb      	str	r3, [r7, #12]
		ThrowError(&FlashInitFailedError);
  401428:	1d3b      	adds	r3, r7, #4
  40142a:	4618      	mov	r0, r3
  40142c:	4b05      	ldr	r3, [pc, #20]	; (401444 <GetUniqueID+0x6c>)
  40142e:	4798      	blx	r3
		return NULL;
  401430:	2300      	movs	r3, #0
  401432:	e000      	b.n	401436 <GetUniqueID+0x5e>
	}
	
	return unique_id;
  401434:	2300      	movs	r3, #0
}
  401436:	4618      	mov	r0, r3
  401438:	3730      	adds	r7, #48	; 0x30
  40143a:	46bd      	mov	sp, r7
  40143c:	bd80      	pop	{r7, pc}
  40143e:	bf00      	nop
  401440:	004012a5 	.word	0x004012a5
  401444:	00401631 	.word	0x00401631
  401448:	004012cd 	.word	0x004012cd

0040144c <EnterSecureMode>:
//Calculates the secure key and verifies it against the received key. If they match, secure mode is entered
void EnterSecureMode(long key)
{
  40144c:	b580      	push	{r7, lr}
  40144e:	b086      	sub	sp, #24
  401450:	af00      	add	r7, sp, #0
  401452:	6078      	str	r0, [r7, #4]
	if(key != 0 && GetKey() == key )
  401454:	687b      	ldr	r3, [r7, #4]
  401456:	2b00      	cmp	r3, #0
  401458:	d00c      	beq.n	401474 <EnterSecureMode+0x28>
  40145a:	4b0e      	ldr	r3, [pc, #56]	; (401494 <EnterSecureMode+0x48>)
  40145c:	4798      	blx	r3
  40145e:	4602      	mov	r2, r0
  401460:	687b      	ldr	r3, [r7, #4]
  401462:	429a      	cmp	r2, r3
  401464:	d106      	bne.n	401474 <EnterSecureMode+0x28>
	{
		SystemConfiguration.in_secure_mode = true;
  401466:	4b0c      	ldr	r3, [pc, #48]	; (401498 <EnterSecureMode+0x4c>)
  401468:	2201      	movs	r2, #1
  40146a:	709a      	strb	r2, [r3, #2]
		SendStatusReport(ENTER_SECURE_MODE);
  40146c:	20e2      	movs	r0, #226	; 0xe2
  40146e:	4b0b      	ldr	r3, [pc, #44]	; (40149c <EnterSecureMode+0x50>)
  401470:	4798      	blx	r3
  401472:	e00a      	b.n	40148a <EnterSecureMode+0x3e>
	{
		//ErrorResponse[4] = ENTER_SECURE_MODE;
		//ErrorResponse[6] = INVALID_KEY;
		//WriteBufferOut(ErrorResponse, 7);
		Error_T FlashInitFailedError;
		FlashInitFailedError.ThrowerID = ENTER_SECURE_MODE;
  401474:	23e2      	movs	r3, #226	; 0xe2
  401476:	60fb      	str	r3, [r7, #12]
		FlashInitFailedError.ErrorMajor = INVALID_KEY;
  401478:	2314      	movs	r3, #20
  40147a:	613b      	str	r3, [r7, #16]
		FlashInitFailedError.ErrorMinor = ERROR_NO_MINOR_CODE;
  40147c:	2300      	movs	r3, #0
  40147e:	617b      	str	r3, [r7, #20]
		ThrowError(&FlashInitFailedError);
  401480:	f107 030c 	add.w	r3, r7, #12
  401484:	4618      	mov	r0, r3
  401486:	4b06      	ldr	r3, [pc, #24]	; (4014a0 <EnterSecureMode+0x54>)
  401488:	4798      	blx	r3
		//Error - Key Verification Failed
	}
}
  40148a:	bf00      	nop
  40148c:	3718      	adds	r7, #24
  40148e:	46bd      	mov	sp, r7
  401490:	bd80      	pop	{r7, pc}
  401492:	bf00      	nop
  401494:	004014c1 	.word	0x004014c1
  401498:	20000a20 	.word	0x20000a20
  40149c:	00401b15 	.word	0x00401b15
  4014a0:	00401631 	.word	0x00401631

004014a4 <ExitSecureMode>:
//Exits secure mode
void ExitSecureMode()
{
  4014a4:	b580      	push	{r7, lr}
  4014a6:	af00      	add	r7, sp, #0
	SystemConfiguration.in_secure_mode = false;
  4014a8:	4b03      	ldr	r3, [pc, #12]	; (4014b8 <ExitSecureMode+0x14>)
  4014aa:	2200      	movs	r2, #0
  4014ac:	709a      	strb	r2, [r3, #2]
	SendStatusReport(EXIT_SECURE_MODE);
  4014ae:	20e6      	movs	r0, #230	; 0xe6
  4014b0:	4b02      	ldr	r3, [pc, #8]	; (4014bc <ExitSecureMode+0x18>)
  4014b2:	4798      	blx	r3
} 
  4014b4:	bf00      	nop
  4014b6:	bd80      	pop	{r7, pc}
  4014b8:	20000a20 	.word	0x20000a20
  4014bc:	00401b15 	.word	0x00401b15

004014c0 <GetKey>:
//Calculates the key for the system
unsigned long GetKey()
{
  4014c0:	b580      	push	{r7, lr}
  4014c2:	b082      	sub	sp, #8
  4014c4:	af00      	add	r7, sp, #0
	uint32_t* unique_id  = GetUniqueID();
  4014c6:	4b0d      	ldr	r3, [pc, #52]	; (4014fc <GetKey+0x3c>)
  4014c8:	4798      	blx	r3
  4014ca:	6078      	str	r0, [r7, #4]
	if(unique_id != NULL)
  4014cc:	687b      	ldr	r3, [r7, #4]
  4014ce:	2b00      	cmp	r3, #0
  4014d0:	d00e      	beq.n	4014f0 <GetKey+0x30>
	{
		return (unique_id[0] | unique_id[2] ) ^ (unique_id[1] | unique_id[3]);	
  4014d2:	687b      	ldr	r3, [r7, #4]
  4014d4:	681a      	ldr	r2, [r3, #0]
  4014d6:	687b      	ldr	r3, [r7, #4]
  4014d8:	3308      	adds	r3, #8
  4014da:	681b      	ldr	r3, [r3, #0]
  4014dc:	431a      	orrs	r2, r3
  4014de:	687b      	ldr	r3, [r7, #4]
  4014e0:	3304      	adds	r3, #4
  4014e2:	6819      	ldr	r1, [r3, #0]
  4014e4:	687b      	ldr	r3, [r7, #4]
  4014e6:	330c      	adds	r3, #12
  4014e8:	681b      	ldr	r3, [r3, #0]
  4014ea:	430b      	orrs	r3, r1
  4014ec:	4053      	eors	r3, r2
  4014ee:	e000      	b.n	4014f2 <GetKey+0x32>
	}else
	{
		return 0;		
  4014f0:	2300      	movs	r3, #0
	}
}
  4014f2:	4618      	mov	r0, r3
  4014f4:	3708      	adds	r7, #8
  4014f6:	46bd      	mov	sp, r7
  4014f8:	bd80      	pop	{r7, pc}
  4014fa:	bf00      	nop
  4014fc:	004013d9 	.word	0x004013d9

00401500 <tc_init>:
 */
void tc_init(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_mode)
{
  401500:	b480      	push	{r7}
  401502:	b087      	sub	sp, #28
  401504:	af00      	add	r7, sp, #0
  401506:	60f8      	str	r0, [r7, #12]
  401508:	60b9      	str	r1, [r7, #8]
  40150a:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  40150c:	68fa      	ldr	r2, [r7, #12]
  40150e:	68bb      	ldr	r3, [r7, #8]
  401510:	019b      	lsls	r3, r3, #6
  401512:	4413      	add	r3, r2
  401514:	617b      	str	r3, [r7, #20]

	/*  Disable TC clock. */
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  401516:	697b      	ldr	r3, [r7, #20]
  401518:	2202      	movs	r2, #2
  40151a:	601a      	str	r2, [r3, #0]

	/*  Disable interrupts. */
	tc_channel->TC_IDR = 0xFFFFFFFF;
  40151c:	697b      	ldr	r3, [r7, #20]
  40151e:	f04f 32ff 	mov.w	r2, #4294967295
  401522:	629a      	str	r2, [r3, #40]	; 0x28

	/*  Clear status register. */
	tc_channel->TC_SR;
  401524:	697b      	ldr	r3, [r7, #20]
  401526:	6a1b      	ldr	r3, [r3, #32]

	/*  Set mode. */
	tc_channel->TC_CMR = ul_mode;
  401528:	697b      	ldr	r3, [r7, #20]
  40152a:	687a      	ldr	r2, [r7, #4]
  40152c:	605a      	str	r2, [r3, #4]
}
  40152e:	bf00      	nop
  401530:	371c      	adds	r7, #28
  401532:	46bd      	mov	sp, r7
  401534:	f85d 7b04 	ldr.w	r7, [sp], #4
  401538:	4770      	bx	lr

0040153a <tc_sync_trigger>:
 * \param[out] p_tc Module hardware register base address pointer
 *
 */
void tc_sync_trigger(
		Tc *p_tc)
{
  40153a:	b480      	push	{r7}
  40153c:	b083      	sub	sp, #12
  40153e:	af00      	add	r7, sp, #0
  401540:	6078      	str	r0, [r7, #4]
	/* Validate inputs. */
	Assert(p_tc);
	
	p_tc->TC_BCR = TC_BCR_SYNC;
  401542:	687b      	ldr	r3, [r7, #4]
  401544:	2201      	movs	r2, #1
  401546:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
}
  40154a:	bf00      	nop
  40154c:	370c      	adds	r7, #12
  40154e:	46bd      	mov	sp, r7
  401550:	f85d 7b04 	ldr.w	r7, [sp], #4
  401554:	4770      	bx	lr

00401556 <tc_start>:
 * \param[in] ul_channel Channel to configure
 */
void tc_start(
		Tc *p_tc,
		uint32_t ul_channel)
{
  401556:	b480      	push	{r7}
  401558:	b083      	sub	sp, #12
  40155a:	af00      	add	r7, sp, #0
  40155c:	6078      	str	r0, [r7, #4]
  40155e:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
  401560:	687a      	ldr	r2, [r7, #4]
  401562:	683b      	ldr	r3, [r7, #0]
  401564:	019b      	lsls	r3, r3, #6
  401566:	4413      	add	r3, r2
  401568:	2205      	movs	r2, #5
  40156a:	601a      	str	r2, [r3, #0]
}
  40156c:	bf00      	nop
  40156e:	370c      	adds	r7, #12
  401570:	46bd      	mov	sp, r7
  401572:	f85d 7b04 	ldr.w	r7, [sp], #4
  401576:	4770      	bx	lr

00401578 <tc_stop>:
 * \param[in] ul_channel Channel to configure
 */
void tc_stop(
		Tc *p_tc,
		uint32_t ul_channel)
{
  401578:	b480      	push	{r7}
  40157a:	b083      	sub	sp, #12
  40157c:	af00      	add	r7, sp, #0
  40157e:	6078      	str	r0, [r7, #4]
  401580:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKDIS;
  401582:	687a      	ldr	r2, [r7, #4]
  401584:	683b      	ldr	r3, [r7, #0]
  401586:	019b      	lsls	r3, r3, #6
  401588:	4413      	add	r3, r2
  40158a:	2202      	movs	r2, #2
  40158c:	601a      	str	r2, [r3, #0]
}
  40158e:	bf00      	nop
  401590:	370c      	adds	r7, #12
  401592:	46bd      	mov	sp, r7
  401594:	f85d 7b04 	ldr.w	r7, [sp], #4
  401598:	4770      	bx	lr

0040159a <tc_read_cv>:
 * \return The counter value.
 */
uint32_t tc_read_cv(
		Tc *p_tc,
		uint32_t ul_channel)
{
  40159a:	b480      	push	{r7}
  40159c:	b083      	sub	sp, #12
  40159e:	af00      	add	r7, sp, #0
  4015a0:	6078      	str	r0, [r7, #4]
  4015a2:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_CV;
  4015a4:	687a      	ldr	r2, [r7, #4]
  4015a6:	683b      	ldr	r3, [r7, #0]
  4015a8:	019b      	lsls	r3, r3, #6
  4015aa:	4413      	add	r3, r2
  4015ac:	3310      	adds	r3, #16
  4015ae:	681b      	ldr	r3, [r3, #0]
}
  4015b0:	4618      	mov	r0, r3
  4015b2:	370c      	adds	r7, #12
  4015b4:	46bd      	mov	sp, r7
  4015b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4015ba:	4770      	bx	lr

004015bc <tc_write_rc>:
 */
void tc_write_rc(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_value)
{
  4015bc:	b480      	push	{r7}
  4015be:	b085      	sub	sp, #20
  4015c0:	af00      	add	r7, sp, #0
  4015c2:	60f8      	str	r0, [r7, #12]
  4015c4:	60b9      	str	r1, [r7, #8]
  4015c6:	607a      	str	r2, [r7, #4]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_RC = ul_value;
  4015c8:	68fa      	ldr	r2, [r7, #12]
  4015ca:	68bb      	ldr	r3, [r7, #8]
  4015cc:	019b      	lsls	r3, r3, #6
  4015ce:	4413      	add	r3, r2
  4015d0:	331c      	adds	r3, #28
  4015d2:	687a      	ldr	r2, [r7, #4]
  4015d4:	601a      	str	r2, [r3, #0]
}
  4015d6:	bf00      	nop
  4015d8:	3714      	adds	r7, #20
  4015da:	46bd      	mov	sp, r7
  4015dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4015e0:	4770      	bx	lr

004015e2 <tc_enable_interrupt>:
 */
void tc_enable_interrupt(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_sources)
{
  4015e2:	b480      	push	{r7}
  4015e4:	b087      	sub	sp, #28
  4015e6:	af00      	add	r7, sp, #0
  4015e8:	60f8      	str	r0, [r7, #12]
  4015ea:	60b9      	str	r1, [r7, #8]
  4015ec:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4015ee:	68fa      	ldr	r2, [r7, #12]
  4015f0:	68bb      	ldr	r3, [r7, #8]
  4015f2:	019b      	lsls	r3, r3, #6
  4015f4:	4413      	add	r3, r2
  4015f6:	617b      	str	r3, [r7, #20]
	tc_channel->TC_IER = ul_sources;
  4015f8:	697b      	ldr	r3, [r7, #20]
  4015fa:	687a      	ldr	r2, [r7, #4]
  4015fc:	625a      	str	r2, [r3, #36]	; 0x24
}
  4015fe:	bf00      	nop
  401600:	371c      	adds	r7, #28
  401602:	46bd      	mov	sp, r7
  401604:	f85d 7b04 	ldr.w	r7, [sp], #4
  401608:	4770      	bx	lr

0040160a <tc_get_status>:
 * \return The current TC status.
 */
uint32_t tc_get_status(
		Tc *p_tc,
		uint32_t ul_channel)
{
  40160a:	b480      	push	{r7}
  40160c:	b085      	sub	sp, #20
  40160e:	af00      	add	r7, sp, #0
  401610:	6078      	str	r0, [r7, #4]
  401612:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
			
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  401614:	687a      	ldr	r2, [r7, #4]
  401616:	683b      	ldr	r3, [r7, #0]
  401618:	019b      	lsls	r3, r3, #6
  40161a:	4413      	add	r3, r2
  40161c:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_SR;
  40161e:	68fb      	ldr	r3, [r7, #12]
  401620:	6a1b      	ldr	r3, [r3, #32]
}
  401622:	4618      	mov	r0, r3
  401624:	3714      	adds	r7, #20
  401626:	46bd      	mov	sp, r7
  401628:	f85d 7b04 	ldr.w	r7, [sp], #4
  40162c:	4770      	bx	lr
	...

00401630 <ThrowError>:
 */ 

#include "ErrorHandler.h"

void ThrowError(Error_T *currError)
{
  401630:	b580      	push	{r7, lr}
  401632:	b086      	sub	sp, #24
  401634:	af00      	add	r7, sp, #0
  401636:	6078      	str	r0, [r7, #4]
	unsigned char error[] = {START_BYTE, 0x00, 0x04, ERROR_RESPONSE, currError->ThrowerID, currError->ErrorMajor, currError->ErrorMinor};
  401638:	2302      	movs	r3, #2
  40163a:	743b      	strb	r3, [r7, #16]
  40163c:	2300      	movs	r3, #0
  40163e:	747b      	strb	r3, [r7, #17]
  401640:	2304      	movs	r3, #4
  401642:	74bb      	strb	r3, [r7, #18]
  401644:	23ef      	movs	r3, #239	; 0xef
  401646:	74fb      	strb	r3, [r7, #19]
  401648:	687b      	ldr	r3, [r7, #4]
  40164a:	681b      	ldr	r3, [r3, #0]
  40164c:	b2db      	uxtb	r3, r3
  40164e:	753b      	strb	r3, [r7, #20]
  401650:	687b      	ldr	r3, [r7, #4]
  401652:	685b      	ldr	r3, [r3, #4]
  401654:	b2db      	uxtb	r3, r3
  401656:	757b      	strb	r3, [r7, #21]
  401658:	687b      	ldr	r3, [r7, #4]
  40165a:	689b      	ldr	r3, [r3, #8]
  40165c:	b2db      	uxtb	r3, r3
  40165e:	75bb      	strb	r3, [r7, #22]
		
	Message_t errorMessage;
	errorMessage.buf = error;
  401660:	f107 0310 	add.w	r3, r7, #16
  401664:	60bb      	str	r3, [r7, #8]
	errorMessage.Size = ERROR_MESSAGE_LENGTH+2;
  401666:	2307      	movs	r3, #7
  401668:	81bb      	strh	r3, [r7, #12]
	
	WriteMessage(&errorMessage);
  40166a:	f107 0308 	add.w	r3, r7, #8
  40166e:	4618      	mov	r0, r3
  401670:	4b02      	ldr	r3, [pc, #8]	; (40167c <ThrowError+0x4c>)
  401672:	4798      	blx	r3
	
  401674:	bf00      	nop
  401676:	3718      	adds	r7, #24
  401678:	46bd      	mov	sp, r7
  40167a:	bd80      	pop	{r7, pc}
  40167c:	00401a3d 	.word	0x00401a3d

00401680 <osc_get_rate>:
{
  401680:	b480      	push	{r7}
  401682:	b083      	sub	sp, #12
  401684:	af00      	add	r7, sp, #0
  401686:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401688:	687b      	ldr	r3, [r7, #4]
  40168a:	2b07      	cmp	r3, #7
  40168c:	d825      	bhi.n	4016da <osc_get_rate+0x5a>
  40168e:	a201      	add	r2, pc, #4	; (adr r2, 401694 <osc_get_rate+0x14>)
  401690:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401694:	004016b5 	.word	0x004016b5
  401698:	004016bb 	.word	0x004016bb
  40169c:	004016c1 	.word	0x004016c1
  4016a0:	004016c7 	.word	0x004016c7
  4016a4:	004016cb 	.word	0x004016cb
  4016a8:	004016cf 	.word	0x004016cf
  4016ac:	004016d3 	.word	0x004016d3
  4016b0:	004016d7 	.word	0x004016d7
		return OSC_SLCK_32K_RC_HZ;
  4016b4:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  4016b8:	e010      	b.n	4016dc <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  4016ba:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4016be:	e00d      	b.n	4016dc <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  4016c0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4016c4:	e00a      	b.n	4016dc <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  4016c6:	4b08      	ldr	r3, [pc, #32]	; (4016e8 <osc_get_rate+0x68>)
  4016c8:	e008      	b.n	4016dc <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  4016ca:	4b08      	ldr	r3, [pc, #32]	; (4016ec <osc_get_rate+0x6c>)
  4016cc:	e006      	b.n	4016dc <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  4016ce:	4b08      	ldr	r3, [pc, #32]	; (4016f0 <osc_get_rate+0x70>)
  4016d0:	e004      	b.n	4016dc <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  4016d2:	4b07      	ldr	r3, [pc, #28]	; (4016f0 <osc_get_rate+0x70>)
  4016d4:	e002      	b.n	4016dc <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  4016d6:	4b06      	ldr	r3, [pc, #24]	; (4016f0 <osc_get_rate+0x70>)
  4016d8:	e000      	b.n	4016dc <osc_get_rate+0x5c>
	return 0;
  4016da:	2300      	movs	r3, #0
}
  4016dc:	4618      	mov	r0, r3
  4016de:	370c      	adds	r7, #12
  4016e0:	46bd      	mov	sp, r7
  4016e2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4016e6:	4770      	bx	lr
  4016e8:	003d0900 	.word	0x003d0900
  4016ec:	007a1200 	.word	0x007a1200
  4016f0:	00b71b00 	.word	0x00b71b00

004016f4 <sysclk_get_main_hz>:
{
  4016f4:	b580      	push	{r7, lr}
  4016f6:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4016f8:	2006      	movs	r0, #6
  4016fa:	4b03      	ldr	r3, [pc, #12]	; (401708 <sysclk_get_main_hz+0x14>)
  4016fc:	4798      	blx	r3
  4016fe:	4603      	mov	r3, r0
  401700:	011b      	lsls	r3, r3, #4
}
  401702:	4618      	mov	r0, r3
  401704:	bd80      	pop	{r7, pc}
  401706:	bf00      	nop
  401708:	00401681 	.word	0x00401681

0040170c <sysclk_get_cpu_hz>:
{
  40170c:	b580      	push	{r7, lr}
  40170e:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  401710:	4b02      	ldr	r3, [pc, #8]	; (40171c <sysclk_get_cpu_hz+0x10>)
  401712:	4798      	blx	r3
  401714:	4603      	mov	r3, r0
  401716:	085b      	lsrs	r3, r3, #1
}
  401718:	4618      	mov	r0, r3
  40171a:	bd80      	pop	{r7, pc}
  40171c:	004016f5 	.word	0x004016f5

00401720 <ReceiveUSBMessage>:

char MessageAvailable = 0;
Message_t IncommingMessage;
//Message in
void ReceiveUSBMessage(uint8_t port)
{
  401720:	b580      	push	{r7, lr}
  401722:	b08e      	sub	sp, #56	; 0x38
  401724:	af00      	add	r7, sp, #0
  401726:	4603      	mov	r3, r0
  401728:	71fb      	strb	r3, [r7, #7]
	//Read a byte
	int currByte = udi_cdc_getc();
  40172a:	4b29      	ldr	r3, [pc, #164]	; (4017d0 <ReceiveUSBMessage+0xb0>)
  40172c:	4798      	blx	r3
  40172e:	6378      	str	r0, [r7, #52]	; 0x34

	if(currByte == START_BYTE )
  401730:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  401732:	2b02      	cmp	r3, #2
  401734:	d13c      	bne.n	4017b0 <ReceiveUSBMessage+0x90>
	{
		//Set the LEDs
		ui_com_rx_start();
  401736:	4b27      	ldr	r3, [pc, #156]	; (4017d4 <ReceiveUSBMessage+0xb4>)
  401738:	4798      	blx	r3
		//Get the lengths and the command
		int LenA = udi_cdc_getc();
  40173a:	4b25      	ldr	r3, [pc, #148]	; (4017d0 <ReceiveUSBMessage+0xb0>)
  40173c:	4798      	blx	r3
  40173e:	6338      	str	r0, [r7, #48]	; 0x30
		int LenB = udi_cdc_getc();
  401740:	4b23      	ldr	r3, [pc, #140]	; (4017d0 <ReceiveUSBMessage+0xb0>)
  401742:	4798      	blx	r3
  401744:	62f8      	str	r0, [r7, #44]	; 0x2c
		int CommandLength = (LenA << 8) | LenB;
  401746:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401748:	021a      	lsls	r2, r3, #8
  40174a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40174c:	4313      	orrs	r3, r2
  40174e:	62bb      	str	r3, [r7, #40]	; 0x28
		int ByteCounter = 0;	
  401750:	2300      	movs	r3, #0
  401752:	627b      	str	r3, [r7, #36]	; 0x24
		
		//Make sure we have enough bytes available
		if( (udi_cdc_get_available_rx_bytes() - 3) < CommandLength)
  401754:	4b20      	ldr	r3, [pc, #128]	; (4017d8 <ReceiveUSBMessage+0xb8>)
  401756:	4798      	blx	r3
  401758:	4603      	mov	r3, r0
  40175a:	1eda      	subs	r2, r3, #3
  40175c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40175e:	429a      	cmp	r2, r3
  401760:	da0e      	bge.n	401780 <ReceiveUSBMessage+0x60>
		{
			Error_T InvalidLengthByteError;
			InvalidLengthByteError.ThrowerID = THROWER_ID_COMMAND_RESPONSE_SYSTEM;
  401762:	2301      	movs	r3, #1
  401764:	61bb      	str	r3, [r7, #24]
			InvalidLengthByteError.ErrorMajor = INVALID_LENGTH_BYTES;
  401766:	2302      	movs	r3, #2
  401768:	61fb      	str	r3, [r7, #28]
			InvalidLengthByteError.ErrorMinor = ERROR_NO_MINOR_CODE;
  40176a:	2300      	movs	r3, #0
  40176c:	623b      	str	r3, [r7, #32]
			ThrowError(&InvalidLengthByteError);
  40176e:	f107 0318 	add.w	r3, r7, #24
  401772:	4618      	mov	r0, r3
  401774:	4b19      	ldr	r3, [pc, #100]	; (4017dc <ReceiveUSBMessage+0xbc>)
  401776:	4798      	blx	r3
			udi_cdc_flush_rx_buffer();
  401778:	4b19      	ldr	r3, [pc, #100]	; (4017e0 <ReceiveUSBMessage+0xc0>)
  40177a:	4798      	blx	r3
			return;
  40177c:	bf00      	nop
  40177e:	e024      	b.n	4017ca <ReceiveUSBMessage+0xaa>
		}
		//Set the buffer up and read the data
		IncommingMessage.buf = IncomingMessageBuffer;
  401780:	4b18      	ldr	r3, [pc, #96]	; (4017e4 <ReceiveUSBMessage+0xc4>)
  401782:	4a19      	ldr	r2, [pc, #100]	; (4017e8 <ReceiveUSBMessage+0xc8>)
  401784:	601a      	str	r2, [r3, #0]
		IncommingMessage.Size = CommandLength;
  401786:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401788:	b21a      	sxth	r2, r3
  40178a:	4b16      	ldr	r3, [pc, #88]	; (4017e4 <ReceiveUSBMessage+0xc4>)
  40178c:	809a      	strh	r2, [r3, #4]
		udi_cdc_read_buf(IncommingMessage.buf, IncommingMessage.Size);
  40178e:	4b15      	ldr	r3, [pc, #84]	; (4017e4 <ReceiveUSBMessage+0xc4>)
  401790:	681a      	ldr	r2, [r3, #0]
  401792:	4b14      	ldr	r3, [pc, #80]	; (4017e4 <ReceiveUSBMessage+0xc4>)
  401794:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  401798:	4619      	mov	r1, r3
  40179a:	4610      	mov	r0, r2
  40179c:	4b13      	ldr	r3, [pc, #76]	; (4017ec <ReceiveUSBMessage+0xcc>)
  40179e:	4798      	blx	r3
		udi_cdc_flush_rx_buffer();
  4017a0:	4b0f      	ldr	r3, [pc, #60]	; (4017e0 <ReceiveUSBMessage+0xc0>)
  4017a2:	4798      	blx	r3
		//Set the LEDs
		ui_com_rx_stop();
  4017a4:	4b12      	ldr	r3, [pc, #72]	; (4017f0 <ReceiveUSBMessage+0xd0>)
  4017a6:	4798      	blx	r3
		//We have a message available
		MessageAvailable = 1;
  4017a8:	4b12      	ldr	r3, [pc, #72]	; (4017f4 <ReceiveUSBMessage+0xd4>)
  4017aa:	2201      	movs	r2, #1
  4017ac:	701a      	strb	r2, [r3, #0]
  4017ae:	e00c      	b.n	4017ca <ReceiveUSBMessage+0xaa>
	}	
	else
	{
		//Was not a start byte
		Error_T InvalidLengthByteError;
		InvalidLengthByteError.ThrowerID = THROWER_ID_COMMAND_RESPONSE_SYSTEM;
  4017b0:	2301      	movs	r3, #1
  4017b2:	60fb      	str	r3, [r7, #12]
		InvalidLengthByteError.ErrorMajor = INVALID_START_BYTE_EXCEPTION;
  4017b4:	2301      	movs	r3, #1
  4017b6:	613b      	str	r3, [r7, #16]
		InvalidLengthByteError.ErrorMinor = currByte;
  4017b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4017ba:	617b      	str	r3, [r7, #20]
		ThrowError(&InvalidLengthByteError);
  4017bc:	f107 030c 	add.w	r3, r7, #12
  4017c0:	4618      	mov	r0, r3
  4017c2:	4b06      	ldr	r3, [pc, #24]	; (4017dc <ReceiveUSBMessage+0xbc>)
  4017c4:	4798      	blx	r3
		udi_cdc_flush_rx_buffer();
  4017c6:	4b06      	ldr	r3, [pc, #24]	; (4017e0 <ReceiveUSBMessage+0xc0>)
  4017c8:	4798      	blx	r3
	}

}
  4017ca:	3738      	adds	r7, #56	; 0x38
  4017cc:	46bd      	mov	sp, r7
  4017ce:	bd80      	pop	{r7, pc}
  4017d0:	004041a1 	.word	0x004041a1
  4017d4:	00401edd 	.word	0x00401edd
  4017d8:	00404555 	.word	0x00404555
  4017dc:	00401631 	.word	0x00401631
  4017e0:	0040450d 	.word	0x0040450d
  4017e4:	2000892c 	.word	0x2000892c
  4017e8:	20000a30 	.word	0x20000a30
  4017ec:	004042d5 	.word	0x004042d5
  4017f0:	00401ef1 	.word	0x00401ef1
  4017f4:	20001db8 	.word	0x20001db8

004017f8 <HandleMessage>:


//Message Run
void HandleMessage(Message_t *message)
{
  4017f8:	b580      	push	{r7, lr}
  4017fa:	b082      	sub	sp, #8
  4017fc:	af00      	add	r7, sp, #0
  4017fe:	6078      	str	r0, [r7, #4]
	//Switch on the command byte
	switch(message->buf[0])
  401800:	687b      	ldr	r3, [r7, #4]
  401802:	681b      	ldr	r3, [r3, #0]
  401804:	781b      	ldrb	r3, [r3, #0]
  401806:	2bc4      	cmp	r3, #196	; 0xc4
  401808:	d062      	beq.n	4018d0 <HandleMessage+0xd8>
  40180a:	2bc4      	cmp	r3, #196	; 0xc4
  40180c:	dc11      	bgt.n	401832 <HandleMessage+0x3a>
  40180e:	2bb0      	cmp	r3, #176	; 0xb0
  401810:	d04e      	beq.n	4018b0 <HandleMessage+0xb8>
  401812:	2bb0      	cmp	r3, #176	; 0xb0
  401814:	dc06      	bgt.n	401824 <HandleMessage+0x2c>
  401816:	2ba0      	cmp	r3, #160	; 0xa0
  401818:	d02a      	beq.n	401870 <HandleMessage+0x78>
  40181a:	2ba1      	cmp	r3, #161	; 0xa1
  40181c:	d02c      	beq.n	401878 <HandleMessage+0x80>
  40181e:	2b00      	cmp	r3, #0
  401820:	d01b      	beq.n	40185a <HandleMessage+0x62>
		
		case RESET_DEVICE:
			ResetDevice();
		break;
	}
}
  401822:	e063      	b.n	4018ec <HandleMessage+0xf4>
	switch(message->buf[0])
  401824:	2bbd      	cmp	r3, #189	; 0xbd
  401826:	d05b      	beq.n	4018e0 <HandleMessage+0xe8>
  401828:	2bc3      	cmp	r3, #195	; 0xc3
  40182a:	d04e      	beq.n	4018ca <HandleMessage+0xd2>
  40182c:	2bb1      	cmp	r3, #177	; 0xb1
  40182e:	d042      	beq.n	4018b6 <HandleMessage+0xbe>
}
  401830:	e05c      	b.n	4018ec <HandleMessage+0xf4>
	switch(message->buf[0])
  401832:	2be2      	cmp	r3, #226	; 0xe2
  401834:	d027      	beq.n	401886 <HandleMessage+0x8e>
  401836:	2be2      	cmp	r3, #226	; 0xe2
  401838:	dc06      	bgt.n	401848 <HandleMessage+0x50>
  40183a:	2be0      	cmp	r3, #224	; 0xe0
  40183c:	d015      	beq.n	40186a <HandleMessage+0x72>
  40183e:	2be0      	cmp	r3, #224	; 0xe0
  401840:	dc1e      	bgt.n	401880 <HandleMessage+0x88>
  401842:	2bc5      	cmp	r3, #197	; 0xc5
  401844:	d03d      	beq.n	4018c2 <HandleMessage+0xca>
}
  401846:	e051      	b.n	4018ec <HandleMessage+0xf4>
	switch(message->buf[0])
  401848:	2be4      	cmp	r3, #228	; 0xe4
  40184a:	d04c      	beq.n	4018e6 <HandleMessage+0xee>
  40184c:	2be4      	cmp	r3, #228	; 0xe4
  40184e:	db35      	blt.n	4018bc <HandleMessage+0xc4>
  401850:	2be6      	cmp	r3, #230	; 0xe6
  401852:	d02a      	beq.n	4018aa <HandleMessage+0xb2>
  401854:	2bfd      	cmp	r3, #253	; 0xfd
  401856:	d004      	beq.n	401862 <HandleMessage+0x6a>
}
  401858:	e048      	b.n	4018ec <HandleMessage+0xf4>
			SendStatusReport(STATUS_REQUEST);
  40185a:	2000      	movs	r0, #0
  40185c:	4b25      	ldr	r3, [pc, #148]	; (4018f4 <HandleMessage+0xfc>)
  40185e:	4798      	blx	r3
		break;
  401860:	e044      	b.n	4018ec <HandleMessage+0xf4>
			SetCommunicationMode(message);
  401862:	6878      	ldr	r0, [r7, #4]
  401864:	4b24      	ldr	r3, [pc, #144]	; (4018f8 <HandleMessage+0x100>)
  401866:	4798      	blx	r3
		break;
  401868:	e040      	b.n	4018ec <HandleMessage+0xf4>
			SendVersionReport();
  40186a:	4b24      	ldr	r3, [pc, #144]	; (4018fc <HandleMessage+0x104>)
  40186c:	4798      	blx	r3
		break;
  40186e:	e03d      	b.n	4018ec <HandleMessage+0xf4>
			SetInterfaceMode(message);
  401870:	6878      	ldr	r0, [r7, #4]
  401872:	4b23      	ldr	r3, [pc, #140]	; (401900 <HandleMessage+0x108>)
  401874:	4798      	blx	r3
		break;
  401876:	e039      	b.n	4018ec <HandleMessage+0xf4>
			WriteVehicleMessage(message);
  401878:	6878      	ldr	r0, [r7, #4]
  40187a:	4b22      	ldr	r3, [pc, #136]	; (401904 <HandleMessage+0x10c>)
  40187c:	4798      	blx	r3
		break;
  40187e:	e035      	b.n	4018ec <HandleMessage+0xf4>
			SendIdenifierReport();
  401880:	4b21      	ldr	r3, [pc, #132]	; (401908 <HandleMessage+0x110>)
  401882:	4798      	blx	r3
		break;
  401884:	e032      	b.n	4018ec <HandleMessage+0xf4>
			EnterSecureMode( (IncomingMessageBuffer[1] << 24) | (IncomingMessageBuffer[2] << 16) | (IncomingMessageBuffer[3] << 8) | (IncomingMessageBuffer[4] << 0)  );
  401886:	4b21      	ldr	r3, [pc, #132]	; (40190c <HandleMessage+0x114>)
  401888:	785b      	ldrb	r3, [r3, #1]
  40188a:	061a      	lsls	r2, r3, #24
  40188c:	4b1f      	ldr	r3, [pc, #124]	; (40190c <HandleMessage+0x114>)
  40188e:	789b      	ldrb	r3, [r3, #2]
  401890:	041b      	lsls	r3, r3, #16
  401892:	431a      	orrs	r2, r3
  401894:	4b1d      	ldr	r3, [pc, #116]	; (40190c <HandleMessage+0x114>)
  401896:	78db      	ldrb	r3, [r3, #3]
  401898:	021b      	lsls	r3, r3, #8
  40189a:	4313      	orrs	r3, r2
  40189c:	4a1b      	ldr	r2, [pc, #108]	; (40190c <HandleMessage+0x114>)
  40189e:	7912      	ldrb	r2, [r2, #4]
  4018a0:	4313      	orrs	r3, r2
  4018a2:	4618      	mov	r0, r3
  4018a4:	4b1a      	ldr	r3, [pc, #104]	; (401910 <HandleMessage+0x118>)
  4018a6:	4798      	blx	r3
		break;
  4018a8:	e020      	b.n	4018ec <HandleMessage+0xf4>
			ExitSecureMode();
  4018aa:	4b1a      	ldr	r3, [pc, #104]	; (401914 <HandleMessage+0x11c>)
  4018ac:	4798      	blx	r3
		break;
  4018ae:	e01d      	b.n	4018ec <HandleMessage+0xf4>
			VPWEnter1xMode();
  4018b0:	4b19      	ldr	r3, [pc, #100]	; (401918 <HandleMessage+0x120>)
  4018b2:	4798      	blx	r3
		break;
  4018b4:	e01a      	b.n	4018ec <HandleMessage+0xf4>
			VPWEnter4xMode();
  4018b6:	4b19      	ldr	r3, [pc, #100]	; (40191c <HandleMessage+0x124>)
  4018b8:	4798      	blx	r3
		break;
  4018ba:	e017      	b.n	4018ec <HandleMessage+0xf4>
			EnterBootloader();
  4018bc:	4b18      	ldr	r3, [pc, #96]	; (401920 <HandleMessage+0x128>)
  4018be:	4798      	blx	r3
		break;
  4018c0:	e014      	b.n	4018ec <HandleMessage+0xf4>
			CreateCanFilter(message);
  4018c2:	6878      	ldr	r0, [r7, #4]
  4018c4:	4b17      	ldr	r3, [pc, #92]	; (401924 <HandleMessage+0x12c>)
  4018c6:	4798      	blx	r3
		break;
  4018c8:	e010      	b.n	4018ec <HandleMessage+0xf4>
			DeleteAllFilters();
  4018ca:	4b17      	ldr	r3, [pc, #92]	; (401928 <HandleMessage+0x130>)
  4018cc:	4798      	blx	r3
		break;
  4018ce:	e00d      	b.n	4018ec <HandleMessage+0xf4>
		RemoveMailbox(message->buf[1]); 		
  4018d0:	687b      	ldr	r3, [r7, #4]
  4018d2:	681b      	ldr	r3, [r3, #0]
  4018d4:	3301      	adds	r3, #1
  4018d6:	781b      	ldrb	r3, [r3, #0]
  4018d8:	4618      	mov	r0, r3
  4018da:	4b14      	ldr	r3, [pc, #80]	; (40192c <HandleMessage+0x134>)
  4018dc:	4798      	blx	r3
		break;
  4018de:	e005      	b.n	4018ec <HandleMessage+0xf4>
			ReadADCValues();
  4018e0:	4b13      	ldr	r3, [pc, #76]	; (401930 <HandleMessage+0x138>)
  4018e2:	4798      	blx	r3
		break;
  4018e4:	e002      	b.n	4018ec <HandleMessage+0xf4>
			ResetDevice();
  4018e6:	4b13      	ldr	r3, [pc, #76]	; (401934 <HandleMessage+0x13c>)
  4018e8:	4798      	blx	r3
		break;
  4018ea:	bf00      	nop
}
  4018ec:	bf00      	nop
  4018ee:	3708      	adds	r7, #8
  4018f0:	46bd      	mov	sp, r7
  4018f2:	bd80      	pop	{r7, pc}
  4018f4:	00401b15 	.word	0x00401b15
  4018f8:	00401c21 	.word	0x00401c21
  4018fc:	00401b6d 	.word	0x00401b6d
  401900:	00401c81 	.word	0x00401c81
  401904:	00401aa9 	.word	0x00401aa9
  401908:	00401ba1 	.word	0x00401ba1
  40190c:	20000a30 	.word	0x20000a30
  401910:	0040144d 	.word	0x0040144d
  401914:	004014a5 	.word	0x004014a5
  401918:	004035f1 	.word	0x004035f1
  40191c:	00403669 	.word	0x00403669
  401920:	00401d5d 	.word	0x00401d5d
  401924:	00401979 	.word	0x00401979
  401928:	004020c1 	.word	0x004020c1
  40192c:	00402aa5 	.word	0x00402aa5
  401930:	004004a5 	.word	0x004004a5
  401934:	00401939 	.word	0x00401939

00401938 <ResetDevice>:
//Soft Reset of the device
void ResetDevice()
{
  401938:	b580      	push	{r7, lr}
  40193a:	af00      	add	r7, sp, #0
	SystemConfiguration.bluetooth_unlocked = 0;
  40193c:	4b0a      	ldr	r3, [pc, #40]	; (401968 <ResetDevice+0x30>)
  40193e:	2200      	movs	r2, #0
  401940:	70da      	strb	r2, [r3, #3]
	SystemConfiguration.in_secure_mode = 0;
  401942:	4b09      	ldr	r3, [pc, #36]	; (401968 <ResetDevice+0x30>)
  401944:	2200      	movs	r2, #0
  401946:	709a      	strb	r2, [r3, #2]
	SystemConfiguration.pc_com_mode = PC_COM_MODE_USB;
  401948:	4b07      	ldr	r3, [pc, #28]	; (401968 <ResetDevice+0x30>)
  40194a:	2200      	movs	r2, #0
  40194c:	701a      	strb	r2, [r3, #0]
	SystemConfiguration.vehicle_com_mode = NONE;
  40194e:	4b06      	ldr	r3, [pc, #24]	; (401968 <ResetDevice+0x30>)
  401950:	22ff      	movs	r2, #255	; 0xff
  401952:	705a      	strb	r2, [r3, #1]
	VPWFilterEnable = true;
  401954:	4b05      	ldr	r3, [pc, #20]	; (40196c <ResetDevice+0x34>)
  401956:	2201      	movs	r2, #1
  401958:	701a      	strb	r2, [r3, #0]
	udi_cdc_flush_rx_buffer();
  40195a:	4b05      	ldr	r3, [pc, #20]	; (401970 <ResetDevice+0x38>)
  40195c:	4798      	blx	r3
	SendStatusReport(RESET_DEVICE);
  40195e:	20e4      	movs	r0, #228	; 0xe4
  401960:	4b04      	ldr	r3, [pc, #16]	; (401974 <ResetDevice+0x3c>)
  401962:	4798      	blx	r3
}
  401964:	bf00      	nop
  401966:	bd80      	pop	{r7, pc}
  401968:	20000a28 	.word	0x20000a28
  40196c:	20000a2d 	.word	0x20000a2d
  401970:	0040450d 	.word	0x0040450d
  401974:	00401b15 	.word	0x00401b15

00401978 <CreateCanFilter>:


 //Create a filter for the CAN system.
 void CreateCanFilter(Message_t *message)
 {
  401978:	b5b0      	push	{r4, r5, r7, lr}
  40197a:	b088      	sub	sp, #32
  40197c:	af02      	add	r7, sp, #8
  40197e:	6078      	str	r0, [r7, #4]
	uint16_t FilterLength; 
	//Length of the filter
	FilterLength = message->buf[1] << 8 | message->buf[2];	
  401980:	687b      	ldr	r3, [r7, #4]
  401982:	681b      	ldr	r3, [r3, #0]
  401984:	3301      	adds	r3, #1
  401986:	781b      	ldrb	r3, [r3, #0]
  401988:	021b      	lsls	r3, r3, #8
  40198a:	b21a      	sxth	r2, r3
  40198c:	687b      	ldr	r3, [r7, #4]
  40198e:	681b      	ldr	r3, [r3, #0]
  401990:	3302      	adds	r3, #2
  401992:	781b      	ldrb	r3, [r3, #0]
  401994:	b21b      	sxth	r3, r3
  401996:	4313      	orrs	r3, r2
  401998:	b21b      	sxth	r3, r3
  40199a:	82fb      	strh	r3, [r7, #22]
	//Creates the Filter
	CreateFilter(message->buf[3],message->buf+5,message->buf+FilterLength+5,message->buf+FilterLength+FilterLength+5,FilterLength);
  40199c:	687b      	ldr	r3, [r7, #4]
  40199e:	681b      	ldr	r3, [r3, #0]
  4019a0:	3303      	adds	r3, #3
  4019a2:	7818      	ldrb	r0, [r3, #0]
  4019a4:	687b      	ldr	r3, [r7, #4]
  4019a6:	681b      	ldr	r3, [r3, #0]
  4019a8:	1d5c      	adds	r4, r3, #5
  4019aa:	687b      	ldr	r3, [r7, #4]
  4019ac:	681a      	ldr	r2, [r3, #0]
  4019ae:	8afb      	ldrh	r3, [r7, #22]
  4019b0:	3305      	adds	r3, #5
  4019b2:	18d5      	adds	r5, r2, r3
  4019b4:	687b      	ldr	r3, [r7, #4]
  4019b6:	681a      	ldr	r2, [r3, #0]
  4019b8:	8af9      	ldrh	r1, [r7, #22]
  4019ba:	8afb      	ldrh	r3, [r7, #22]
  4019bc:	440b      	add	r3, r1
  4019be:	3305      	adds	r3, #5
  4019c0:	441a      	add	r2, r3
  4019c2:	8afb      	ldrh	r3, [r7, #22]
  4019c4:	9300      	str	r3, [sp, #0]
  4019c6:	4613      	mov	r3, r2
  4019c8:	462a      	mov	r2, r5
  4019ca:	4621      	mov	r1, r4
  4019cc:	4c17      	ldr	r4, [pc, #92]	; (401a2c <CreateCanFilter+0xb4>)
  4019ce:	47a0      	blx	r4
	//Sets up a receiver mailbox (see CAN section of datasheet)
	InitalizeReceiverMailbox(message->buf[1],message->buf+5,message->buf+FilterLength+5);
  4019d0:	687b      	ldr	r3, [r7, #4]
  4019d2:	681b      	ldr	r3, [r3, #0]
  4019d4:	3301      	adds	r3, #1
  4019d6:	7818      	ldrb	r0, [r3, #0]
  4019d8:	687b      	ldr	r3, [r7, #4]
  4019da:	681b      	ldr	r3, [r3, #0]
  4019dc:	1d59      	adds	r1, r3, #5
  4019de:	687b      	ldr	r3, [r7, #4]
  4019e0:	681a      	ldr	r2, [r3, #0]
  4019e2:	8afb      	ldrh	r3, [r7, #22]
  4019e4:	3305      	adds	r3, #5
  4019e6:	4413      	add	r3, r2
  4019e8:	461a      	mov	r2, r3
  4019ea:	4b11      	ldr	r3, [pc, #68]	; (401a30 <CreateCanFilter+0xb8>)
  4019ec:	4798      	blx	r3
	//Notify user we did it
	char tmpRtn[] = {START_BYTE,0x00,0x03,CREATE_CAN_FILTER,0x01,rx_mailbox_num-1};
  4019ee:	2302      	movs	r3, #2
  4019f0:	743b      	strb	r3, [r7, #16]
  4019f2:	2300      	movs	r3, #0
  4019f4:	747b      	strb	r3, [r7, #17]
  4019f6:	2303      	movs	r3, #3
  4019f8:	74bb      	strb	r3, [r7, #18]
  4019fa:	23c5      	movs	r3, #197	; 0xc5
  4019fc:	74fb      	strb	r3, [r7, #19]
  4019fe:	2301      	movs	r3, #1
  401a00:	753b      	strb	r3, [r7, #20]
  401a02:	4b0c      	ldr	r3, [pc, #48]	; (401a34 <CreateCanFilter+0xbc>)
  401a04:	681b      	ldr	r3, [r3, #0]
  401a06:	b2db      	uxtb	r3, r3
  401a08:	3b01      	subs	r3, #1
  401a0a:	b2db      	uxtb	r3, r3
  401a0c:	757b      	strb	r3, [r7, #21]
	Message_t CanRxSettingsAck;
	CanRxSettingsAck.buf = tmpRtn;
  401a0e:	f107 0310 	add.w	r3, r7, #16
  401a12:	60bb      	str	r3, [r7, #8]
	CanRxSettingsAck.Size = 6;
  401a14:	2306      	movs	r3, #6
  401a16:	81bb      	strh	r3, [r7, #12]
	WriteMessage(&CanRxSettingsAck);
  401a18:	f107 0308 	add.w	r3, r7, #8
  401a1c:	4618      	mov	r0, r3
  401a1e:	4b06      	ldr	r3, [pc, #24]	; (401a38 <CreateCanFilter+0xc0>)
  401a20:	4798      	blx	r3
 }
  401a22:	bf00      	nop
  401a24:	3718      	adds	r7, #24
  401a26:	46bd      	mov	sp, r7
  401a28:	bdb0      	pop	{r4, r5, r7, pc}
  401a2a:	bf00      	nop
  401a2c:	00401fcd 	.word	0x00401fcd
  401a30:	004029a5 	.word	0x004029a5
  401a34:	20000174 	.word	0x20000174
  401a38:	00401a3d 	.word	0x00401a3d

00401a3c <WriteMessage>:
 
			
//Writes a message out to the user depending on the mode the interface is in (Bluetooth or USB)
void WriteMessage(Message_t *OutgoingMessage)
{
  401a3c:	b580      	push	{r7, lr}
  401a3e:	b086      	sub	sp, #24
  401a40:	af00      	add	r7, sp, #0
  401a42:	6078      	str	r0, [r7, #4]
	Error_T InvalidLengthByteError;
	switch(SystemConfiguration.pc_com_mode)
  401a44:	4b13      	ldr	r3, [pc, #76]	; (401a94 <WriteMessage+0x58>)
  401a46:	781b      	ldrb	r3, [r3, #0]
  401a48:	2b00      	cmp	r3, #0
  401a4a:	d002      	beq.n	401a52 <WriteMessage+0x16>
  401a4c:	2b01      	cmp	r3, #1
  401a4e:	d01b      	beq.n	401a88 <WriteMessage+0x4c>
  401a50:	e00d      	b.n	401a6e <WriteMessage+0x32>
	{
		case PC_COM_MODE_USB:
			ui_com_tx_start();
  401a52:	4b11      	ldr	r3, [pc, #68]	; (401a98 <WriteMessage+0x5c>)
  401a54:	4798      	blx	r3
			udi_cdc_write_buf(OutgoingMessage->buf, OutgoingMessage->Size);
  401a56:	687b      	ldr	r3, [r7, #4]
  401a58:	681a      	ldr	r2, [r3, #0]
  401a5a:	687b      	ldr	r3, [r7, #4]
  401a5c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  401a60:	4619      	mov	r1, r3
  401a62:	4610      	mov	r0, r2
  401a64:	4b0d      	ldr	r3, [pc, #52]	; (401a9c <WriteMessage+0x60>)
  401a66:	4798      	blx	r3
			ui_com_tx_stop();	
  401a68:	4b0d      	ldr	r3, [pc, #52]	; (401aa0 <WriteMessage+0x64>)
  401a6a:	4798      	blx	r3
		break;
  401a6c:	e00d      	b.n	401a8a <WriteMessage+0x4e>
#endif

		default:
			//Thats awkward. . .I have no way to talk to the world! :'(

			InvalidLengthByteError.ThrowerID = THROWER_ID_COMMAND_RESPONSE_SYSTEM;
  401a6e:	2301      	movs	r3, #1
  401a70:	60fb      	str	r3, [r7, #12]
			InvalidLengthByteError.ErrorMajor = UNREACHABLE_STATE_REACHED_EXCPETION;
  401a72:	2305      	movs	r3, #5
  401a74:	613b      	str	r3, [r7, #16]
			InvalidLengthByteError.ErrorMinor = SystemConfiguration.pc_com_mode;
  401a76:	4b07      	ldr	r3, [pc, #28]	; (401a94 <WriteMessage+0x58>)
  401a78:	781b      	ldrb	r3, [r3, #0]
  401a7a:	617b      	str	r3, [r7, #20]
			ThrowError(&InvalidLengthByteError);
  401a7c:	f107 030c 	add.w	r3, r7, #12
  401a80:	4618      	mov	r0, r3
  401a82:	4b08      	ldr	r3, [pc, #32]	; (401aa4 <WriteMessage+0x68>)
  401a84:	4798      	blx	r3
		break;
  401a86:	e000      	b.n	401a8a <WriteMessage+0x4e>
		break;
  401a88:	bf00      	nop
		
	}
	
}
  401a8a:	bf00      	nop
  401a8c:	3718      	adds	r7, #24
  401a8e:	46bd      	mov	sp, r7
  401a90:	bd80      	pop	{r7, pc}
  401a92:	bf00      	nop
  401a94:	20000a28 	.word	0x20000a28
  401a98:	00401f05 	.word	0x00401f05
  401a9c:	004044e9 	.word	0x004044e9
  401aa0:	00401f19 	.word	0x00401f19
  401aa4:	00401631 	.word	0x00401631

00401aa8 <WriteVehicleMessage>:

//Writes a message to the vehicle depdning on what mode the interface is in
void WriteVehicleMessage(Message_t *OutgoingMessage)
{
  401aa8:	b580      	push	{r7, lr}
  401aaa:	b082      	sub	sp, #8
  401aac:	af00      	add	r7, sp, #0
  401aae:	6078      	str	r0, [r7, #4]
	//Can_Message_t CanTXMessage;
	switch(SystemConfiguration.vehicle_com_mode)
  401ab0:	4b14      	ldr	r3, [pc, #80]	; (401b04 <WriteVehicleMessage+0x5c>)
  401ab2:	785b      	ldrb	r3, [r3, #1]
  401ab4:	2b00      	cmp	r3, #0
  401ab6:	d002      	beq.n	401abe <WriteVehicleMessage+0x16>
  401ab8:	2b02      	cmp	r3, #2
  401aba:	d01a      	beq.n	401af2 <WriteVehicleMessage+0x4a>
		
		case CAN_MODE:
		 HandleSendCanRequest(OutgoingMessage);
		break;
	}
}
  401abc:	e01d      	b.n	401afa <WriteVehicleMessage+0x52>
  __ASM volatile ("cpsid i" : : : "memory");
  401abe:	b672      	cpsid	i
  401ac0:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
  401ac4:	4b10      	ldr	r3, [pc, #64]	; (401b08 <WriteVehicleMessage+0x60>)
  401ac6:	2200      	movs	r2, #0
  401ac8:	701a      	strb	r2, [r3, #0]
			VPWSendNetworkMessage(OutgoingMessage->buf + 1,	OutgoingMessage->Size-1);
  401aca:	687b      	ldr	r3, [r7, #4]
  401acc:	681b      	ldr	r3, [r3, #0]
  401ace:	1c5a      	adds	r2, r3, #1
  401ad0:	687b      	ldr	r3, [r7, #4]
  401ad2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  401ad6:	b29b      	uxth	r3, r3
  401ad8:	3b01      	subs	r3, #1
  401ada:	b29b      	uxth	r3, r3
  401adc:	4619      	mov	r1, r3
  401ade:	4610      	mov	r0, r2
  401ae0:	4b0a      	ldr	r3, [pc, #40]	; (401b0c <WriteVehicleMessage+0x64>)
  401ae2:	4798      	blx	r3
			cpu_irq_enable();
  401ae4:	4b08      	ldr	r3, [pc, #32]	; (401b08 <WriteVehicleMessage+0x60>)
  401ae6:	2201      	movs	r2, #1
  401ae8:	701a      	strb	r2, [r3, #0]
  401aea:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  401aee:	b662      	cpsie	i
		break;
  401af0:	e003      	b.n	401afa <WriteVehicleMessage+0x52>
		 HandleSendCanRequest(OutgoingMessage);
  401af2:	6878      	ldr	r0, [r7, #4]
  401af4:	4b06      	ldr	r3, [pc, #24]	; (401b10 <WriteVehicleMessage+0x68>)
  401af6:	4798      	blx	r3
		break;
  401af8:	bf00      	nop
}
  401afa:	bf00      	nop
  401afc:	3708      	adds	r7, #8
  401afe:	46bd      	mov	sp, r7
  401b00:	bd80      	pop	{r7, pc}
  401b02:	bf00      	nop
  401b04:	20000a28 	.word	0x20000a28
  401b08:	200001aa 	.word	0x200001aa
  401b0c:	00403441 	.word	0x00403441
  401b10:	00402761 	.word	0x00402761

00401b14 <SendStatusReport>:

//Send a status report. The response byte is used to tell the user what we are responding to as 
//multiple commands will return a status report. 
void SendStatusReport(uint8_t ResponseByte)
{
  401b14:	b580      	push	{r7, lr}
  401b16:	b086      	sub	sp, #24
  401b18:	af00      	add	r7, sp, #0
  401b1a:	4603      	mov	r3, r0
  401b1c:	71fb      	strb	r3, [r7, #7]
	uint8_t StatusReportBuf[] = {START_BYTE, 0x00, (STATUS_MESSAGE_LENGTH-MESSAGE_BYTES_TO_LENGTH_LSB), ResponseByte, SystemConfiguration.vehicle_com_mode, SystemConfiguration.in_secure_mode, SystemConfiguration.pc_com_mode, SystemConfiguration.bluetooth_unlocked};
  401b1e:	2302      	movs	r3, #2
  401b20:	743b      	strb	r3, [r7, #16]
  401b22:	2300      	movs	r3, #0
  401b24:	747b      	strb	r3, [r7, #17]
  401b26:	2304      	movs	r3, #4
  401b28:	74bb      	strb	r3, [r7, #18]
  401b2a:	79fb      	ldrb	r3, [r7, #7]
  401b2c:	74fb      	strb	r3, [r7, #19]
  401b2e:	4b0d      	ldr	r3, [pc, #52]	; (401b64 <SendStatusReport+0x50>)
  401b30:	785b      	ldrb	r3, [r3, #1]
  401b32:	753b      	strb	r3, [r7, #20]
  401b34:	4b0b      	ldr	r3, [pc, #44]	; (401b64 <SendStatusReport+0x50>)
  401b36:	789b      	ldrb	r3, [r3, #2]
  401b38:	757b      	strb	r3, [r7, #21]
  401b3a:	4b0a      	ldr	r3, [pc, #40]	; (401b64 <SendStatusReport+0x50>)
  401b3c:	781b      	ldrb	r3, [r3, #0]
  401b3e:	75bb      	strb	r3, [r7, #22]
  401b40:	4b08      	ldr	r3, [pc, #32]	; (401b64 <SendStatusReport+0x50>)
  401b42:	78db      	ldrb	r3, [r3, #3]
  401b44:	75fb      	strb	r3, [r7, #23]
	Message_t StatusReportMessage;
	
	StatusReportMessage.buf = StatusReportBuf;
  401b46:	f107 0310 	add.w	r3, r7, #16
  401b4a:	60bb      	str	r3, [r7, #8]
	StatusReportMessage.Size = STATUS_MESSAGE_LENGTH;
  401b4c:	2307      	movs	r3, #7
  401b4e:	81bb      	strh	r3, [r7, #12]
	
	WriteMessage(&StatusReportMessage);
  401b50:	f107 0308 	add.w	r3, r7, #8
  401b54:	4618      	mov	r0, r3
  401b56:	4b04      	ldr	r3, [pc, #16]	; (401b68 <SendStatusReport+0x54>)
  401b58:	4798      	blx	r3
}
  401b5a:	bf00      	nop
  401b5c:	3718      	adds	r7, #24
  401b5e:	46bd      	mov	sp, r7
  401b60:	bd80      	pop	{r7, pc}
  401b62:	bf00      	nop
  401b64:	20000a28 	.word	0x20000a28
  401b68:	00401a3d 	.word	0x00401a3d

00401b6c <SendVersionReport>:
//Sends the version
void SendVersionReport()
{
  401b6c:	b580      	push	{r7, lr}
  401b6e:	b086      	sub	sp, #24
  401b70:	af00      	add	r7, sp, #0
	uint8_t VersionReportBuf[] = {START_BYTE, 0x00,0x7,VERSION_REQUEST, ENGINEERING_FIRMWARE, MAJOR, MINOR, DATE_MM, DATE_DD, DATE_YY};
  401b72:	4a09      	ldr	r2, [pc, #36]	; (401b98 <SendVersionReport+0x2c>)
  401b74:	f107 030c 	add.w	r3, r7, #12
  401b78:	ca07      	ldmia	r2, {r0, r1, r2}
  401b7a:	c303      	stmia	r3!, {r0, r1}
  401b7c:	801a      	strh	r2, [r3, #0]
	Message_t VersionReport;
	VersionReport.buf = VersionReportBuf;
  401b7e:	f107 030c 	add.w	r3, r7, #12
  401b82:	607b      	str	r3, [r7, #4]
	VersionReport.Size = 10;
  401b84:	230a      	movs	r3, #10
  401b86:	813b      	strh	r3, [r7, #8]
	WriteMessage(&VersionReport);
  401b88:	1d3b      	adds	r3, r7, #4
  401b8a:	4618      	mov	r0, r3
  401b8c:	4b03      	ldr	r3, [pc, #12]	; (401b9c <SendVersionReport+0x30>)
  401b8e:	4798      	blx	r3
}
  401b90:	bf00      	nop
  401b92:	3718      	adds	r7, #24
  401b94:	46bd      	mov	sp, r7
  401b96:	bd80      	pop	{r7, pc}
  401b98:	0040ac54 	.word	0x0040ac54
  401b9c:	00401a3d 	.word	0x00401a3d

00401ba0 <SendIdenifierReport>:
//Reads the flash ID as per the datasheet/ASF documentation and then sends it out to the user
void SendIdenifierReport()
{
  401ba0:	b580      	push	{r7, lr}
  401ba2:	b08c      	sub	sp, #48	; 0x30
  401ba4:	af00      	add	r7, sp, #0
	uint32_t* ID = GetUniqueID();
  401ba6:	4b1a      	ldr	r3, [pc, #104]	; (401c10 <SendIdenifierReport+0x70>)
  401ba8:	4798      	blx	r3
  401baa:	62f8      	str	r0, [r7, #44]	; 0x2c
	if(ID == NULL)
  401bac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401bae:	2b00      	cmp	r3, #0
  401bb0:	d10b      	bne.n	401bca <SendIdenifierReport+0x2a>
	{
		Error_T GetIDFailedError;
		GetIDFailedError.ThrowerID = READ_UNIQUE_ID;
  401bb2:	23e1      	movs	r3, #225	; 0xe1
  401bb4:	607b      	str	r3, [r7, #4]
		GetIDFailedError.ErrorMajor = FLASH_ID_READ_FAILED;
  401bb6:	230c      	movs	r3, #12
  401bb8:	60bb      	str	r3, [r7, #8]
		GetIDFailedError.ErrorMinor = ERROR_NO_MINOR_CODE;
  401bba:	2300      	movs	r3, #0
  401bbc:	60fb      	str	r3, [r7, #12]
		ThrowError(&GetIDFailedError); 
  401bbe:	1d3b      	adds	r3, r7, #4
  401bc0:	4618      	mov	r0, r3
  401bc2:	4b14      	ldr	r3, [pc, #80]	; (401c14 <SendIdenifierReport+0x74>)
  401bc4:	4798      	blx	r3
		return; 
  401bc6:	bf00      	nop
  401bc8:	e01f      	b.n	401c0a <SendIdenifierReport+0x6a>
	}
	
	uint8_t tmpRtn[20] = {0x02, 0x00, 0x14, READ_UNIQUE_ID};
  401bca:	f107 0318 	add.w	r3, r7, #24
  401bce:	2200      	movs	r2, #0
  401bd0:	601a      	str	r2, [r3, #0]
  401bd2:	605a      	str	r2, [r3, #4]
  401bd4:	609a      	str	r2, [r3, #8]
  401bd6:	60da      	str	r2, [r3, #12]
  401bd8:	611a      	str	r2, [r3, #16]
  401bda:	2302      	movs	r3, #2
  401bdc:	763b      	strb	r3, [r7, #24]
  401bde:	2314      	movs	r3, #20
  401be0:	76bb      	strb	r3, [r7, #26]
  401be2:	23e1      	movs	r3, #225	; 0xe1
  401be4:	76fb      	strb	r3, [r7, #27]
	memcpy(tmpRtn+4,ID,20);
  401be6:	f107 0318 	add.w	r3, r7, #24
  401bea:	3304      	adds	r3, #4
  401bec:	2214      	movs	r2, #20
  401bee:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  401bf0:	4618      	mov	r0, r3
  401bf2:	4b09      	ldr	r3, [pc, #36]	; (401c18 <SendIdenifierReport+0x78>)
  401bf4:	4798      	blx	r3
	Message_t IDMessage;
	IDMessage.buf = tmpRtn;
  401bf6:	f107 0318 	add.w	r3, r7, #24
  401bfa:	613b      	str	r3, [r7, #16]
	IDMessage.Size = 20;
  401bfc:	2314      	movs	r3, #20
  401bfe:	82bb      	strh	r3, [r7, #20]
	WriteMessage(&IDMessage);
  401c00:	f107 0310 	add.w	r3, r7, #16
  401c04:	4618      	mov	r0, r3
  401c06:	4b05      	ldr	r3, [pc, #20]	; (401c1c <SendIdenifierReport+0x7c>)
  401c08:	4798      	blx	r3
}
  401c0a:	3730      	adds	r7, #48	; 0x30
  401c0c:	46bd      	mov	sp, r7
  401c0e:	bd80      	pop	{r7, pc}
  401c10:	004013d9 	.word	0x004013d9
  401c14:	00401631 	.word	0x00401631
  401c18:	0040a635 	.word	0x0040a635
  401c1c:	00401a3d 	.word	0x00401a3d

00401c20 <SetCommunicationMode>:

//Changes the communication mode
void SetCommunicationMode(Message_t *message)
{
  401c20:	b580      	push	{r7, lr}
  401c22:	b086      	sub	sp, #24
  401c24:	af00      	add	r7, sp, #0
  401c26:	6078      	str	r0, [r7, #4]
	Error_T InvalidLengthByteError;	
	switch(message->buf[2])
  401c28:	687b      	ldr	r3, [r7, #4]
  401c2a:	681b      	ldr	r3, [r3, #0]
  401c2c:	3302      	adds	r3, #2
  401c2e:	781b      	ldrb	r3, [r3, #0]
  401c30:	2b00      	cmp	r3, #0
  401c32:	d002      	beq.n	401c3a <SetCommunicationMode+0x1a>
  401c34:	2b01      	cmp	r3, #1
  401c36:	d004      	beq.n	401c42 <SetCommunicationMode+0x22>
  401c38:	e007      	b.n	401c4a <SetCommunicationMode+0x2a>
	{
		case PC_COM_MODE_USB:
			SystemConfiguration.pc_com_mode = PC_COM_MODE_USB;
  401c3a:	4b0e      	ldr	r3, [pc, #56]	; (401c74 <SetCommunicationMode+0x54>)
  401c3c:	2200      	movs	r2, #0
  401c3e:	701a      	strb	r2, [r3, #0]
		break;
  401c40:	e010      	b.n	401c64 <SetCommunicationMode+0x44>
		
		case PC_COM_MODE_BLUETOOTH:
			SystemConfiguration.pc_com_mode = PC_COM_MODE_BLUETOOTH;		
  401c42:	4b0c      	ldr	r3, [pc, #48]	; (401c74 <SetCommunicationMode+0x54>)
  401c44:	2201      	movs	r2, #1
  401c46:	701a      	strb	r2, [r3, #0]
		break;
  401c48:	e00c      	b.n	401c64 <SetCommunicationMode+0x44>
		break;
#endif

		default:
		//Thats awkward. . .I would have no way to talk to the world! :'(
			InvalidLengthByteError.ThrowerID = SET_TX_MODE;
  401c4a:	23fd      	movs	r3, #253	; 0xfd
  401c4c:	60fb      	str	r3, [r7, #12]
			InvalidLengthByteError.ErrorMajor = INVALID_PC_COM_MODE_EXCEPTION;
  401c4e:	2306      	movs	r3, #6
  401c50:	613b      	str	r3, [r7, #16]
			InvalidLengthByteError.ErrorMinor = SystemConfiguration.pc_com_mode;
  401c52:	4b08      	ldr	r3, [pc, #32]	; (401c74 <SetCommunicationMode+0x54>)
  401c54:	781b      	ldrb	r3, [r3, #0]
  401c56:	617b      	str	r3, [r7, #20]
			ThrowError(&InvalidLengthByteError);
  401c58:	f107 030c 	add.w	r3, r7, #12
  401c5c:	4618      	mov	r0, r3
  401c5e:	4b06      	ldr	r3, [pc, #24]	; (401c78 <SetCommunicationMode+0x58>)
  401c60:	4798      	blx	r3
		break;
  401c62:	bf00      	nop
	}
	SendStatusReport(SET_TX_MODE);
  401c64:	20fd      	movs	r0, #253	; 0xfd
  401c66:	4b05      	ldr	r3, [pc, #20]	; (401c7c <SetCommunicationMode+0x5c>)
  401c68:	4798      	blx	r3
}
  401c6a:	bf00      	nop
  401c6c:	3718      	adds	r7, #24
  401c6e:	46bd      	mov	sp, r7
  401c70:	bd80      	pop	{r7, pc}
  401c72:	bf00      	nop
  401c74:	20000a28 	.word	0x20000a28
  401c78:	00401631 	.word	0x00401631
  401c7c:	00401b15 	.word	0x00401b15

00401c80 <SetInterfaceMode>:
//Changes the interface mode (Vehicle bus)
void SetInterfaceMode(Message_t *message)
{
  401c80:	b590      	push	{r4, r7, lr}
  401c82:	b087      	sub	sp, #28
  401c84:	af00      	add	r7, sp, #0
  401c86:	6078      	str	r0, [r7, #4]
	Error_T InvalidInterfaceModeError;	
	switch(message->buf[1])
  401c88:	687b      	ldr	r3, [r7, #4]
  401c8a:	681b      	ldr	r3, [r3, #0]
  401c8c:	3301      	adds	r3, #1
  401c8e:	781b      	ldrb	r3, [r3, #0]
  401c90:	2b02      	cmp	r3, #2
  401c92:	d010      	beq.n	401cb6 <SetInterfaceMode+0x36>
  401c94:	2bff      	cmp	r3, #255	; 0xff
  401c96:	d024      	beq.n	401ce2 <SetInterfaceMode+0x62>
  401c98:	2b00      	cmp	r3, #0
  401c9a:	d12d      	bne.n	401cf8 <SetInterfaceMode+0x78>
	{
		case VPW_MODE:
			//shutdownCAN();
			VPWEnable();
  401c9c:	4b20      	ldr	r3, [pc, #128]	; (401d20 <SetInterfaceMode+0xa0>)
  401c9e:	4798      	blx	r3
			ui_vehicle_enable_vpw();
  401ca0:	4b20      	ldr	r3, [pc, #128]	; (401d24 <SetInterfaceMode+0xa4>)
  401ca2:	4798      	blx	r3
			ui_vehicle_disable_can();
  401ca4:	4b20      	ldr	r3, [pc, #128]	; (401d28 <SetInterfaceMode+0xa8>)
  401ca6:	4798      	blx	r3
			SystemConfiguration.vehicle_com_mode = VPW_MODE;
  401ca8:	4b20      	ldr	r3, [pc, #128]	; (401d2c <SetInterfaceMode+0xac>)
  401caa:	2200      	movs	r2, #0
  401cac:	705a      	strb	r2, [r3, #1]
			WriteLine("System Mode...VPW");
  401cae:	4820      	ldr	r0, [pc, #128]	; (401d30 <SetInterfaceMode+0xb0>)
  401cb0:	4b20      	ldr	r3, [pc, #128]	; (401d34 <SetInterfaceMode+0xb4>)
  401cb2:	4798      	blx	r3
		break;
  401cb4:	e02d      	b.n	401d12 <SetInterfaceMode+0x92>

		case CAN_MODE:
			SystemConfiguration.vehicle_com_mode = CAN_MODE;
  401cb6:	4b1d      	ldr	r3, [pc, #116]	; (401d2c <SetInterfaceMode+0xac>)
  401cb8:	2202      	movs	r2, #2
  401cba:	705a      	strb	r2, [r3, #1]
			//TODO: ERROR HANLDING ON BAUD
			InitalizeCanSystem(message->buf[2], sysclk_get_cpu_hz());
  401cbc:	687b      	ldr	r3, [r7, #4]
  401cbe:	681b      	ldr	r3, [r3, #0]
  401cc0:	3302      	adds	r3, #2
  401cc2:	781c      	ldrb	r4, [r3, #0]
  401cc4:	4b1c      	ldr	r3, [pc, #112]	; (401d38 <SetInterfaceMode+0xb8>)
  401cc6:	4798      	blx	r3
  401cc8:	4603      	mov	r3, r0
  401cca:	4619      	mov	r1, r3
  401ccc:	4620      	mov	r0, r4
  401cce:	4b1b      	ldr	r3, [pc, #108]	; (401d3c <SetInterfaceMode+0xbc>)
  401cd0:	4798      	blx	r3
			ui_vehicle_enable_can();
  401cd2:	4b1b      	ldr	r3, [pc, #108]	; (401d40 <SetInterfaceMode+0xc0>)
  401cd4:	4798      	blx	r3
			ui_vehicle_disable_vpw();
  401cd6:	4b1b      	ldr	r3, [pc, #108]	; (401d44 <SetInterfaceMode+0xc4>)
  401cd8:	4798      	blx	r3
			WriteLine("System Mode...HSCAN");
  401cda:	481b      	ldr	r0, [pc, #108]	; (401d48 <SetInterfaceMode+0xc8>)
  401cdc:	4b15      	ldr	r3, [pc, #84]	; (401d34 <SetInterfaceMode+0xb4>)
  401cde:	4798      	blx	r3
	break;
  401ce0:	e017      	b.n	401d12 <SetInterfaceMode+0x92>
		
		case NONE:
			VPWDisable();
  401ce2:	4b1a      	ldr	r3, [pc, #104]	; (401d4c <SetInterfaceMode+0xcc>)
  401ce4:	4798      	blx	r3
			ui_vehicle_disable_can();
  401ce6:	4b10      	ldr	r3, [pc, #64]	; (401d28 <SetInterfaceMode+0xa8>)
  401ce8:	4798      	blx	r3
			SystemConfiguration.vehicle_com_mode = NONE;
  401cea:	4b10      	ldr	r3, [pc, #64]	; (401d2c <SetInterfaceMode+0xac>)
  401cec:	22ff      	movs	r2, #255	; 0xff
  401cee:	705a      	strb	r2, [r3, #1]
			WriteLine("System Mode...NONE");
  401cf0:	4817      	ldr	r0, [pc, #92]	; (401d50 <SetInterfaceMode+0xd0>)
  401cf2:	4b10      	ldr	r3, [pc, #64]	; (401d34 <SetInterfaceMode+0xb4>)
  401cf4:	4798      	blx	r3
		break;
  401cf6:	e00c      	b.n	401d12 <SetInterfaceMode+0x92>

		default:
			InvalidInterfaceModeError.ThrowerID = SET_INTERFACE_MODE;
  401cf8:	23a0      	movs	r3, #160	; 0xa0
  401cfa:	60fb      	str	r3, [r7, #12]
			InvalidInterfaceModeError.ErrorMajor = INVALID_INTERFACE_MODE_EXCEPTION;
  401cfc:	2308      	movs	r3, #8
  401cfe:	613b      	str	r3, [r7, #16]
			InvalidInterfaceModeError.ErrorMinor = SystemConfiguration.pc_com_mode;
  401d00:	4b0a      	ldr	r3, [pc, #40]	; (401d2c <SetInterfaceMode+0xac>)
  401d02:	781b      	ldrb	r3, [r3, #0]
  401d04:	617b      	str	r3, [r7, #20]
			ThrowError(&InvalidInterfaceModeError);
  401d06:	f107 030c 	add.w	r3, r7, #12
  401d0a:	4618      	mov	r0, r3
  401d0c:	4b11      	ldr	r3, [pc, #68]	; (401d54 <SetInterfaceMode+0xd4>)
  401d0e:	4798      	blx	r3
		break;
  401d10:	bf00      	nop
	}
	
	SendStatusReport(SET_INTERFACE_MODE);
  401d12:	20a0      	movs	r0, #160	; 0xa0
  401d14:	4b10      	ldr	r3, [pc, #64]	; (401d58 <SetInterfaceMode+0xd8>)
  401d16:	4798      	blx	r3
}
  401d18:	bf00      	nop
  401d1a:	371c      	adds	r7, #28
  401d1c:	46bd      	mov	sp, r7
  401d1e:	bd90      	pop	{r4, r7, pc}
  401d20:	00403055 	.word	0x00403055
  401d24:	00401f41 	.word	0x00401f41
  401d28:	00401fb9 	.word	0x00401fb9
  401d2c:	20000a28 	.word	0x20000a28
  401d30:	0040ac60 	.word	0x0040ac60
  401d34:	0040134b 	.word	0x0040134b
  401d38:	0040170d 	.word	0x0040170d
  401d3c:	00402521 	.word	0x00402521
  401d40:	00401fa5 	.word	0x00401fa5
  401d44:	00401f55 	.word	0x00401f55
  401d48:	0040ac74 	.word	0x0040ac74
  401d4c:	00403111 	.word	0x00403111
  401d50:	0040ac88 	.word	0x0040ac88
  401d54:	00401631 	.word	0x00401631
  401d58:	00401b15 	.word	0x00401b15

00401d5c <EnterBootloader>:
//Sets the boot flags to boot from ROM (Bootloader) for firmware update using SAM-BA (See Datasheet/SAM-BA documentation)
void EnterBootloader()
{
  401d5c:	b480      	push	{r7}
  401d5e:	b083      	sub	sp, #12
  401d60:	af00      	add	r7, sp, #0
	while( ((EFC->EEFC_FSR) & EEFC_FSR_FRDY) == 0)
  401d62:	bf00      	nop
  401d64:	4b0d      	ldr	r3, [pc, #52]	; (401d9c <EnterBootloader+0x40>)
  401d66:	689b      	ldr	r3, [r3, #8]
  401d68:	f003 0301 	and.w	r3, r3, #1
  401d6c:	2b00      	cmp	r3, #0
  401d6e:	d0f9      	beq.n	401d64 <EnterBootloader+0x8>
	{
		//Wait for Flash Ready
	}
	//Boot to bootloader on reset
	uint32_t Fcommand = (0x5A << 24) | 0x010C;
  401d70:	4b0b      	ldr	r3, [pc, #44]	; (401da0 <EnterBootloader+0x44>)
  401d72:	607b      	str	r3, [r7, #4]
	EFC->EEFC_FCR = Fcommand;
  401d74:	4a09      	ldr	r2, [pc, #36]	; (401d9c <EnterBootloader+0x40>)
  401d76:	687b      	ldr	r3, [r7, #4]
  401d78:	6053      	str	r3, [r2, #4]
	while( ((EFC->EEFC_FSR) & EEFC_FSR_FRDY) == 0)
  401d7a:	bf00      	nop
  401d7c:	4b07      	ldr	r3, [pc, #28]	; (401d9c <EnterBootloader+0x40>)
  401d7e:	689b      	ldr	r3, [r3, #8]
  401d80:	f003 0301 	and.w	r3, r3, #1
  401d84:	2b00      	cmp	r3, #0
  401d86:	d0f9      	beq.n	401d7c <EnterBootloader+0x20>
	{
		//Wait for Flash Ready
	}
	//Reset!
	RSTC->RSTC_CR = (0xA5 << 24) | RSTC_CR_PERRST | RSTC_CR_PROCRST;
  401d88:	4b06      	ldr	r3, [pc, #24]	; (401da4 <EnterBootloader+0x48>)
  401d8a:	4a07      	ldr	r2, [pc, #28]	; (401da8 <EnterBootloader+0x4c>)
  401d8c:	601a      	str	r2, [r3, #0]
  401d8e:	bf00      	nop
  401d90:	370c      	adds	r7, #12
  401d92:	46bd      	mov	sp, r7
  401d94:	f85d 7b04 	ldr.w	r7, [sp], #4
  401d98:	4770      	bx	lr
  401d9a:	bf00      	nop
  401d9c:	400e0a00 	.word	0x400e0a00
  401da0:	5a00010c 	.word	0x5a00010c
  401da4:	400e1800 	.word	0x400e1800
  401da8:	a5000005 	.word	0xa5000005

00401dac <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  401dac:	b480      	push	{r7}
  401dae:	b08b      	sub	sp, #44	; 0x2c
  401db0:	af00      	add	r7, sp, #0
  401db2:	6078      	str	r0, [r7, #4]
  401db4:	460b      	mov	r3, r1
  401db6:	70fb      	strb	r3, [r7, #3]
  401db8:	687b      	ldr	r3, [r7, #4]
  401dba:	627b      	str	r3, [r7, #36]	; 0x24
  401dbc:	78fb      	ldrb	r3, [r7, #3]
  401dbe:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401dc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401dc4:	61fb      	str	r3, [r7, #28]
  401dc6:	69fb      	ldr	r3, [r7, #28]
  401dc8:	61bb      	str	r3, [r7, #24]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  401dca:	69bb      	ldr	r3, [r7, #24]
  401dcc:	095b      	lsrs	r3, r3, #5
  401dce:	617b      	str	r3, [r7, #20]
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401dd0:	697b      	ldr	r3, [r7, #20]
  401dd2:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401dd6:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401dda:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401ddc:	613b      	str	r3, [r7, #16]

	if (level) {
  401dde:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  401de2:	2b00      	cmp	r3, #0
  401de4:	d009      	beq.n	401dfa <ioport_set_pin_level+0x4e>
  401de6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401de8:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401dea:	68fb      	ldr	r3, [r7, #12]
  401dec:	f003 031f 	and.w	r3, r3, #31
  401df0:	2201      	movs	r2, #1
  401df2:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401df4:	693b      	ldr	r3, [r7, #16]
  401df6:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  401df8:	e008      	b.n	401e0c <ioport_set_pin_level+0x60>
  401dfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401dfc:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  401dfe:	68bb      	ldr	r3, [r7, #8]
  401e00:	f003 031f 	and.w	r3, r3, #31
  401e04:	2201      	movs	r2, #1
  401e06:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401e08:	693b      	ldr	r3, [r7, #16]
  401e0a:	635a      	str	r2, [r3, #52]	; 0x34
  401e0c:	bf00      	nop
  401e0e:	372c      	adds	r7, #44	; 0x2c
  401e10:	46bd      	mov	sp, r7
  401e12:	f85d 7b04 	ldr.w	r7, [sp], #4
  401e16:	4770      	bx	lr

00401e18 <ioport_toggle_pin_level>:
 * an output.
 *
 * \param pin IOPORT pin to toggle
 */
static inline void ioport_toggle_pin_level(ioport_pin_t pin)
{
  401e18:	b480      	push	{r7}
  401e1a:	b08b      	sub	sp, #44	; 0x2c
  401e1c:	af00      	add	r7, sp, #0
  401e1e:	6078      	str	r0, [r7, #4]
  401e20:	687b      	ldr	r3, [r7, #4]
  401e22:	627b      	str	r3, [r7, #36]	; 0x24
  401e24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401e26:	623b      	str	r3, [r7, #32]
  401e28:	6a3b      	ldr	r3, [r7, #32]
  401e2a:	61fb      	str	r3, [r7, #28]
	return pin >> 5;
  401e2c:	69fb      	ldr	r3, [r7, #28]
  401e2e:	095b      	lsrs	r3, r3, #5
  401e30:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401e32:	69bb      	ldr	r3, [r7, #24]
  401e34:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401e38:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401e3c:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(port)->PIO_PDSR & mask;
}

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
  401e3e:	617b      	str	r3, [r7, #20]
  401e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401e42:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  401e44:	693b      	ldr	r3, [r7, #16]
  401e46:	f003 031f 	and.w	r3, r3, #31
  401e4a:	2201      	movs	r2, #1
  401e4c:	fa02 f303 	lsl.w	r3, r2, r3
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);
  401e50:	60fb      	str	r3, [r7, #12]

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  401e52:	697b      	ldr	r3, [r7, #20]
  401e54:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  401e56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401e58:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  401e5a:	68bb      	ldr	r3, [r7, #8]
  401e5c:	f003 031f 	and.w	r3, r3, #31
  401e60:	2101      	movs	r1, #1
  401e62:	fa01 f303 	lsl.w	r3, r1, r3
	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  401e66:	4013      	ands	r3, r2
  401e68:	2b00      	cmp	r3, #0
  401e6a:	d003      	beq.n	401e74 <ioport_toggle_pin_level+0x5c>
		port->PIO_CODR = mask;
  401e6c:	697b      	ldr	r3, [r7, #20]
  401e6e:	68fa      	ldr	r2, [r7, #12]
  401e70:	635a      	str	r2, [r3, #52]	; 0x34
	arch_ioport_toggle_pin_level(pin);
}
  401e72:	e002      	b.n	401e7a <ioport_toggle_pin_level+0x62>
	} else {
		port->PIO_SODR = mask;
  401e74:	697b      	ldr	r3, [r7, #20]
  401e76:	68fa      	ldr	r2, [r7, #12]
  401e78:	631a      	str	r2, [r3, #48]	; 0x30
  401e7a:	bf00      	nop
  401e7c:	372c      	adds	r7, #44	; 0x2c
  401e7e:	46bd      	mov	sp, r7
  401e80:	f85d 7b04 	ldr.w	r7, [sp], #4
  401e84:	4770      	bx	lr
	...

00401e88 <ui_init>:
#include <asf.h>
#include "ui.h"

//This file just contains the code which sets the LED colors. It is self-explainitory 
void ui_init(void)
{
  401e88:	b580      	push	{r7, lr}
  401e8a:	af00      	add	r7, sp, #0
	/* Initialize LEDs */
	LED_Off(PC_LED_RED);
  401e8c:	2101      	movs	r1, #1
  401e8e:	2000      	movs	r0, #0
  401e90:	4b11      	ldr	r3, [pc, #68]	; (401ed8 <ui_init+0x50>)
  401e92:	4798      	blx	r3
	LED_Off(PC_LED_GREEN);
  401e94:	2101      	movs	r1, #1
  401e96:	206f      	movs	r0, #111	; 0x6f
  401e98:	4b0f      	ldr	r3, [pc, #60]	; (401ed8 <ui_init+0x50>)
  401e9a:	4798      	blx	r3
	LED_Off(PC_LED_BLUE);
  401e9c:	2101      	movs	r1, #1
  401e9e:	207d      	movs	r0, #125	; 0x7d
  401ea0:	4b0d      	ldr	r3, [pc, #52]	; (401ed8 <ui_init+0x50>)
  401ea2:	4798      	blx	r3
	
	LED_On(POWER_LED_RED);
  401ea4:	2100      	movs	r1, #0
  401ea6:	2065      	movs	r0, #101	; 0x65
  401ea8:	4b0b      	ldr	r3, [pc, #44]	; (401ed8 <ui_init+0x50>)
  401eaa:	4798      	blx	r3
	LED_Off(POWER_LED_GREEN);
  401eac:	2101      	movs	r1, #1
  401eae:	2064      	movs	r0, #100	; 0x64
  401eb0:	4b09      	ldr	r3, [pc, #36]	; (401ed8 <ui_init+0x50>)
  401eb2:	4798      	blx	r3
	LED_Off(POWER_LED_BLUE);
  401eb4:	2101      	movs	r1, #1
  401eb6:	2063      	movs	r0, #99	; 0x63
  401eb8:	4b07      	ldr	r3, [pc, #28]	; (401ed8 <ui_init+0x50>)
  401eba:	4798      	blx	r3
	
	LED_Off(VEHICLE_LED_RED);
  401ebc:	2101      	movs	r1, #1
  401ebe:	206b      	movs	r0, #107	; 0x6b
  401ec0:	4b05      	ldr	r3, [pc, #20]	; (401ed8 <ui_init+0x50>)
  401ec2:	4798      	blx	r3
	LED_Off(VEHICLE_LED_GREEN);
  401ec4:	2101      	movs	r1, #1
  401ec6:	2001      	movs	r0, #1
  401ec8:	4b03      	ldr	r3, [pc, #12]	; (401ed8 <ui_init+0x50>)
  401eca:	4798      	blx	r3
	LED_Off(VEHICLE_LED_BLUE);
  401ecc:	2101      	movs	r1, #1
  401ece:	206a      	movs	r0, #106	; 0x6a
  401ed0:	4b01      	ldr	r3, [pc, #4]	; (401ed8 <ui_init+0x50>)
  401ed2:	4798      	blx	r3
}
  401ed4:	bf00      	nop
  401ed6:	bd80      	pop	{r7, pc}
  401ed8:	00401dad 	.word	0x00401dad

00401edc <ui_com_rx_start>:
	UNUSED(port);
	LED_Off(PC_LED_GREEN);
}

void ui_com_rx_start(void)
{
  401edc:	b580      	push	{r7, lr}
  401ede:	af00      	add	r7, sp, #0
	LED_On(PC_LED_BLUE);
  401ee0:	2100      	movs	r1, #0
  401ee2:	207d      	movs	r0, #125	; 0x7d
  401ee4:	4b01      	ldr	r3, [pc, #4]	; (401eec <ui_com_rx_start+0x10>)
  401ee6:	4798      	blx	r3
}
  401ee8:	bf00      	nop
  401eea:	bd80      	pop	{r7, pc}
  401eec:	00401dad 	.word	0x00401dad

00401ef0 <ui_com_rx_stop>:

void ui_com_rx_stop(void)
{
  401ef0:	b580      	push	{r7, lr}
  401ef2:	af00      	add	r7, sp, #0
	LED_Off(PC_LED_BLUE);
  401ef4:	2101      	movs	r1, #1
  401ef6:	207d      	movs	r0, #125	; 0x7d
  401ef8:	4b01      	ldr	r3, [pc, #4]	; (401f00 <ui_com_rx_stop+0x10>)
  401efa:	4798      	blx	r3
}
  401efc:	bf00      	nop
  401efe:	bd80      	pop	{r7, pc}
  401f00:	00401dad 	.word	0x00401dad

00401f04 <ui_com_tx_start>:

void ui_com_tx_start(void)
{
  401f04:	b580      	push	{r7, lr}
  401f06:	af00      	add	r7, sp, #0
	LED_On(PC_LED_RED);
  401f08:	2100      	movs	r1, #0
  401f0a:	2000      	movs	r0, #0
  401f0c:	4b01      	ldr	r3, [pc, #4]	; (401f14 <ui_com_tx_start+0x10>)
  401f0e:	4798      	blx	r3
	
}
  401f10:	bf00      	nop
  401f12:	bd80      	pop	{r7, pc}
  401f14:	00401dad 	.word	0x00401dad

00401f18 <ui_com_tx_stop>:

void ui_com_tx_stop(void)
{
  401f18:	b580      	push	{r7, lr}
  401f1a:	af00      	add	r7, sp, #0
	LED_Off(PC_LED_RED);
  401f1c:	2101      	movs	r1, #1
  401f1e:	2000      	movs	r0, #0
  401f20:	4b01      	ldr	r3, [pc, #4]	; (401f28 <ui_com_tx_stop+0x10>)
  401f22:	4798      	blx	r3
	
}
  401f24:	bf00      	nop
  401f26:	bd80      	pop	{r7, pc}
  401f28:	00401dad 	.word	0x00401dad

00401f2c <ui_power_good>:
		LED_Off(PC_LED_BLUE);
	}
}

void ui_power_good()
{
  401f2c:	b580      	push	{r7, lr}
  401f2e:	af00      	add	r7, sp, #0
	LED_On(POWER_LED_RED);
  401f30:	2100      	movs	r1, #0
  401f32:	2065      	movs	r0, #101	; 0x65
  401f34:	4b01      	ldr	r3, [pc, #4]	; (401f3c <ui_power_good+0x10>)
  401f36:	4798      	blx	r3
}
  401f38:	bf00      	nop
  401f3a:	bd80      	pop	{r7, pc}
  401f3c:	00401dad 	.word	0x00401dad

00401f40 <ui_vehicle_enable_vpw>:

void ui_vehicle_enable_vpw()
{
  401f40:	b580      	push	{r7, lr}
  401f42:	af00      	add	r7, sp, #0
	LED_On(VEHICLE_LED_BLUE);
  401f44:	2100      	movs	r1, #0
  401f46:	206a      	movs	r0, #106	; 0x6a
  401f48:	4b01      	ldr	r3, [pc, #4]	; (401f50 <ui_vehicle_enable_vpw+0x10>)
  401f4a:	4798      	blx	r3
}
  401f4c:	bf00      	nop
  401f4e:	bd80      	pop	{r7, pc}
  401f50:	00401dad 	.word	0x00401dad

00401f54 <ui_vehicle_disable_vpw>:

void ui_vehicle_disable_vpw()
{
  401f54:	b580      	push	{r7, lr}
  401f56:	af00      	add	r7, sp, #0
	LED_Off(VEHICLE_LED_BLUE);
  401f58:	2101      	movs	r1, #1
  401f5a:	206a      	movs	r0, #106	; 0x6a
  401f5c:	4b01      	ldr	r3, [pc, #4]	; (401f64 <ui_vehicle_disable_vpw+0x10>)
  401f5e:	4798      	blx	r3
}
  401f60:	bf00      	nop
  401f62:	bd80      	pop	{r7, pc}
  401f64:	00401dad 	.word	0x00401dad

00401f68 <ui_vehicle_vpw_tx_notify>:

void ui_vehicle_vpw_tx_notify()
{
  401f68:	b580      	push	{r7, lr}
  401f6a:	af00      	add	r7, sp, #0
	LED_Toggle(VEHICLE_LED_RED);
  401f6c:	206b      	movs	r0, #107	; 0x6b
  401f6e:	4b02      	ldr	r3, [pc, #8]	; (401f78 <ui_vehicle_vpw_tx_notify+0x10>)
  401f70:	4798      	blx	r3
}
  401f72:	bf00      	nop
  401f74:	bd80      	pop	{r7, pc}
  401f76:	bf00      	nop
  401f78:	00401e19 	.word	0x00401e19

00401f7c <ui_vehicle_vpw_rx_notify_off>:
{
	LED_Toggle(VEHICLE_LED_GREEN);
}

void ui_vehicle_vpw_rx_notify_off()
{
  401f7c:	b580      	push	{r7, lr}
  401f7e:	af00      	add	r7, sp, #0
	LED_Off(VEHICLE_LED_GREEN);
  401f80:	2101      	movs	r1, #1
  401f82:	2001      	movs	r0, #1
  401f84:	4b01      	ldr	r3, [pc, #4]	; (401f8c <ui_vehicle_vpw_rx_notify_off+0x10>)
  401f86:	4798      	blx	r3
}
  401f88:	bf00      	nop
  401f8a:	bd80      	pop	{r7, pc}
  401f8c:	00401dad 	.word	0x00401dad

00401f90 <ui_vehicle_vpw_tx_notify_off>:

void ui_vehicle_vpw_tx_notify_off()
{
  401f90:	b580      	push	{r7, lr}
  401f92:	af00      	add	r7, sp, #0
	LED_Off(VEHICLE_LED_RED);	
  401f94:	2101      	movs	r1, #1
  401f96:	206b      	movs	r0, #107	; 0x6b
  401f98:	4b01      	ldr	r3, [pc, #4]	; (401fa0 <ui_vehicle_vpw_tx_notify_off+0x10>)
  401f9a:	4798      	blx	r3
}
  401f9c:	bf00      	nop
  401f9e:	bd80      	pop	{r7, pc}
  401fa0:	00401dad 	.word	0x00401dad

00401fa4 <ui_vehicle_enable_can>:

void ui_vehicle_enable_can()
{
  401fa4:	b580      	push	{r7, lr}
  401fa6:	af00      	add	r7, sp, #0
	LED_On(VEHICLE_LED_GREEN);
  401fa8:	2100      	movs	r1, #0
  401faa:	2001      	movs	r0, #1
  401fac:	4b01      	ldr	r3, [pc, #4]	; (401fb4 <ui_vehicle_enable_can+0x10>)
  401fae:	4798      	blx	r3
}
  401fb0:	bf00      	nop
  401fb2:	bd80      	pop	{r7, pc}
  401fb4:	00401dad 	.word	0x00401dad

00401fb8 <ui_vehicle_disable_can>:

void ui_vehicle_disable_can()
{
  401fb8:	b580      	push	{r7, lr}
  401fba:	af00      	add	r7, sp, #0
	LED_Off(VEHICLE_LED_GREEN);
  401fbc:	2101      	movs	r1, #1
  401fbe:	2001      	movs	r0, #1
  401fc0:	4b01      	ldr	r3, [pc, #4]	; (401fc8 <ui_vehicle_disable_can+0x10>)
  401fc2:	4798      	blx	r3
  401fc4:	bf00      	nop
  401fc6:	bd80      	pop	{r7, pc}
  401fc8:	00401dad 	.word	0x00401dad

00401fcc <CreateFilter>:
 */ 
#include "CanFilter.h"

//Creates a filer and adds it to the filter list
bool CreateFilter(uint8_t FilterType, uint8_t * Mask, uint8_t* Pattern, uint8_t* FlowControlMessage ,uint16_t Length)
{
  401fcc:	b5b0      	push	{r4, r5, r7, lr}
  401fce:	b08c      	sub	sp, #48	; 0x30
  401fd0:	af00      	add	r7, sp, #0
  401fd2:	60b9      	str	r1, [r7, #8]
  401fd4:	607a      	str	r2, [r7, #4]
  401fd6:	603b      	str	r3, [r7, #0]
  401fd8:	4603      	mov	r3, r0
  401fda:	73fb      	strb	r3, [r7, #15]
	//Make sure we have room
	if(FilterCounter + 1 > MAX_FILTERS)
  401fdc:	4b33      	ldr	r3, [pc, #204]	; (4020ac <CreateFilter+0xe0>)
  401fde:	781b      	ldrb	r3, [r3, #0]
  401fe0:	3301      	adds	r3, #1
  401fe2:	2bfe      	cmp	r3, #254	; 0xfe
  401fe4:	dd0c      	ble.n	402000 <CreateFilter+0x34>
	{
		Error_T OutOfBoundsError;
		OutOfBoundsError.ThrowerID = THROWER_ID_COMMAND_RESPONSE_SYSTEM;
  401fe6:	2301      	movs	r3, #1
  401fe8:	613b      	str	r3, [r7, #16]
		OutOfBoundsError.ErrorMajor = MESSAGE_FILTER_INDEX_OUT_OF_BOUNDS;
  401fea:	2310      	movs	r3, #16
  401fec:	617b      	str	r3, [r7, #20]
		OutOfBoundsError.ErrorMinor = ERROR_NO_MINOR_CODE;
  401fee:	2300      	movs	r3, #0
  401ff0:	61bb      	str	r3, [r7, #24]
		ThrowError(&OutOfBoundsError);
  401ff2:	f107 0310 	add.w	r3, r7, #16
  401ff6:	4618      	mov	r0, r3
  401ff8:	4b2d      	ldr	r3, [pc, #180]	; (4020b0 <CreateFilter+0xe4>)
  401ffa:	4798      	blx	r3
		return;
  401ffc:	bf00      	nop
  401ffe:	e051      	b.n	4020a4 <CreateFilter+0xd8>
	}
	//Create and initialize the filter
	Filter_t tmpFilter;
	tmpFilter.Type = FilterType;
  402000:	7bfb      	ldrb	r3, [r7, #15]
  402002:	773b      	strb	r3, [r7, #28]
	tmpFilter.FilterMessageLength = Length;
  402004:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
  402008:	83fb      	strh	r3, [r7, #30]
	tmpFilter.MaskMessage = (uint8_t*) malloc(Length);
  40200a:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
  40200e:	4618      	mov	r0, r3
  402010:	4b28      	ldr	r3, [pc, #160]	; (4020b4 <CreateFilter+0xe8>)
  402012:	4798      	blx	r3
  402014:	4603      	mov	r3, r0
  402016:	623b      	str	r3, [r7, #32]
	tmpFilter.PatternMessage = (uint8_t*) malloc(Length);
  402018:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
  40201c:	4618      	mov	r0, r3
  40201e:	4b25      	ldr	r3, [pc, #148]	; (4020b4 <CreateFilter+0xe8>)
  402020:	4798      	blx	r3
  402022:	4603      	mov	r3, r0
  402024:	627b      	str	r3, [r7, #36]	; 0x24
	tmpFilter.FlowControlMessage = (uint8_t*) malloc(Length);
  402026:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
  40202a:	4618      	mov	r0, r3
  40202c:	4b21      	ldr	r3, [pc, #132]	; (4020b4 <CreateFilter+0xe8>)
  40202e:	4798      	blx	r3
  402030:	4603      	mov	r3, r0
  402032:	62bb      	str	r3, [r7, #40]	; 0x28
	//Out of memory error
	if(tmpFilter.MaskMessage == NULL || tmpFilter.PatternMessage == NULL || tmpFilter.FlowControlMessage == NULL)
  402034:	6a3b      	ldr	r3, [r7, #32]
  402036:	2b00      	cmp	r3, #0
  402038:	d005      	beq.n	402046 <CreateFilter+0x7a>
  40203a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40203c:	2b00      	cmp	r3, #0
  40203e:	d002      	beq.n	402046 <CreateFilter+0x7a>
  402040:	6abb      	ldr	r3, [r7, #40]	; 0x28
  402042:	2b00      	cmp	r3, #0
  402044:	d101      	bne.n	40204a <CreateFilter+0x7e>
	{
		//TODO: ERROR OOM
		return false;
  402046:	2300      	movs	r3, #0
  402048:	e02c      	b.n	4020a4 <CreateFilter+0xd8>
	}
	//Copy over filter data
	tmpFilter.FilterID = FilterCounter;
  40204a:	4b18      	ldr	r3, [pc, #96]	; (4020ac <CreateFilter+0xe0>)
  40204c:	781b      	ldrb	r3, [r3, #0]
  40204e:	62fb      	str	r3, [r7, #44]	; 0x2c
	memcpy(tmpFilter.MaskMessage, Mask, Length);
  402050:	6a3b      	ldr	r3, [r7, #32]
  402052:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
  402056:	68b9      	ldr	r1, [r7, #8]
  402058:	4618      	mov	r0, r3
  40205a:	4b17      	ldr	r3, [pc, #92]	; (4020b8 <CreateFilter+0xec>)
  40205c:	4798      	blx	r3
	memcpy(tmpFilter.PatternMessage, Pattern, Length);
  40205e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402060:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
  402064:	6879      	ldr	r1, [r7, #4]
  402066:	4618      	mov	r0, r3
  402068:	4b13      	ldr	r3, [pc, #76]	; (4020b8 <CreateFilter+0xec>)
  40206a:	4798      	blx	r3
	memcpy(tmpFilter.FlowControlMessage, FlowControlMessage, Length);
  40206c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40206e:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
  402072:	6839      	ldr	r1, [r7, #0]
  402074:	4618      	mov	r0, r3
  402076:	4b10      	ldr	r3, [pc, #64]	; (4020b8 <CreateFilter+0xec>)
  402078:	4798      	blx	r3
//Add it to the list
	Filters[FilterCounter++] = tmpFilter;
  40207a:	4b0c      	ldr	r3, [pc, #48]	; (4020ac <CreateFilter+0xe0>)
  40207c:	781b      	ldrb	r3, [r3, #0]
  40207e:	1c5a      	adds	r2, r3, #1
  402080:	b2d1      	uxtb	r1, r2
  402082:	4a0a      	ldr	r2, [pc, #40]	; (4020ac <CreateFilter+0xe0>)
  402084:	7011      	strb	r1, [r2, #0]
  402086:	4619      	mov	r1, r3
  402088:	4a0c      	ldr	r2, [pc, #48]	; (4020bc <CreateFilter+0xf0>)
  40208a:	460b      	mov	r3, r1
  40208c:	009b      	lsls	r3, r3, #2
  40208e:	440b      	add	r3, r1
  402090:	009b      	lsls	r3, r3, #2
  402092:	4413      	add	r3, r2
  402094:	461d      	mov	r5, r3
  402096:	f107 041c 	add.w	r4, r7, #28
  40209a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  40209c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  40209e:	6823      	ldr	r3, [r4, #0]
  4020a0:	602b      	str	r3, [r5, #0]

	return true;
  4020a2:	2301      	movs	r3, #1
}
  4020a4:	4618      	mov	r0, r3
  4020a6:	3730      	adds	r7, #48	; 0x30
  4020a8:	46bd      	mov	sp, r7
  4020aa:	bdb0      	pop	{r4, r5, r7, pc}
  4020ac:	20000170 	.word	0x20000170
  4020b0:	00401631 	.word	0x00401631
  4020b4:	0040a0b5 	.word	0x0040a0b5
  4020b8:	0040a635 	.word	0x0040a635
  4020bc:	20001dbc 	.word	0x20001dbc

004020c0 <DeleteAllFilters>:
	}
	
}
//Removes all the filters
void DeleteAllFilters()
{
  4020c0:	b580      	push	{r7, lr}
  4020c2:	b086      	sub	sp, #24
  4020c4:	af00      	add	r7, sp, #0
	int i;
	//Free all of the filter memory
	for(i = 0; i < FilterCounter; i++)
  4020c6:	2300      	movs	r3, #0
  4020c8:	617b      	str	r3, [r7, #20]
  4020ca:	e044      	b.n	402156 <DeleteAllFilters+0x96>
	{
		Filters[i].MaskMessage = NULL;
  4020cc:	4938      	ldr	r1, [pc, #224]	; (4021b0 <DeleteAllFilters+0xf0>)
  4020ce:	697a      	ldr	r2, [r7, #20]
  4020d0:	4613      	mov	r3, r2
  4020d2:	009b      	lsls	r3, r3, #2
  4020d4:	4413      	add	r3, r2
  4020d6:	009b      	lsls	r3, r3, #2
  4020d8:	440b      	add	r3, r1
  4020da:	3304      	adds	r3, #4
  4020dc:	2200      	movs	r2, #0
  4020de:	601a      	str	r2, [r3, #0]
		Filters[i].PatternMessage = NULL;
  4020e0:	4933      	ldr	r1, [pc, #204]	; (4021b0 <DeleteAllFilters+0xf0>)
  4020e2:	697a      	ldr	r2, [r7, #20]
  4020e4:	4613      	mov	r3, r2
  4020e6:	009b      	lsls	r3, r3, #2
  4020e8:	4413      	add	r3, r2
  4020ea:	009b      	lsls	r3, r3, #2
  4020ec:	440b      	add	r3, r1
  4020ee:	3308      	adds	r3, #8
  4020f0:	2200      	movs	r2, #0
  4020f2:	601a      	str	r2, [r3, #0]
		Filters[i].FlowControlMessage = NULL;
  4020f4:	492e      	ldr	r1, [pc, #184]	; (4021b0 <DeleteAllFilters+0xf0>)
  4020f6:	697a      	ldr	r2, [r7, #20]
  4020f8:	4613      	mov	r3, r2
  4020fa:	009b      	lsls	r3, r3, #2
  4020fc:	4413      	add	r3, r2
  4020fe:	009b      	lsls	r3, r3, #2
  402100:	440b      	add	r3, r1
  402102:	330c      	adds	r3, #12
  402104:	2200      	movs	r2, #0
  402106:	601a      	str	r2, [r3, #0]
		free(Filters[i].MaskMessage);
  402108:	4929      	ldr	r1, [pc, #164]	; (4021b0 <DeleteAllFilters+0xf0>)
  40210a:	697a      	ldr	r2, [r7, #20]
  40210c:	4613      	mov	r3, r2
  40210e:	009b      	lsls	r3, r3, #2
  402110:	4413      	add	r3, r2
  402112:	009b      	lsls	r3, r3, #2
  402114:	440b      	add	r3, r1
  402116:	3304      	adds	r3, #4
  402118:	681b      	ldr	r3, [r3, #0]
  40211a:	4618      	mov	r0, r3
  40211c:	4b25      	ldr	r3, [pc, #148]	; (4021b4 <DeleteAllFilters+0xf4>)
  40211e:	4798      	blx	r3
		free(Filters[i].PatternMessage);
  402120:	4923      	ldr	r1, [pc, #140]	; (4021b0 <DeleteAllFilters+0xf0>)
  402122:	697a      	ldr	r2, [r7, #20]
  402124:	4613      	mov	r3, r2
  402126:	009b      	lsls	r3, r3, #2
  402128:	4413      	add	r3, r2
  40212a:	009b      	lsls	r3, r3, #2
  40212c:	440b      	add	r3, r1
  40212e:	3308      	adds	r3, #8
  402130:	681b      	ldr	r3, [r3, #0]
  402132:	4618      	mov	r0, r3
  402134:	4b1f      	ldr	r3, [pc, #124]	; (4021b4 <DeleteAllFilters+0xf4>)
  402136:	4798      	blx	r3
		free(Filters[i].FlowControlMessage);	
  402138:	491d      	ldr	r1, [pc, #116]	; (4021b0 <DeleteAllFilters+0xf0>)
  40213a:	697a      	ldr	r2, [r7, #20]
  40213c:	4613      	mov	r3, r2
  40213e:	009b      	lsls	r3, r3, #2
  402140:	4413      	add	r3, r2
  402142:	009b      	lsls	r3, r3, #2
  402144:	440b      	add	r3, r1
  402146:	330c      	adds	r3, #12
  402148:	681b      	ldr	r3, [r3, #0]
  40214a:	4618      	mov	r0, r3
  40214c:	4b19      	ldr	r3, [pc, #100]	; (4021b4 <DeleteAllFilters+0xf4>)
  40214e:	4798      	blx	r3
	for(i = 0; i < FilterCounter; i++)
  402150:	697b      	ldr	r3, [r7, #20]
  402152:	3301      	adds	r3, #1
  402154:	617b      	str	r3, [r7, #20]
  402156:	4b18      	ldr	r3, [pc, #96]	; (4021b8 <DeleteAllFilters+0xf8>)
  402158:	781b      	ldrb	r3, [r3, #0]
  40215a:	461a      	mov	r2, r3
  40215c:	697b      	ldr	r3, [r7, #20]
  40215e:	429a      	cmp	r2, r3
  402160:	dcb4      	bgt.n	4020cc <DeleteAllFilters+0xc>
	}
	
	FilterCounter = 0;
  402162:	4b15      	ldr	r3, [pc, #84]	; (4021b8 <DeleteAllFilters+0xf8>)
  402164:	2200      	movs	r2, #0
  402166:	701a      	strb	r2, [r3, #0]
	rx_mailbox_num = 1;
  402168:	4b14      	ldr	r3, [pc, #80]	; (4021bc <DeleteAllFilters+0xfc>)
  40216a:	2201      	movs	r2, #1
  40216c:	601a      	str	r2, [r3, #0]
	can_disable_interrupt(SYSTEM_CAN, CAN_DISABLE_ALL_INTERRUPT_MASK);
  40216e:	f04f 31ff 	mov.w	r1, #4294967295
  402172:	4813      	ldr	r0, [pc, #76]	; (4021c0 <DeleteAllFilters+0x100>)
  402174:	4b13      	ldr	r3, [pc, #76]	; (4021c4 <DeleteAllFilters+0x104>)
  402176:	4798      	blx	r3
	can_enable_interrupt(SYSTEM_CAN, CAN_IER_ERRA | CAN_IER_WARN | CAN_IER_ERRP | CAN_IER_BOFF | CAN_IER_BERR);
  402178:	4913      	ldr	r1, [pc, #76]	; (4021c8 <DeleteAllFilters+0x108>)
  40217a:	4811      	ldr	r0, [pc, #68]	; (4021c0 <DeleteAllFilters+0x100>)
  40217c:	4b13      	ldr	r3, [pc, #76]	; (4021cc <DeleteAllFilters+0x10c>)
  40217e:	4798      	blx	r3
	can_reset_all_mailbox(SYSTEM_CAN);
  402180:	480f      	ldr	r0, [pc, #60]	; (4021c0 <DeleteAllFilters+0x100>)
  402182:	4b13      	ldr	r3, [pc, #76]	; (4021d0 <DeleteAllFilters+0x110>)
  402184:	4798      	blx	r3
	
	uint8_t DeleteFiltersSuccess[] = {START_BYTE, 0x00,0x02,DELETE_CAN_FILTER, 0x01};
  402186:	4a13      	ldr	r2, [pc, #76]	; (4021d4 <DeleteAllFilters+0x114>)
  402188:	f107 030c 	add.w	r3, r7, #12
  40218c:	e892 0003 	ldmia.w	r2, {r0, r1}
  402190:	6018      	str	r0, [r3, #0]
  402192:	3304      	adds	r3, #4
  402194:	7019      	strb	r1, [r3, #0]
	Message_t tmpMsg;
	tmpMsg.buf = DeleteFiltersSuccess;
  402196:	f107 030c 	add.w	r3, r7, #12
  40219a:	607b      	str	r3, [r7, #4]
	tmpMsg.Size = 5;
  40219c:	2305      	movs	r3, #5
  40219e:	813b      	strh	r3, [r7, #8]
	WriteMessage(&tmpMsg);
  4021a0:	1d3b      	adds	r3, r7, #4
  4021a2:	4618      	mov	r0, r3
  4021a4:	4b0c      	ldr	r3, [pc, #48]	; (4021d8 <DeleteAllFilters+0x118>)
  4021a6:	4798      	blx	r3
}
  4021a8:	bf00      	nop
  4021aa:	3718      	adds	r7, #24
  4021ac:	46bd      	mov	sp, r7
  4021ae:	bd80      	pop	{r7, pc}
  4021b0:	20001dbc 	.word	0x20001dbc
  4021b4:	0040a0c5 	.word	0x0040a0c5
  4021b8:	20000170 	.word	0x20000170
  4021bc:	20000174 	.word	0x20000174
  4021c0:	40010000 	.word	0x40010000
  4021c4:	00400ead 	.word	0x00400ead
  4021c8:	100f0000 	.word	0x100f0000
  4021cc:	00400e91 	.word	0x00400e91
  4021d0:	0040122d 	.word	0x0040122d
  4021d4:	0040ac9c 	.word	0x0040ac9c
  4021d8:	00401a3d 	.word	0x00401a3d

004021dc <RunFilters>:
	return true;	
}
//Runs the filters, returns the filter type. By doing this we simply the logic. A block filter type is 0 and if it matches it will return 0 which will
//cause the caller to ignore the message as intended.
int RunFilters(uint8_t * Message, uint16_t length, uint8_t** FlowControlMessage, uint8_t* FlowControlMessageLength)
{
  4021dc:	b580      	push	{r7, lr}
  4021de:	b088      	sub	sp, #32
  4021e0:	af00      	add	r7, sp, #0
  4021e2:	60f8      	str	r0, [r7, #12]
  4021e4:	607a      	str	r2, [r7, #4]
  4021e6:	603b      	str	r3, [r7, #0]
  4021e8:	460b      	mov	r3, r1
  4021ea:	817b      	strh	r3, [r7, #10]
	int i, j;	
	if(IsFilteringEnabled == false)
  4021ec:	4b40      	ldr	r3, [pc, #256]	; (4022f0 <RunFilters+0x114>)
  4021ee:	781b      	ldrb	r3, [r3, #0]
  4021f0:	f083 0301 	eor.w	r3, r3, #1
  4021f4:	b2db      	uxtb	r3, r3
  4021f6:	2b00      	cmp	r3, #0
  4021f8:	d004      	beq.n	402204 <RunFilters+0x28>
	{
		WriteLine("Filtering Disabled!");
  4021fa:	483e      	ldr	r0, [pc, #248]	; (4022f4 <RunFilters+0x118>)
  4021fc:	4b3e      	ldr	r3, [pc, #248]	; (4022f8 <RunFilters+0x11c>)
  4021fe:	4798      	blx	r3
		return true;
  402200:	2301      	movs	r3, #1
  402202:	e070      	b.n	4022e6 <RunFilters+0x10a>
	}
	
	WriteLine("Running Filter!");
  402204:	483d      	ldr	r0, [pc, #244]	; (4022fc <RunFilters+0x120>)
  402206:	4b3c      	ldr	r3, [pc, #240]	; (4022f8 <RunFilters+0x11c>)
  402208:	4798      	blx	r3
	
	for(i = 0; i < FilterCounter; i++)
  40220a:	2300      	movs	r3, #0
  40220c:	61fb      	str	r3, [r7, #28]
  40220e:	e063      	b.n	4022d8 <RunFilters+0xfc>
	{

		if(Filters[i].FilterMessageLength > length)
  402210:	493b      	ldr	r1, [pc, #236]	; (402300 <RunFilters+0x124>)
  402212:	69fa      	ldr	r2, [r7, #28]
  402214:	4613      	mov	r3, r2
  402216:	009b      	lsls	r3, r3, #2
  402218:	4413      	add	r3, r2
  40221a:	009b      	lsls	r3, r3, #2
  40221c:	440b      	add	r3, r1
  40221e:	3302      	adds	r3, #2
  402220:	881b      	ldrh	r3, [r3, #0]
  402222:	897a      	ldrh	r2, [r7, #10]
  402224:	429a      	cmp	r2, r3
  402226:	d353      	bcc.n	4022d0 <RunFilters+0xf4>
		{
			//WriteLine("Filter length greater than message length.");
			continue;	
		}
		for(j = 0; j < Filters[i].FilterMessageLength; j++)
  402228:	2300      	movs	r3, #0
  40222a:	61bb      	str	r3, [r7, #24]
  40222c:	e029      	b.n	402282 <RunFilters+0xa6>
			//WriteChar(0x0A);
			//
			//WriteString("Pattern Message: ");
			//WriteCharArr(Filters[i].PatternMessage, Filters[i].FilterMessageLength);
			//WriteChar(0x0A);
			char t1 = Message[j];
  40222e:	69bb      	ldr	r3, [r7, #24]
  402230:	68fa      	ldr	r2, [r7, #12]
  402232:	4413      	add	r3, r2
  402234:	781b      	ldrb	r3, [r3, #0]
  402236:	75fb      	strb	r3, [r7, #23]
			char t2 = Filters[i].MaskMessage[j];
  402238:	4931      	ldr	r1, [pc, #196]	; (402300 <RunFilters+0x124>)
  40223a:	69fa      	ldr	r2, [r7, #28]
  40223c:	4613      	mov	r3, r2
  40223e:	009b      	lsls	r3, r3, #2
  402240:	4413      	add	r3, r2
  402242:	009b      	lsls	r3, r3, #2
  402244:	440b      	add	r3, r1
  402246:	3304      	adds	r3, #4
  402248:	681a      	ldr	r2, [r3, #0]
  40224a:	69bb      	ldr	r3, [r7, #24]
  40224c:	4413      	add	r3, r2
  40224e:	781b      	ldrb	r3, [r3, #0]
  402250:	75bb      	strb	r3, [r7, #22]
			char t3 = Filters[i].PatternMessage[j];
  402252:	492b      	ldr	r1, [pc, #172]	; (402300 <RunFilters+0x124>)
  402254:	69fa      	ldr	r2, [r7, #28]
  402256:	4613      	mov	r3, r2
  402258:	009b      	lsls	r3, r3, #2
  40225a:	4413      	add	r3, r2
  40225c:	009b      	lsls	r3, r3, #2
  40225e:	440b      	add	r3, r1
  402260:	3308      	adds	r3, #8
  402262:	681a      	ldr	r2, [r3, #0]
  402264:	69bb      	ldr	r3, [r7, #24]
  402266:	4413      	add	r3, r2
  402268:	781b      	ldrb	r3, [r3, #0]
  40226a:	757b      	strb	r3, [r7, #21]
			char t4 = t1 & t2;
  40226c:	7dfa      	ldrb	r2, [r7, #23]
  40226e:	7dbb      	ldrb	r3, [r7, #22]
  402270:	4013      	ands	r3, r2
  402272:	753b      	strb	r3, [r7, #20]
			
			//if(Message[j] & Filters[i].MaskMessage[j] != Filters[i].PatternMessage[j])
			if(t4 != t3)
  402274:	7d3a      	ldrb	r2, [r7, #20]
  402276:	7d7b      	ldrb	r3, [r7, #21]
  402278:	429a      	cmp	r2, r3
  40227a:	d127      	bne.n	4022cc <RunFilters+0xf0>
		for(j = 0; j < Filters[i].FilterMessageLength; j++)
  40227c:	69bb      	ldr	r3, [r7, #24]
  40227e:	3301      	adds	r3, #1
  402280:	61bb      	str	r3, [r7, #24]
  402282:	491f      	ldr	r1, [pc, #124]	; (402300 <RunFilters+0x124>)
  402284:	69fa      	ldr	r2, [r7, #28]
  402286:	4613      	mov	r3, r2
  402288:	009b      	lsls	r3, r3, #2
  40228a:	4413      	add	r3, r2
  40228c:	009b      	lsls	r3, r3, #2
  40228e:	440b      	add	r3, r1
  402290:	3302      	adds	r3, #2
  402292:	881b      	ldrh	r3, [r3, #0]
  402294:	461a      	mov	r2, r3
  402296:	69bb      	ldr	r3, [r7, #24]
  402298:	429a      	cmp	r2, r3
  40229a:	dcc8      	bgt.n	40222e <RunFilters+0x52>
			}	
		}
		//WriteString("Display Message: ");
		//WriteChar(Filters[i].Type);
		//WriteChar(0x0A);
		*FlowControlMessage = Filters[i].FlowControlMessage;
  40229c:	4918      	ldr	r1, [pc, #96]	; (402300 <RunFilters+0x124>)
  40229e:	69fa      	ldr	r2, [r7, #28]
  4022a0:	4613      	mov	r3, r2
  4022a2:	009b      	lsls	r3, r3, #2
  4022a4:	4413      	add	r3, r2
  4022a6:	009b      	lsls	r3, r3, #2
  4022a8:	440b      	add	r3, r1
  4022aa:	330c      	adds	r3, #12
  4022ac:	681a      	ldr	r2, [r3, #0]
  4022ae:	687b      	ldr	r3, [r7, #4]
  4022b0:	601a      	str	r2, [r3, #0]
		*FlowControlMessageLength = length;
  4022b2:	897b      	ldrh	r3, [r7, #10]
  4022b4:	b2da      	uxtb	r2, r3
  4022b6:	683b      	ldr	r3, [r7, #0]
  4022b8:	701a      	strb	r2, [r3, #0]
		return Filters[i].Type;
  4022ba:	4911      	ldr	r1, [pc, #68]	; (402300 <RunFilters+0x124>)
  4022bc:	69fa      	ldr	r2, [r7, #28]
  4022be:	4613      	mov	r3, r2
  4022c0:	009b      	lsls	r3, r3, #2
  4022c2:	4413      	add	r3, r2
  4022c4:	009b      	lsls	r3, r3, #2
  4022c6:	440b      	add	r3, r1
  4022c8:	781b      	ldrb	r3, [r3, #0]
  4022ca:	e00c      	b.n	4022e6 <RunFilters+0x10a>
				goto Skip;
  4022cc:	bf00      	nop
		
		Skip:
		continue;
  4022ce:	e000      	b.n	4022d2 <RunFilters+0xf6>
			continue;	
  4022d0:	bf00      	nop
	for(i = 0; i < FilterCounter; i++)
  4022d2:	69fb      	ldr	r3, [r7, #28]
  4022d4:	3301      	adds	r3, #1
  4022d6:	61fb      	str	r3, [r7, #28]
  4022d8:	4b0a      	ldr	r3, [pc, #40]	; (402304 <RunFilters+0x128>)
  4022da:	781b      	ldrb	r3, [r3, #0]
  4022dc:	461a      	mov	r2, r3
  4022de:	69fb      	ldr	r3, [r7, #28]
  4022e0:	429a      	cmp	r2, r3
  4022e2:	dc95      	bgt.n	402210 <RunFilters+0x34>
	}
	//WriteLine("Dropping Message");
	return false;
  4022e4:	2300      	movs	r3, #0
}
  4022e6:	4618      	mov	r0, r3
  4022e8:	3720      	adds	r7, #32
  4022ea:	46bd      	mov	sp, r7
  4022ec:	bd80      	pop	{r7, pc}
  4022ee:	bf00      	nop
  4022f0:	20003194 	.word	0x20003194
  4022f4:	0040aca4 	.word	0x0040aca4
  4022f8:	0040134b 	.word	0x0040134b
  4022fc:	0040acb8 	.word	0x0040acb8
  402300:	20001dbc 	.word	0x20001dbc
  402304:	20000170 	.word	0x20000170

00402308 <NVIC_EnableIRQ>:
{
  402308:	b480      	push	{r7}
  40230a:	b083      	sub	sp, #12
  40230c:	af00      	add	r7, sp, #0
  40230e:	4603      	mov	r3, r0
  402310:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  402312:	4909      	ldr	r1, [pc, #36]	; (402338 <NVIC_EnableIRQ+0x30>)
  402314:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402318:	095b      	lsrs	r3, r3, #5
  40231a:	79fa      	ldrb	r2, [r7, #7]
  40231c:	f002 021f 	and.w	r2, r2, #31
  402320:	2001      	movs	r0, #1
  402322:	fa00 f202 	lsl.w	r2, r0, r2
  402326:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40232a:	bf00      	nop
  40232c:	370c      	adds	r7, #12
  40232e:	46bd      	mov	sp, r7
  402330:	f85d 7b04 	ldr.w	r7, [sp], #4
  402334:	4770      	bx	lr
  402336:	bf00      	nop
  402338:	e000e100 	.word	0xe000e100

0040233c <NVIC_DisableIRQ>:
{
  40233c:	b480      	push	{r7}
  40233e:	b083      	sub	sp, #12
  402340:	af00      	add	r7, sp, #0
  402342:	4603      	mov	r3, r0
  402344:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  402346:	4909      	ldr	r1, [pc, #36]	; (40236c <NVIC_DisableIRQ+0x30>)
  402348:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40234c:	095b      	lsrs	r3, r3, #5
  40234e:	79fa      	ldrb	r2, [r7, #7]
  402350:	f002 021f 	and.w	r2, r2, #31
  402354:	2001      	movs	r0, #1
  402356:	fa00 f202 	lsl.w	r2, r0, r2
  40235a:	3320      	adds	r3, #32
  40235c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402360:	bf00      	nop
  402362:	370c      	adds	r7, #12
  402364:	46bd      	mov	sp, r7
  402366:	f85d 7b04 	ldr.w	r7, [sp], #4
  40236a:	4770      	bx	lr
  40236c:	e000e100 	.word	0xe000e100

00402370 <NVIC_ClearPendingIRQ>:
{
  402370:	b480      	push	{r7}
  402372:	b083      	sub	sp, #12
  402374:	af00      	add	r7, sp, #0
  402376:	4603      	mov	r3, r0
  402378:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40237a:	4909      	ldr	r1, [pc, #36]	; (4023a0 <NVIC_ClearPendingIRQ+0x30>)
  40237c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402380:	095b      	lsrs	r3, r3, #5
  402382:	79fa      	ldrb	r2, [r7, #7]
  402384:	f002 021f 	and.w	r2, r2, #31
  402388:	2001      	movs	r0, #1
  40238a:	fa00 f202 	lsl.w	r2, r0, r2
  40238e:	3360      	adds	r3, #96	; 0x60
  402390:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402394:	bf00      	nop
  402396:	370c      	adds	r7, #12
  402398:	46bd      	mov	sp, r7
  40239a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40239e:	4770      	bx	lr
  4023a0:	e000e100 	.word	0xe000e100

004023a4 <NVIC_SetPriority>:
{
  4023a4:	b480      	push	{r7}
  4023a6:	b083      	sub	sp, #12
  4023a8:	af00      	add	r7, sp, #0
  4023aa:	4603      	mov	r3, r0
  4023ac:	6039      	str	r1, [r7, #0]
  4023ae:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4023b0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4023b4:	2b00      	cmp	r3, #0
  4023b6:	da0b      	bge.n	4023d0 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4023b8:	490d      	ldr	r1, [pc, #52]	; (4023f0 <NVIC_SetPriority+0x4c>)
  4023ba:	79fb      	ldrb	r3, [r7, #7]
  4023bc:	f003 030f 	and.w	r3, r3, #15
  4023c0:	3b04      	subs	r3, #4
  4023c2:	683a      	ldr	r2, [r7, #0]
  4023c4:	b2d2      	uxtb	r2, r2
  4023c6:	0112      	lsls	r2, r2, #4
  4023c8:	b2d2      	uxtb	r2, r2
  4023ca:	440b      	add	r3, r1
  4023cc:	761a      	strb	r2, [r3, #24]
}
  4023ce:	e009      	b.n	4023e4 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4023d0:	4908      	ldr	r1, [pc, #32]	; (4023f4 <NVIC_SetPriority+0x50>)
  4023d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4023d6:	683a      	ldr	r2, [r7, #0]
  4023d8:	b2d2      	uxtb	r2, r2
  4023da:	0112      	lsls	r2, r2, #4
  4023dc:	b2d2      	uxtb	r2, r2
  4023de:	440b      	add	r3, r1
  4023e0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4023e4:	bf00      	nop
  4023e6:	370c      	adds	r7, #12
  4023e8:	46bd      	mov	sp, r7
  4023ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  4023ee:	4770      	bx	lr
  4023f0:	e000ed00 	.word	0xe000ed00
  4023f4:	e000e100 	.word	0xe000e100

004023f8 <osc_get_rate>:
{
  4023f8:	b480      	push	{r7}
  4023fa:	b083      	sub	sp, #12
  4023fc:	af00      	add	r7, sp, #0
  4023fe:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  402400:	687b      	ldr	r3, [r7, #4]
  402402:	2b07      	cmp	r3, #7
  402404:	d825      	bhi.n	402452 <osc_get_rate+0x5a>
  402406:	a201      	add	r2, pc, #4	; (adr r2, 40240c <osc_get_rate+0x14>)
  402408:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40240c:	0040242d 	.word	0x0040242d
  402410:	00402433 	.word	0x00402433
  402414:	00402439 	.word	0x00402439
  402418:	0040243f 	.word	0x0040243f
  40241c:	00402443 	.word	0x00402443
  402420:	00402447 	.word	0x00402447
  402424:	0040244b 	.word	0x0040244b
  402428:	0040244f 	.word	0x0040244f
		return OSC_SLCK_32K_RC_HZ;
  40242c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  402430:	e010      	b.n	402454 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  402432:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402436:	e00d      	b.n	402454 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  402438:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40243c:	e00a      	b.n	402454 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40243e:	4b08      	ldr	r3, [pc, #32]	; (402460 <osc_get_rate+0x68>)
  402440:	e008      	b.n	402454 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  402442:	4b08      	ldr	r3, [pc, #32]	; (402464 <osc_get_rate+0x6c>)
  402444:	e006      	b.n	402454 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  402446:	4b08      	ldr	r3, [pc, #32]	; (402468 <osc_get_rate+0x70>)
  402448:	e004      	b.n	402454 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  40244a:	4b07      	ldr	r3, [pc, #28]	; (402468 <osc_get_rate+0x70>)
  40244c:	e002      	b.n	402454 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40244e:	4b06      	ldr	r3, [pc, #24]	; (402468 <osc_get_rate+0x70>)
  402450:	e000      	b.n	402454 <osc_get_rate+0x5c>
	return 0;
  402452:	2300      	movs	r3, #0
}
  402454:	4618      	mov	r0, r3
  402456:	370c      	adds	r7, #12
  402458:	46bd      	mov	sp, r7
  40245a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40245e:	4770      	bx	lr
  402460:	003d0900 	.word	0x003d0900
  402464:	007a1200 	.word	0x007a1200
  402468:	00b71b00 	.word	0x00b71b00

0040246c <sysclk_get_main_hz>:
{
  40246c:	b580      	push	{r7, lr}
  40246e:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  402470:	2006      	movs	r0, #6
  402472:	4b03      	ldr	r3, [pc, #12]	; (402480 <sysclk_get_main_hz+0x14>)
  402474:	4798      	blx	r3
  402476:	4603      	mov	r3, r0
  402478:	011b      	lsls	r3, r3, #4
}
  40247a:	4618      	mov	r0, r3
  40247c:	bd80      	pop	{r7, pc}
  40247e:	bf00      	nop
  402480:	004023f9 	.word	0x004023f9

00402484 <sysclk_get_cpu_hz>:
{
  402484:	b580      	push	{r7, lr}
  402486:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402488:	4b02      	ldr	r3, [pc, #8]	; (402494 <sysclk_get_cpu_hz+0x10>)
  40248a:	4798      	blx	r3
  40248c:	4603      	mov	r3, r0
  40248e:	085b      	lsrs	r3, r3, #1
}
  402490:	4618      	mov	r0, r3
  402492:	bd80      	pop	{r7, pc}
  402494:	0040246d 	.word	0x0040246d

00402498 <sysclk_enable_peripheral_clock>:
{
  402498:	b580      	push	{r7, lr}
  40249a:	b082      	sub	sp, #8
  40249c:	af00      	add	r7, sp, #0
  40249e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4024a0:	6878      	ldr	r0, [r7, #4]
  4024a2:	4b03      	ldr	r3, [pc, #12]	; (4024b0 <sysclk_enable_peripheral_clock+0x18>)
  4024a4:	4798      	blx	r3
}
  4024a6:	bf00      	nop
  4024a8:	3708      	adds	r7, #8
  4024aa:	46bd      	mov	sp, r7
  4024ac:	bd80      	pop	{r7, pc}
  4024ae:	bf00      	nop
  4024b0:	0040823d 	.word	0x0040823d

004024b4 <ioport_set_pin_level>:
{
  4024b4:	b480      	push	{r7}
  4024b6:	b08b      	sub	sp, #44	; 0x2c
  4024b8:	af00      	add	r7, sp, #0
  4024ba:	6078      	str	r0, [r7, #4]
  4024bc:	460b      	mov	r3, r1
  4024be:	70fb      	strb	r3, [r7, #3]
  4024c0:	687b      	ldr	r3, [r7, #4]
  4024c2:	627b      	str	r3, [r7, #36]	; 0x24
  4024c4:	78fb      	ldrb	r3, [r7, #3]
  4024c6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4024ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024cc:	61fb      	str	r3, [r7, #28]
  4024ce:	69fb      	ldr	r3, [r7, #28]
  4024d0:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  4024d2:	69bb      	ldr	r3, [r7, #24]
  4024d4:	095b      	lsrs	r3, r3, #5
  4024d6:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4024d8:	697b      	ldr	r3, [r7, #20]
  4024da:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4024de:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4024e2:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  4024e4:	613b      	str	r3, [r7, #16]
	if (level) {
  4024e6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4024ea:	2b00      	cmp	r3, #0
  4024ec:	d009      	beq.n	402502 <ioport_set_pin_level+0x4e>
  4024ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024f0:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4024f2:	68fb      	ldr	r3, [r7, #12]
  4024f4:	f003 031f 	and.w	r3, r3, #31
  4024f8:	2201      	movs	r2, #1
  4024fa:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4024fc:	693b      	ldr	r3, [r7, #16]
  4024fe:	631a      	str	r2, [r3, #48]	; 0x30
}
  402500:	e008      	b.n	402514 <ioport_set_pin_level+0x60>
  402502:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402504:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  402506:	68bb      	ldr	r3, [r7, #8]
  402508:	f003 031f 	and.w	r3, r3, #31
  40250c:	2201      	movs	r2, #1
  40250e:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  402510:	693b      	ldr	r3, [r7, #16]
  402512:	635a      	str	r2, [r3, #52]	; 0x34
  402514:	bf00      	nop
  402516:	372c      	adds	r7, #44	; 0x2c
  402518:	46bd      	mov	sp, r7
  40251a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40251e:	4770      	bx	lr

00402520 <InitalizeCanSystem>:
 
uint32_t rx_mailbox_num = CAN_COMM_RXMB_ID;
  uint32_t ErrorCount = 0;
  
void InitalizeCanSystem(uint8_t DataRate, uint32_t ul_sysclk)
{
  402520:	b5b0      	push	{r4, r5, r7, lr}
  402522:	b08c      	sub	sp, #48	; 0x30
  402524:	af02      	add	r7, sp, #8
  402526:	4603      	mov	r3, r0
  402528:	61b9      	str	r1, [r7, #24]
  40252a:	77fb      	strb	r3, [r7, #31]
	uint32_t _DataRate = 0;
  40252c:	2300      	movs	r3, #0
  40252e:	627b      	str	r3, [r7, #36]	; 0x24
	#define CAN_BPS_50K                   50
	#define CAN_BPS_25K                   25
	#define CAN_BPS_10K                   10
	#define CAN_BPS_5K                    5
	*/
	switch(DataRate)
  402530:	7ffb      	ldrb	r3, [r7, #31]
  402532:	2b08      	cmp	r3, #8
  402534:	d878      	bhi.n	402628 <InitalizeCanSystem+0x108>
  402536:	a201      	add	r2, pc, #4	; (adr r2, 40253c <InitalizeCanSystem+0x1c>)
  402538:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40253c:	00402561 	.word	0x00402561
  402540:	00402569 	.word	0x00402569
  402544:	00402571 	.word	0x00402571
  402548:	00402579 	.word	0x00402579
  40254c:	0040257f 	.word	0x0040257f
  402550:	00402585 	.word	0x00402585
  402554:	0040258b 	.word	0x0040258b
  402558:	00402591 	.word	0x00402591
  40255c:	00402597 	.word	0x00402597
	{
		case 0:
		_DataRate = CAN_BPS_1000K;
  402560:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  402564:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  402566:	e019      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 1:
		_DataRate = CAN_BPS_800K;
  402568:	f44f 7348 	mov.w	r3, #800	; 0x320
  40256c:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  40256e:	e015      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 2:
		_DataRate = CAN_BPS_500K;
  402570:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  402574:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  402576:	e011      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 3:
		_DataRate = CAN_BPS_250K;
  402578:	23fa      	movs	r3, #250	; 0xfa
  40257a:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  40257c:	e00e      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 4:
		_DataRate = CAN_BPS_125K;
  40257e:	237d      	movs	r3, #125	; 0x7d
  402580:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  402582:	e00b      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 5: 
		_DataRate = CAN_BPS_50K;
  402584:	2332      	movs	r3, #50	; 0x32
  402586:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  402588:	e008      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 6:
		_DataRate = CAN_BPS_25K;
  40258a:	2319      	movs	r3, #25
  40258c:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  40258e:	e005      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 7:
		_DataRate = CAN_BPS_10K;
  402590:	230a      	movs	r3, #10
  402592:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  402594:	e002      	b.n	40259c <InitalizeCanSystem+0x7c>
		
		case 8:
		_DataRate = CAN_BPS_5K;
  402596:	2305      	movs	r3, #5
  402598:	627b      	str	r3, [r7, #36]	; 0x24
		break;
  40259a:	bf00      	nop
		default:
		//TODO: ERROR
		return;
	}
	//Enable the CAN system
	pmc_enable_periph_clk(SYSTEM_CAN_ID);
  40259c:	2025      	movs	r0, #37	; 0x25
  40259e:	4b24      	ldr	r3, [pc, #144]	; (402630 <InitalizeCanSystem+0x110>)
  4025a0:	4798      	blx	r3
	//Initalize the can system
	can_init(SYSTEM_CAN, ul_sysclk, _DataRate);
  4025a2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4025a4:	69b9      	ldr	r1, [r7, #24]
  4025a6:	4823      	ldr	r0, [pc, #140]	; (402634 <InitalizeCanSystem+0x114>)
  4025a8:	4b23      	ldr	r3, [pc, #140]	; (402638 <InitalizeCanSystem+0x118>)
  4025aa:	4798      	blx	r3
	SYSTEM_CAN->CAN_BR |= CAN_BR_SMP_THREE;
  4025ac:	4a21      	ldr	r2, [pc, #132]	; (402634 <InitalizeCanSystem+0x114>)
  4025ae:	4b21      	ldr	r3, [pc, #132]	; (402634 <InitalizeCanSystem+0x114>)
  4025b0:	695b      	ldr	r3, [r3, #20]
  4025b2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  4025b6:	6153      	str	r3, [r2, #20]
	//Disable all the trasceivers and then enable the HSC transeiver 
	DisableAllTransceivers();
  4025b8:	4b20      	ldr	r3, [pc, #128]	; (40263c <InitalizeCanSystem+0x11c>)
  4025ba:	4798      	blx	r3
	ioport_set_pin_level(HSC_NEN, IOPORT_PIN_LEVEL_LOW);
  4025bc:	2100      	movs	r1, #0
  4025be:	2074      	movs	r0, #116	; 0x74
  4025c0:	4b1f      	ldr	r3, [pc, #124]	; (402640 <InitalizeCanSystem+0x120>)
  4025c2:	4798      	blx	r3
	ioport_set_pin_level(HSC_NRM, IOPORT_PIN_LEVEL_HIGH);
  4025c4:	2101      	movs	r1, #1
  4025c6:	200b      	movs	r0, #11
  4025c8:	4b1d      	ldr	r3, [pc, #116]	; (402640 <InitalizeCanSystem+0x120>)
  4025ca:	4798      	blx	r3
	
	//Init Timer 
	sysclk_enable_peripheral_clock(TP_TIMEOUT_TIMER_ID);
  4025cc:	2018      	movs	r0, #24
  4025ce:	4b1d      	ldr	r3, [pc, #116]	; (402644 <InitalizeCanSystem+0x124>)
  4025d0:	4798      	blx	r3
	
	tc_stop(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL);
  4025d2:	2100      	movs	r1, #0
  4025d4:	481c      	ldr	r0, [pc, #112]	; (402648 <InitalizeCanSystem+0x128>)
  4025d6:	4b1d      	ldr	r3, [pc, #116]	; (40264c <InitalizeCanSystem+0x12c>)
  4025d8:	4798      	blx	r3
	
	tc_init(
  4025da:	f244 0203 	movw	r2, #16387	; 0x4003
  4025de:	2100      	movs	r1, #0
  4025e0:	4819      	ldr	r0, [pc, #100]	; (402648 <InitalizeCanSystem+0x128>)
  4025e2:	4b1b      	ldr	r3, [pc, #108]	; (402650 <InitalizeCanSystem+0x130>)
  4025e4:	4798      	blx	r3
	TP_TIMEOUT_TIMER_CHANNEL,
	TC_CMR_TCCLKS_TIMER_CLOCK4|
	TC_CMR_BURST_NONE|TC_CMR_CPCTRG
	);
	//Enable can interrupts
	can_enable_interrupt(SYSTEM_CAN, CAN_IER_ERRA | CAN_IER_WARN | CAN_IER_ERRP | CAN_IER_BOFF | CAN_IER_BERR);
  4025e6:	491b      	ldr	r1, [pc, #108]	; (402654 <InitalizeCanSystem+0x134>)
  4025e8:	4812      	ldr	r0, [pc, #72]	; (402634 <InitalizeCanSystem+0x114>)
  4025ea:	4b1b      	ldr	r3, [pc, #108]	; (402658 <InitalizeCanSystem+0x138>)
  4025ec:	4798      	blx	r3
	//Set the ISO15765 Shims
	shims = isotp_init_shims( NULL, SendStandardCanMessage, RunTimer, delayms);
  4025ee:	4d1b      	ldr	r5, [pc, #108]	; (40265c <InitalizeCanSystem+0x13c>)
  4025f0:	4638      	mov	r0, r7
  4025f2:	4b1b      	ldr	r3, [pc, #108]	; (402660 <InitalizeCanSystem+0x140>)
  4025f4:	9300      	str	r3, [sp, #0]
  4025f6:	4b1b      	ldr	r3, [pc, #108]	; (402664 <InitalizeCanSystem+0x144>)
  4025f8:	4a1b      	ldr	r2, [pc, #108]	; (402668 <InitalizeCanSystem+0x148>)
  4025fa:	2100      	movs	r1, #0
  4025fc:	4c1b      	ldr	r4, [pc, #108]	; (40266c <InitalizeCanSystem+0x14c>)
  4025fe:	47a0      	blx	r4
  402600:	463c      	mov	r4, r7
  402602:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  402604:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  402606:	6823      	ldr	r3, [r4, #0]
  402608:	602b      	str	r3, [r5, #0]
	//Set the rx handle for iso15765
	rx_handle = isotp_receive(&shims,0x00,message_received);
  40260a:	4d19      	ldr	r5, [pc, #100]	; (402670 <InitalizeCanSystem+0x150>)
  40260c:	4638      	mov	r0, r7
  40260e:	4b19      	ldr	r3, [pc, #100]	; (402674 <InitalizeCanSystem+0x154>)
  402610:	2200      	movs	r2, #0
  402612:	4912      	ldr	r1, [pc, #72]	; (40265c <InitalizeCanSystem+0x13c>)
  402614:	4c18      	ldr	r4, [pc, #96]	; (402678 <InitalizeCanSystem+0x158>)
  402616:	47a0      	blx	r4
  402618:	463c      	mov	r4, r7
  40261a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  40261c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  40261e:	e894 0003 	ldmia.w	r4, {r0, r1}
  402622:	e885 0003 	stmia.w	r5, {r0, r1}
  402626:	e000      	b.n	40262a <InitalizeCanSystem+0x10a>
		return;
  402628:	bf00      	nop
}
  40262a:	3728      	adds	r7, #40	; 0x28
  40262c:	46bd      	mov	sp, r7
  40262e:	bdb0      	pop	{r4, r5, r7, pc}
  402630:	0040823d 	.word	0x0040823d
  402634:	40010000 	.word	0x40010000
  402638:	00400dd5 	.word	0x00400dd5
  40263c:	00402851 	.word	0x00402851
  402640:	004024b5 	.word	0x004024b5
  402644:	00402499 	.word	0x00402499
  402648:	40094000 	.word	0x40094000
  40264c:	00401579 	.word	0x00401579
  402650:	00401501 	.word	0x00401501
  402654:	100f0000 	.word	0x100f0000
  402658:	00400e91 	.word	0x00400e91
  40265c:	20008938 	.word	0x20008938
  402660:	00402681 	.word	0x00402681
  402664:	00402ce5 	.word	0x00402ce5
  402668:	00402895 	.word	0x00402895
  40266c:	00408809 	.word	0x00408809
  402670:	2000894c 	.word	0x2000894c
  402674:	00402de9 	.word	0x00402de9
  402678:	00408847 	.word	0x00408847
  40267c:	00000000 	.word	0x00000000

00402680 <delayms>:
//Delay shim
void delayms(uint32_t delay)
{
  402680:	b5f0      	push	{r4, r5, r6, r7, lr}
  402682:	b083      	sub	sp, #12
  402684:	af00      	add	r7, sp, #0
  402686:	6078      	str	r0, [r7, #4]
	delay_ms(delay);
  402688:	687b      	ldr	r3, [r7, #4]
  40268a:	2b00      	cmp	r3, #0
  40268c:	d038      	beq.n	402700 <delayms+0x80>
  40268e:	687b      	ldr	r3, [r7, #4]
  402690:	461d      	mov	r5, r3
  402692:	f04f 0600 	mov.w	r6, #0
  402696:	4b2a      	ldr	r3, [pc, #168]	; (402740 <delayms+0xc0>)
  402698:	4798      	blx	r3
  40269a:	4603      	mov	r3, r0
  40269c:	f04f 0400 	mov.w	r4, #0
  4026a0:	fb03 f106 	mul.w	r1, r3, r6
  4026a4:	fb05 f204 	mul.w	r2, r5, r4
  4026a8:	440a      	add	r2, r1
  4026aa:	fba5 0103 	umull	r0, r1, r5, r3
  4026ae:	1853      	adds	r3, r2, r1
  4026b0:	4619      	mov	r1, r3
  4026b2:	4c24      	ldr	r4, [pc, #144]	; (402744 <delayms+0xc4>)
  4026b4:	f04f 0206 	mov.w	r2, #6
  4026b8:	f04f 0300 	mov.w	r3, #0
  4026bc:	47a0      	blx	r4
  4026be:	4603      	mov	r3, r0
  4026c0:	460c      	mov	r4, r1
  4026c2:	4619      	mov	r1, r3
  4026c4:	4622      	mov	r2, r4
  4026c6:	f240 33e7 	movw	r3, #999	; 0x3e7
  4026ca:	f04f 0400 	mov.w	r4, #0
  4026ce:	185b      	adds	r3, r3, r1
  4026d0:	eb44 0402 	adc.w	r4, r4, r2
  4026d4:	4a1c      	ldr	r2, [pc, #112]	; (402748 <delayms+0xc8>)
  4026d6:	4618      	mov	r0, r3
  4026d8:	4621      	mov	r1, r4
  4026da:	4790      	blx	r2
  4026dc:	4c1b      	ldr	r4, [pc, #108]	; (40274c <delayms+0xcc>)
  4026de:	f04f 0200 	mov.w	r2, #0
  4026e2:	4b1b      	ldr	r3, [pc, #108]	; (402750 <delayms+0xd0>)
  4026e4:	47a0      	blx	r4
  4026e6:	4603      	mov	r3, r0
  4026e8:	460c      	mov	r4, r1
  4026ea:	4619      	mov	r1, r3
  4026ec:	4622      	mov	r2, r4
  4026ee:	4b19      	ldr	r3, [pc, #100]	; (402754 <delayms+0xd4>)
  4026f0:	4608      	mov	r0, r1
  4026f2:	4611      	mov	r1, r2
  4026f4:	4798      	blx	r3
  4026f6:	4603      	mov	r3, r0
  4026f8:	4618      	mov	r0, r3
  4026fa:	4b17      	ldr	r3, [pc, #92]	; (402758 <delayms+0xd8>)
  4026fc:	4798      	blx	r3
}
  4026fe:	e016      	b.n	40272e <delayms+0xae>
	delay_ms(delay);
  402700:	4b0f      	ldr	r3, [pc, #60]	; (402740 <delayms+0xc0>)
  402702:	4798      	blx	r3
  402704:	4603      	mov	r3, r0
  402706:	f04f 0400 	mov.w	r4, #0
  40270a:	a20b      	add	r2, pc, #44	; (adr r2, 402738 <delayms+0xb8>)
  40270c:	e9d2 1200 	ldrd	r1, r2, [r2]
  402710:	185d      	adds	r5, r3, r1
  402712:	eb44 0602 	adc.w	r6, r4, r2
  402716:	4628      	mov	r0, r5
  402718:	4631      	mov	r1, r6
  40271a:	4c0a      	ldr	r4, [pc, #40]	; (402744 <delayms+0xc4>)
  40271c:	4a0f      	ldr	r2, [pc, #60]	; (40275c <delayms+0xdc>)
  40271e:	f04f 0300 	mov.w	r3, #0
  402722:	47a0      	blx	r4
  402724:	4603      	mov	r3, r0
  402726:	460c      	mov	r4, r1
  402728:	4618      	mov	r0, r3
  40272a:	4b0b      	ldr	r3, [pc, #44]	; (402758 <delayms+0xd8>)
  40272c:	4798      	blx	r3
}
  40272e:	bf00      	nop
  402730:	370c      	adds	r7, #12
  402732:	46bd      	mov	sp, r7
  402734:	bdf0      	pop	{r4, r5, r6, r7, pc}
  402736:	bf00      	nop
  402738:	00d59f7f 	.word	0x00d59f7f
  40273c:	00000000 	.word	0x00000000
  402740:	00402485 	.word	0x00402485
  402744:	00409d55 	.word	0x00409d55
  402748:	00409885 	.word	0x00409885
  40274c:	00409b45 	.word	0x00409b45
  402750:	408f4000 	.word	0x408f4000
  402754:	00409d15 	.word	0x00409d15
  402758:	20000001 	.word	0x20000001
  40275c:	00d59f80 	.word	0x00d59f80

00402760 <HandleSendCanRequest>:
//Send a can message to the network
void HandleSendCanRequest(Message_t *OutgoingMessage)
{
  402760:	b590      	push	{r4, r7, lr}
  402762:	b08d      	sub	sp, #52	; 0x34
  402764:	af04      	add	r7, sp, #16
  402766:	61f8      	str	r0, [r7, #28]
	switch(OutgoingMessage->buf[1])
  402768:	69fb      	ldr	r3, [r7, #28]
  40276a:	681b      	ldr	r3, [r3, #0]
  40276c:	3301      	adds	r3, #1
  40276e:	781b      	ldrb	r3, [r3, #0]
  402770:	2b00      	cmp	r3, #0
  402772:	d002      	beq.n	40277a <HandleSendCanRequest+0x1a>
  402774:	2b01      	cmp	r3, #1
  402776:	d011      	beq.n	40279c <HandleSendCanRequest+0x3c>
			}
			
		}
		break;
	}
}
  402778:	e05d      	b.n	402836 <HandleSendCanRequest+0xd6>
			SendStandardCanMessage(OutgoingMessage->buf[2], OutgoingMessage->buf+3, OutgoingMessage->Size-3);
  40277a:	69fb      	ldr	r3, [r7, #28]
  40277c:	681b      	ldr	r3, [r3, #0]
  40277e:	3302      	adds	r3, #2
  402780:	7818      	ldrb	r0, [r3, #0]
  402782:	69fb      	ldr	r3, [r7, #28]
  402784:	681b      	ldr	r3, [r3, #0]
  402786:	1cd9      	adds	r1, r3, #3
  402788:	69fb      	ldr	r3, [r7, #28]
  40278a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  40278e:	b2db      	uxtb	r3, r3
  402790:	3b03      	subs	r3, #3
  402792:	b2db      	uxtb	r3, r3
  402794:	461a      	mov	r2, r3
  402796:	4b2a      	ldr	r3, [pc, #168]	; (402840 <HandleSendCanRequest+0xe0>)
  402798:	4798      	blx	r3
		break;
  40279a:	e04c      	b.n	402836 <HandleSendCanRequest+0xd6>
			if(OutgoingMessage->buf[2] == 0)
  40279c:	69fb      	ldr	r3, [r7, #28]
  40279e:	681b      	ldr	r3, [r3, #0]
  4027a0:	3302      	adds	r3, #2
  4027a2:	781b      	ldrb	r3, [r3, #0]
  4027a4:	2b00      	cmp	r3, #0
  4027a6:	d120      	bne.n	4027ea <HandleSendCanRequest+0x8a>
				isotp_send(&shims, (OutgoingMessage->buf[5] << 8) | OutgoingMessage->buf[6], OutgoingMessage->buf+5, OutgoingMessage->Size-5, NULL);
  4027a8:	69fb      	ldr	r3, [r7, #28]
  4027aa:	681b      	ldr	r3, [r3, #0]
  4027ac:	3305      	adds	r3, #5
  4027ae:	781b      	ldrb	r3, [r3, #0]
  4027b0:	021b      	lsls	r3, r3, #8
  4027b2:	b21a      	sxth	r2, r3
  4027b4:	69fb      	ldr	r3, [r7, #28]
  4027b6:	681b      	ldr	r3, [r3, #0]
  4027b8:	3306      	adds	r3, #6
  4027ba:	781b      	ldrb	r3, [r3, #0]
  4027bc:	b21b      	sxth	r3, r3
  4027be:	4313      	orrs	r3, r2
  4027c0:	b21b      	sxth	r3, r3
  4027c2:	b299      	uxth	r1, r3
  4027c4:	69fb      	ldr	r3, [r7, #28]
  4027c6:	681b      	ldr	r3, [r3, #0]
  4027c8:	1d5c      	adds	r4, r3, #5
  4027ca:	69fb      	ldr	r3, [r7, #28]
  4027cc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  4027d0:	b29b      	uxth	r3, r3
  4027d2:	3b05      	subs	r3, #5
  4027d4:	b29b      	uxth	r3, r3
  4027d6:	4638      	mov	r0, r7
  4027d8:	2200      	movs	r2, #0
  4027da:	9201      	str	r2, [sp, #4]
  4027dc:	9300      	str	r3, [sp, #0]
  4027de:	4623      	mov	r3, r4
  4027e0:	460a      	mov	r2, r1
  4027e2:	4918      	ldr	r1, [pc, #96]	; (402844 <HandleSendCanRequest+0xe4>)
  4027e4:	4c18      	ldr	r4, [pc, #96]	; (402848 <HandleSendCanRequest+0xe8>)
  4027e6:	47a0      	blx	r4
		break;
  4027e8:	e024      	b.n	402834 <HandleSendCanRequest+0xd4>
				isotp_send_ext(&shims, (OutgoingMessage->buf[6] << 8) | OutgoingMessage->buf[7], OutgoingMessage->buf+6, OutgoingMessage->Size-6, NULL, OutgoingMessage->buf[3]);	
  4027ea:	69fb      	ldr	r3, [r7, #28]
  4027ec:	681b      	ldr	r3, [r3, #0]
  4027ee:	3306      	adds	r3, #6
  4027f0:	781b      	ldrb	r3, [r3, #0]
  4027f2:	021b      	lsls	r3, r3, #8
  4027f4:	b21a      	sxth	r2, r3
  4027f6:	69fb      	ldr	r3, [r7, #28]
  4027f8:	681b      	ldr	r3, [r3, #0]
  4027fa:	3307      	adds	r3, #7
  4027fc:	781b      	ldrb	r3, [r3, #0]
  4027fe:	b21b      	sxth	r3, r3
  402800:	4313      	orrs	r3, r2
  402802:	b21b      	sxth	r3, r3
  402804:	b299      	uxth	r1, r3
  402806:	69fb      	ldr	r3, [r7, #28]
  402808:	681b      	ldr	r3, [r3, #0]
  40280a:	1d9c      	adds	r4, r3, #6
  40280c:	69fb      	ldr	r3, [r7, #28]
  40280e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
  402812:	b29b      	uxth	r3, r3
  402814:	3b06      	subs	r3, #6
  402816:	b29b      	uxth	r3, r3
  402818:	69fa      	ldr	r2, [r7, #28]
  40281a:	6812      	ldr	r2, [r2, #0]
  40281c:	3203      	adds	r2, #3
  40281e:	7812      	ldrb	r2, [r2, #0]
  402820:	4638      	mov	r0, r7
  402822:	9202      	str	r2, [sp, #8]
  402824:	2200      	movs	r2, #0
  402826:	9201      	str	r2, [sp, #4]
  402828:	9300      	str	r3, [sp, #0]
  40282a:	4623      	mov	r3, r4
  40282c:	460a      	mov	r2, r1
  40282e:	4905      	ldr	r1, [pc, #20]	; (402844 <HandleSendCanRequest+0xe4>)
  402830:	4c06      	ldr	r4, [pc, #24]	; (40284c <HandleSendCanRequest+0xec>)
  402832:	47a0      	blx	r4
		break;
  402834:	bf00      	nop
}
  402836:	bf00      	nop
  402838:	3724      	adds	r7, #36	; 0x24
  40283a:	46bd      	mov	sp, r7
  40283c:	bd90      	pop	{r4, r7, pc}
  40283e:	bf00      	nop
  402840:	00402895 	.word	0x00402895
  402844:	20008938 	.word	0x20008938
  402848:	00408f51 	.word	0x00408f51
  40284c:	00408fb5 	.word	0x00408fb5

00402850 <DisableAllTransceivers>:
	}
	
}
//Disables all the transceivers
void DisableAllTransceivers()
{
  402850:	b580      	push	{r7, lr}
  402852:	af00      	add	r7, sp, #0
	ioport_set_pin_level(SWC_RX_EN, IOPORT_PIN_LEVEL_LOW);
  402854:	2100      	movs	r1, #0
  402856:	2017      	movs	r0, #23
  402858:	4b0d      	ldr	r3, [pc, #52]	; (402890 <DisableAllTransceivers+0x40>)
  40285a:	4798      	blx	r3
	ioport_set_pin_level(SWC_MODE_1, IOPORT_PIN_LEVEL_LOW);
  40285c:	2100      	movs	r1, #0
  40285e:	200d      	movs	r0, #13
  402860:	4b0b      	ldr	r3, [pc, #44]	; (402890 <DisableAllTransceivers+0x40>)
  402862:	4798      	blx	r3
	ioport_set_pin_level(SWC_MODE_2, IOPORT_PIN_LEVEL_HIGH);
  402864:	2101      	movs	r1, #1
  402866:	200e      	movs	r0, #14
  402868:	4b09      	ldr	r3, [pc, #36]	; (402890 <DisableAllTransceivers+0x40>)
  40286a:	4798      	blx	r3

	ioport_set_pin_level(MSC_NEN, IOPORT_PIN_LEVEL_HIGH);
  40286c:	2101      	movs	r1, #1
  40286e:	2079      	movs	r0, #121	; 0x79
  402870:	4b07      	ldr	r3, [pc, #28]	; (402890 <DisableAllTransceivers+0x40>)
  402872:	4798      	blx	r3
	ioport_set_pin_level(MSC_NRM, IOPORT_PIN_LEVEL_HIGH);
  402874:	2101      	movs	r1, #1
  402876:	2079      	movs	r0, #121	; 0x79
  402878:	4b05      	ldr	r3, [pc, #20]	; (402890 <DisableAllTransceivers+0x40>)
  40287a:	4798      	blx	r3

	ioport_set_pin_level(HSC_NEN, IOPORT_PIN_LEVEL_HIGH);
  40287c:	2101      	movs	r1, #1
  40287e:	2074      	movs	r0, #116	; 0x74
  402880:	4b03      	ldr	r3, [pc, #12]	; (402890 <DisableAllTransceivers+0x40>)
  402882:	4798      	blx	r3
	ioport_set_pin_level(HSC_NRM, IOPORT_PIN_LEVEL_HIGH);
  402884:	2101      	movs	r1, #1
  402886:	200b      	movs	r0, #11
  402888:	4b01      	ldr	r3, [pc, #4]	; (402890 <DisableAllTransceivers+0x40>)
  40288a:	4798      	blx	r3
}
  40288c:	bf00      	nop
  40288e:	bd80      	pop	{r7, pc}
  402890:	004024b5 	.word	0x004024b5

00402894 <SendStandardCanMessage>:
This function is called when a standard can message must be sent to the network. 
It waits for the transmit mailbox to become available, sets it up, and sends the message. 
Any response is handled by the CAN receiver logic.
*/
uint32_t SendStandardCanMessage(uint8_t arbitration_type, uint8_t *data, const uint8_t size)
{
  402894:	b580      	push	{r7, lr}
  402896:	b086      	sub	sp, #24
  402898:	af00      	add	r7, sp, #0
  40289a:	4603      	mov	r3, r0
  40289c:	6039      	str	r1, [r7, #0]
  40289e:	71fb      	strb	r3, [r7, #7]
  4028a0:	4613      	mov	r3, r2
  4028a2:	71bb      	strb	r3, [r7, #6]
	uint32_t retval = 0;
  4028a4:	2300      	movs	r3, #0
  4028a6:	617b      	str	r3, [r7, #20]
	uint32_t arbitrationID = 0;
  4028a8:	2300      	movs	r3, #0
  4028aa:	613b      	str	r3, [r7, #16]
	uint32_t CanStatusReg = CAN0->CAN_SR;
  4028ac:	4b36      	ldr	r3, [pc, #216]	; (402988 <SendStandardCanMessage+0xf4>)
  4028ae:	691b      	ldr	r3, [r3, #16]
  4028b0:	60fb      	str	r3, [r7, #12]
	
	if(size - 4 > 8)
  4028b2:	79bb      	ldrb	r3, [r7, #6]
  4028b4:	3b04      	subs	r3, #4
  4028b6:	2b08      	cmp	r3, #8
  4028b8:	dc5f      	bgt.n	40297a <SendStandardCanMessage+0xe6>
		////Unsupported Error	
		//return;
		//break;
	//}
	
	arbitrationID = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | (data[3] << 0);
  4028ba:	683b      	ldr	r3, [r7, #0]
  4028bc:	781b      	ldrb	r3, [r3, #0]
  4028be:	061a      	lsls	r2, r3, #24
  4028c0:	683b      	ldr	r3, [r7, #0]
  4028c2:	3301      	adds	r3, #1
  4028c4:	781b      	ldrb	r3, [r3, #0]
  4028c6:	041b      	lsls	r3, r3, #16
  4028c8:	431a      	orrs	r2, r3
  4028ca:	683b      	ldr	r3, [r7, #0]
  4028cc:	3302      	adds	r3, #2
  4028ce:	781b      	ldrb	r3, [r3, #0]
  4028d0:	021b      	lsls	r3, r3, #8
  4028d2:	4313      	orrs	r3, r2
  4028d4:	683a      	ldr	r2, [r7, #0]
  4028d6:	3203      	adds	r2, #3
  4028d8:	7812      	ldrb	r2, [r2, #0]
  4028da:	4313      	orrs	r3, r2
  4028dc:	613b      	str	r3, [r7, #16]

	reset_mailbox_conf(&tx_mailbox);
  4028de:	482b      	ldr	r0, [pc, #172]	; (40298c <SendStandardCanMessage+0xf8>)
  4028e0:	4b2b      	ldr	r3, [pc, #172]	; (402990 <SendStandardCanMessage+0xfc>)
  4028e2:	4798      	blx	r3
	tx_mailbox.ul_mb_idx = CAN_COMM_TXMB_ID;
  4028e4:	4b29      	ldr	r3, [pc, #164]	; (40298c <SendStandardCanMessage+0xf8>)
  4028e6:	2200      	movs	r2, #0
  4028e8:	601a      	str	r2, [r3, #0]
	tx_mailbox.uc_obj_type = CAN_MB_TX_MODE;
  4028ea:	4b28      	ldr	r3, [pc, #160]	; (40298c <SendStandardCanMessage+0xf8>)
  4028ec:	2203      	movs	r2, #3
  4028ee:	711a      	strb	r2, [r3, #4]

	tx_mailbox.ul_id = CAN_MID_MIDvA(arbitrationID) | CAN_MID_MIDvB((arbitrationID >>16));
  4028f0:	693b      	ldr	r3, [r7, #16]
  4028f2:	049a      	lsls	r2, r3, #18
  4028f4:	4b27      	ldr	r3, [pc, #156]	; (402994 <SendStandardCanMessage+0x100>)
  4028f6:	4013      	ands	r3, r2
  4028f8:	693a      	ldr	r2, [r7, #16]
  4028fa:	0c12      	lsrs	r2, r2, #16
  4028fc:	4313      	orrs	r3, r2
  4028fe:	4a23      	ldr	r2, [pc, #140]	; (40298c <SendStandardCanMessage+0xf8>)
  402900:	6113      	str	r3, [r2, #16]
	if(arbitration_type)
  402902:	79fb      	ldrb	r3, [r7, #7]
  402904:	2b00      	cmp	r3, #0
  402906:	d005      	beq.n	402914 <SendStandardCanMessage+0x80>
	{
		tx_mailbox.ul_id |= CAN_MID_MIDE;
  402908:	4b20      	ldr	r3, [pc, #128]	; (40298c <SendStandardCanMessage+0xf8>)
  40290a:	691b      	ldr	r3, [r3, #16]
  40290c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  402910:	4a1e      	ldr	r2, [pc, #120]	; (40298c <SendStandardCanMessage+0xf8>)
  402912:	6113      	str	r3, [r2, #16]
	}
	
	tx_mailbox.uc_tx_prio = 2;
  402914:	4b1d      	ldr	r3, [pc, #116]	; (40298c <SendStandardCanMessage+0xf8>)
  402916:	2202      	movs	r2, #2
  402918:	71da      	strb	r2, [r3, #7]
	tx_mailbox.uc_id_ver = 0;
  40291a:	4b1c      	ldr	r3, [pc, #112]	; (40298c <SendStandardCanMessage+0xf8>)
  40291c:	2200      	movs	r2, #0
  40291e:	715a      	strb	r2, [r3, #5]
	tx_mailbox.ul_id_msk = 0;
  402920:	4b1a      	ldr	r3, [pc, #104]	; (40298c <SendStandardCanMessage+0xf8>)
  402922:	2200      	movs	r2, #0
  402924:	60da      	str	r2, [r3, #12]
	tx_mailbox.uc_length = 8;
  402926:	4b19      	ldr	r3, [pc, #100]	; (40298c <SendStandardCanMessage+0xf8>)
  402928:	2208      	movs	r2, #8
  40292a:	719a      	strb	r2, [r3, #6]
	can_mailbox_init(SYSTEM_CAN, &tx_mailbox);
  40292c:	4917      	ldr	r1, [pc, #92]	; (40298c <SendStandardCanMessage+0xf8>)
  40292e:	4816      	ldr	r0, [pc, #88]	; (402988 <SendStandardCanMessage+0xf4>)
  402930:	4b19      	ldr	r3, [pc, #100]	; (402998 <SendStandardCanMessage+0x104>)
  402932:	4798      	blx	r3
	
	memcpy(&tx_mailbox.ul_datal,data+4, 4*sizeof(Byte));
  402934:	683b      	ldr	r3, [r7, #0]
  402936:	3304      	adds	r3, #4
  402938:	681b      	ldr	r3, [r3, #0]
  40293a:	461a      	mov	r2, r3
  40293c:	4b13      	ldr	r3, [pc, #76]	; (40298c <SendStandardCanMessage+0xf8>)
  40293e:	619a      	str	r2, [r3, #24]
	memcpy(&tx_mailbox.ul_datah,data+8, 4*sizeof(Byte));
  402940:	683b      	ldr	r3, [r7, #0]
  402942:	3308      	adds	r3, #8
  402944:	681b      	ldr	r3, [r3, #0]
  402946:	461a      	mov	r2, r3
  402948:	4b10      	ldr	r3, [pc, #64]	; (40298c <SendStandardCanMessage+0xf8>)
  40294a:	61da      	str	r2, [r3, #28]
	//memset(&tx_mailbox.ul_datal+(size-3),0x00,8-(size - 4));
	retval = can_mailbox_write(SYSTEM_CAN, &tx_mailbox);
  40294c:	490f      	ldr	r1, [pc, #60]	; (40298c <SendStandardCanMessage+0xf8>)
  40294e:	480e      	ldr	r0, [pc, #56]	; (402988 <SendStandardCanMessage+0xf4>)
  402950:	4b12      	ldr	r3, [pc, #72]	; (40299c <SendStandardCanMessage+0x108>)
  402952:	4798      	blx	r3
  402954:	6178      	str	r0, [r7, #20]
	
	int i =0;
  402956:	2300      	movs	r3, #0
  402958:	60bb      	str	r3, [r7, #8]
	if(data[4] == 0x00)
  40295a:	683b      	ldr	r3, [r7, #0]
  40295c:	3304      	adds	r3, #4
  40295e:	781b      	ldrb	r3, [r3, #0]
  402960:	2b00      	cmp	r3, #0
  402962:	d102      	bne.n	40296a <SendStandardCanMessage+0xd6>
	{
		i++;
  402964:	68bb      	ldr	r3, [r7, #8]
  402966:	3301      	adds	r3, #1
  402968:	60bb      	str	r3, [r7, #8]
	}
	
	//TODO: Report TX error here
	if(retval)
  40296a:	697b      	ldr	r3, [r7, #20]
  40296c:	2b00      	cmp	r3, #0
  40296e:	d106      	bne.n	40297e <SendStandardCanMessage+0xea>
	{
		return;
	}
	//can_mailbox_send_transfer_cmd(SYSTEM_CAN, &hsc_tx_mailbox);
	can_global_send_transfer_cmd(CAN0,  (0x1u << CAN_COMM_TXMB_ID));
  402970:	2101      	movs	r1, #1
  402972:	4805      	ldr	r0, [pc, #20]	; (402988 <SendStandardCanMessage+0xf4>)
  402974:	4b0a      	ldr	r3, [pc, #40]	; (4029a0 <SendStandardCanMessage+0x10c>)
  402976:	4798      	blx	r3
  402978:	e002      	b.n	402980 <SendStandardCanMessage+0xec>
		return;
  40297a:	bf00      	nop
  40297c:	e000      	b.n	402980 <SendStandardCanMessage+0xec>
		return;
  40297e:	bf00      	nop
}
  402980:	4618      	mov	r0, r3
  402982:	3718      	adds	r7, #24
  402984:	46bd      	mov	sp, r7
  402986:	bd80      	pop	{r7, pc}
  402988:	40010000 	.word	0x40010000
  40298c:	20003198 	.word	0x20003198
  402990:	00402b15 	.word	0x00402b15
  402994:	1ffc0000 	.word	0x1ffc0000
  402998:	00400f6b 	.word	0x00400f6b
  40299c:	00401175 	.word	0x00401175
  4029a0:	00400ee1 	.word	0x00400ee1

004029a4 <InitalizeReceiverMailbox>:

//Initalizes a receiver mailbox, see the datasheet/asf documentation for information on mailboxs
void InitalizeReceiverMailbox(uint8_t type, uint8_t * Mask, uint8_t* Pattern)
{
  4029a4:	b580      	push	{r7, lr}
  4029a6:	b084      	sub	sp, #16
  4029a8:	af00      	add	r7, sp, #0
  4029aa:	4603      	mov	r3, r0
  4029ac:	60b9      	str	r1, [r7, #8]
  4029ae:	607a      	str	r2, [r7, #4]
  4029b0:	73fb      	strb	r3, [r7, #15]
	
	//TODO: HANDLE MORE THAN 7 RX BOX
	reset_mailbox_conf(&rx_mailbox);
  4029b2:	4833      	ldr	r0, [pc, #204]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  4029b4:	4b33      	ldr	r3, [pc, #204]	; (402a84 <InitalizeReceiverMailbox+0xe0>)
  4029b6:	4798      	blx	r3
	
	rx_mailbox.ul_mb_idx = rx_mailbox_num;
  4029b8:	4b33      	ldr	r3, [pc, #204]	; (402a88 <InitalizeReceiverMailbox+0xe4>)
  4029ba:	681b      	ldr	r3, [r3, #0]
  4029bc:	4a30      	ldr	r2, [pc, #192]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  4029be:	6013      	str	r3, [r2, #0]
	rx_mailbox.uc_obj_type = CAN_MB_RX_MODE;
  4029c0:	4b2f      	ldr	r3, [pc, #188]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  4029c2:	2201      	movs	r2, #1
  4029c4:	711a      	strb	r2, [r3, #4]

	rx_mailbox.ul_id = CAN_MID_MIDvA(Pattern[2] << 8 | Pattern[3]) | CAN_MID_MIDvB(Pattern[0] << 8 | Pattern[1]);
  4029c6:	687b      	ldr	r3, [r7, #4]
  4029c8:	3302      	adds	r3, #2
  4029ca:	781b      	ldrb	r3, [r3, #0]
  4029cc:	021b      	lsls	r3, r3, #8
  4029ce:	687a      	ldr	r2, [r7, #4]
  4029d0:	3203      	adds	r2, #3
  4029d2:	7812      	ldrb	r2, [r2, #0]
  4029d4:	4313      	orrs	r3, r2
  4029d6:	049b      	lsls	r3, r3, #18
  4029d8:	461a      	mov	r2, r3
  4029da:	4b2c      	ldr	r3, [pc, #176]	; (402a8c <InitalizeReceiverMailbox+0xe8>)
  4029dc:	4013      	ands	r3, r2
  4029de:	687a      	ldr	r2, [r7, #4]
  4029e0:	7812      	ldrb	r2, [r2, #0]
  4029e2:	0212      	lsls	r2, r2, #8
  4029e4:	6879      	ldr	r1, [r7, #4]
  4029e6:	3101      	adds	r1, #1
  4029e8:	7809      	ldrb	r1, [r1, #0]
  4029ea:	430a      	orrs	r2, r1
  4029ec:	f3c2 0211 	ubfx	r2, r2, #0, #18
  4029f0:	4313      	orrs	r3, r2
  4029f2:	4a23      	ldr	r2, [pc, #140]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  4029f4:	6113      	str	r3, [r2, #16]
	rx_mailbox.ul_id_msk = CAN_MID_MIDvA(Mask[2] << 8 | Mask[3]) | CAN_MID_MIDvB(Mask[0] << 8 | Mask[1]);
  4029f6:	68bb      	ldr	r3, [r7, #8]
  4029f8:	3302      	adds	r3, #2
  4029fa:	781b      	ldrb	r3, [r3, #0]
  4029fc:	021b      	lsls	r3, r3, #8
  4029fe:	68ba      	ldr	r2, [r7, #8]
  402a00:	3203      	adds	r2, #3
  402a02:	7812      	ldrb	r2, [r2, #0]
  402a04:	4313      	orrs	r3, r2
  402a06:	049b      	lsls	r3, r3, #18
  402a08:	461a      	mov	r2, r3
  402a0a:	4b20      	ldr	r3, [pc, #128]	; (402a8c <InitalizeReceiverMailbox+0xe8>)
  402a0c:	4013      	ands	r3, r2
  402a0e:	68ba      	ldr	r2, [r7, #8]
  402a10:	7812      	ldrb	r2, [r2, #0]
  402a12:	0212      	lsls	r2, r2, #8
  402a14:	68b9      	ldr	r1, [r7, #8]
  402a16:	3101      	adds	r1, #1
  402a18:	7809      	ldrb	r1, [r1, #0]
  402a1a:	430a      	orrs	r2, r1
  402a1c:	f3c2 0211 	ubfx	r2, r2, #0, #18
  402a20:	4313      	orrs	r3, r2
  402a22:	4a17      	ldr	r2, [pc, #92]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a24:	60d3      	str	r3, [r2, #12]
	
	if(type)
  402a26:	7bfb      	ldrb	r3, [r7, #15]
  402a28:	2b00      	cmp	r3, #0
  402a2a:	d00b      	beq.n	402a44 <InitalizeReceiverMailbox+0xa0>
	{
		rx_mailbox.ul_id |= CAN_MID_MIDE;
  402a2c:	4b14      	ldr	r3, [pc, #80]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a2e:	691b      	ldr	r3, [r3, #16]
  402a30:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  402a34:	4a12      	ldr	r2, [pc, #72]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a36:	6113      	str	r3, [r2, #16]
		rx_mailbox.ul_id_msk |= CAN_MAM_MIDE;
  402a38:	4b11      	ldr	r3, [pc, #68]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a3a:	68db      	ldr	r3, [r3, #12]
  402a3c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  402a40:	4a0f      	ldr	r2, [pc, #60]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a42:	60d3      	str	r3, [r2, #12]
	}
	
	can_mailbox_init(SYSTEM_CAN, &rx_mailbox);
  402a44:	490e      	ldr	r1, [pc, #56]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a46:	4812      	ldr	r0, [pc, #72]	; (402a90 <InitalizeReceiverMailbox+0xec>)
  402a48:	4b12      	ldr	r3, [pc, #72]	; (402a94 <InitalizeReceiverMailbox+0xf0>)
  402a4a:	4798      	blx	r3
	
	can_enable_interrupt(SYSTEM_CAN, (0x1u << rx_mailbox_num++));
  402a4c:	4b0e      	ldr	r3, [pc, #56]	; (402a88 <InitalizeReceiverMailbox+0xe4>)
  402a4e:	681b      	ldr	r3, [r3, #0]
  402a50:	1c5a      	adds	r2, r3, #1
  402a52:	490d      	ldr	r1, [pc, #52]	; (402a88 <InitalizeReceiverMailbox+0xe4>)
  402a54:	600a      	str	r2, [r1, #0]
  402a56:	2201      	movs	r2, #1
  402a58:	fa02 f303 	lsl.w	r3, r2, r3
  402a5c:	4619      	mov	r1, r3
  402a5e:	480c      	ldr	r0, [pc, #48]	; (402a90 <InitalizeReceiverMailbox+0xec>)
  402a60:	4b0d      	ldr	r3, [pc, #52]	; (402a98 <InitalizeReceiverMailbox+0xf4>)
  402a62:	4798      	blx	r3
	NVIC_EnableIRQ(SYSTEM_CAN_IRQ);
  402a64:	2025      	movs	r0, #37	; 0x25
  402a66:	4b0d      	ldr	r3, [pc, #52]	; (402a9c <InitalizeReceiverMailbox+0xf8>)
  402a68:	4798      	blx	r3
	NVIC_SetPriority(SYSTEM_CAN_IRQ, 7);
  402a6a:	2107      	movs	r1, #7
  402a6c:	2025      	movs	r0, #37	; 0x25
  402a6e:	4b0c      	ldr	r3, [pc, #48]	; (402aa0 <InitalizeReceiverMailbox+0xfc>)
  402a70:	4798      	blx	r3
	reset_mailbox_conf(&rx_mailbox);
  402a72:	4803      	ldr	r0, [pc, #12]	; (402a80 <InitalizeReceiverMailbox+0xdc>)
  402a74:	4b03      	ldr	r3, [pc, #12]	; (402a84 <InitalizeReceiverMailbox+0xe0>)
  402a76:	4798      	blx	r3
	
	
}
  402a78:	bf00      	nop
  402a7a:	3710      	adds	r7, #16
  402a7c:	46bd      	mov	sp, r7
  402a7e:	bd80      	pop	{r7, pc}
  402a80:	200031b8 	.word	0x200031b8
  402a84:	00402b15 	.word	0x00402b15
  402a88:	20000174 	.word	0x20000174
  402a8c:	1ffc0000 	.word	0x1ffc0000
  402a90:	40010000 	.word	0x40010000
  402a94:	00400f6b 	.word	0x00400f6b
  402a98:	00400e91 	.word	0x00400e91
  402a9c:	00402309 	.word	0x00402309
  402aa0:	004023a5 	.word	0x004023a5

00402aa4 <RemoveMailbox>:
//Removes a mailbox
void RemoveMailbox(uint8_t MailboxID)
{
  402aa4:	b580      	push	{r7, lr}
  402aa6:	b082      	sub	sp, #8
  402aa8:	af00      	add	r7, sp, #0
  402aaa:	4603      	mov	r3, r0
  402aac:	71fb      	strb	r3, [r7, #7]
	rx_mailbox.ul_mb_idx = MailboxID;
  402aae:	79fb      	ldrb	r3, [r7, #7]
  402ab0:	4a12      	ldr	r2, [pc, #72]	; (402afc <RemoveMailbox+0x58>)
  402ab2:	6013      	str	r3, [r2, #0]
	rx_mailbox.uc_obj_type = CAN_MB_DISABLE_MODE;
  402ab4:	4b11      	ldr	r3, [pc, #68]	; (402afc <RemoveMailbox+0x58>)
  402ab6:	2200      	movs	r2, #0
  402ab8:	711a      	strb	r2, [r3, #4]
	can_mailbox_init(SYSTEM_CAN, &rx_mailbox);	
  402aba:	4910      	ldr	r1, [pc, #64]	; (402afc <RemoveMailbox+0x58>)
  402abc:	4810      	ldr	r0, [pc, #64]	; (402b00 <RemoveMailbox+0x5c>)
  402abe:	4b11      	ldr	r3, [pc, #68]	; (402b04 <RemoveMailbox+0x60>)
  402ac0:	4798      	blx	r3
	can_disable_interrupt(SYSTEM_CAN, (0x1u << rx_mailbox_num));	
  402ac2:	4b11      	ldr	r3, [pc, #68]	; (402b08 <RemoveMailbox+0x64>)
  402ac4:	681b      	ldr	r3, [r3, #0]
  402ac6:	2201      	movs	r2, #1
  402ac8:	fa02 f303 	lsl.w	r3, r2, r3
  402acc:	4619      	mov	r1, r3
  402ace:	480c      	ldr	r0, [pc, #48]	; (402b00 <RemoveMailbox+0x5c>)
  402ad0:	4b0e      	ldr	r3, [pc, #56]	; (402b0c <RemoveMailbox+0x68>)
  402ad2:	4798      	blx	r3
	reset_mailbox_conf(&rx_mailbox);
  402ad4:	4809      	ldr	r0, [pc, #36]	; (402afc <RemoveMailbox+0x58>)
  402ad6:	4b0e      	ldr	r3, [pc, #56]	; (402b10 <RemoveMailbox+0x6c>)
  402ad8:	4798      	blx	r3
	rx_mailbox_num--;
  402ada:	4b0b      	ldr	r3, [pc, #44]	; (402b08 <RemoveMailbox+0x64>)
  402adc:	681b      	ldr	r3, [r3, #0]
  402ade:	3b01      	subs	r3, #1
  402ae0:	4a09      	ldr	r2, [pc, #36]	; (402b08 <RemoveMailbox+0x64>)
  402ae2:	6013      	str	r3, [r2, #0]
	if(rx_mailbox_num <= 0)
  402ae4:	4b08      	ldr	r3, [pc, #32]	; (402b08 <RemoveMailbox+0x64>)
  402ae6:	681b      	ldr	r3, [r3, #0]
  402ae8:	2b00      	cmp	r3, #0
  402aea:	d102      	bne.n	402af2 <RemoveMailbox+0x4e>
	{
		rx_mailbox_num = 1;	
  402aec:	4b06      	ldr	r3, [pc, #24]	; (402b08 <RemoveMailbox+0x64>)
  402aee:	2201      	movs	r2, #1
  402af0:	601a      	str	r2, [r3, #0]
	}
}
  402af2:	bf00      	nop
  402af4:	3708      	adds	r7, #8
  402af6:	46bd      	mov	sp, r7
  402af8:	bd80      	pop	{r7, pc}
  402afa:	bf00      	nop
  402afc:	200031b8 	.word	0x200031b8
  402b00:	40010000 	.word	0x40010000
  402b04:	00400f6b 	.word	0x00400f6b
  402b08:	20000174 	.word	0x20000174
  402b0c:	00400ead 	.word	0x00400ead
  402b10:	00402b15 	.word	0x00402b15

00402b14 <reset_mailbox_conf>:
//Resets the mailbox configuration vairables
static void reset_mailbox_conf(can_mb_conf_t *p_mailbox)
{
  402b14:	b480      	push	{r7}
  402b16:	b083      	sub	sp, #12
  402b18:	af00      	add	r7, sp, #0
  402b1a:	6078      	str	r0, [r7, #4]
	p_mailbox->ul_mb_idx = 0;
  402b1c:	687b      	ldr	r3, [r7, #4]
  402b1e:	2200      	movs	r2, #0
  402b20:	601a      	str	r2, [r3, #0]
	p_mailbox->uc_obj_type = 0;
  402b22:	687b      	ldr	r3, [r7, #4]
  402b24:	2200      	movs	r2, #0
  402b26:	711a      	strb	r2, [r3, #4]
	p_mailbox->uc_id_ver = 0;
  402b28:	687b      	ldr	r3, [r7, #4]
  402b2a:	2200      	movs	r2, #0
  402b2c:	715a      	strb	r2, [r3, #5]
	p_mailbox->uc_length = 0;
  402b2e:	687b      	ldr	r3, [r7, #4]
  402b30:	2200      	movs	r2, #0
  402b32:	719a      	strb	r2, [r3, #6]
	p_mailbox->uc_tx_prio = 0;
  402b34:	687b      	ldr	r3, [r7, #4]
  402b36:	2200      	movs	r2, #0
  402b38:	71da      	strb	r2, [r3, #7]
	p_mailbox->ul_status = 0;
  402b3a:	687b      	ldr	r3, [r7, #4]
  402b3c:	2200      	movs	r2, #0
  402b3e:	609a      	str	r2, [r3, #8]
	p_mailbox->ul_id_msk = 0;
  402b40:	687b      	ldr	r3, [r7, #4]
  402b42:	2200      	movs	r2, #0
  402b44:	60da      	str	r2, [r3, #12]
	p_mailbox->ul_id = 0;
  402b46:	687b      	ldr	r3, [r7, #4]
  402b48:	2200      	movs	r2, #0
  402b4a:	611a      	str	r2, [r3, #16]
	p_mailbox->ul_fid = 0;
  402b4c:	687b      	ldr	r3, [r7, #4]
  402b4e:	2200      	movs	r2, #0
  402b50:	615a      	str	r2, [r3, #20]
	p_mailbox->ul_datal = 0;
  402b52:	687b      	ldr	r3, [r7, #4]
  402b54:	2200      	movs	r2, #0
  402b56:	619a      	str	r2, [r3, #24]
	p_mailbox->ul_datah = 0;
  402b58:	687b      	ldr	r3, [r7, #4]
  402b5a:	2200      	movs	r2, #0
  402b5c:	61da      	str	r2, [r3, #28]
}
  402b5e:	bf00      	nop
  402b60:	370c      	adds	r7, #12
  402b62:	46bd      	mov	sp, r7
  402b64:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b68:	4770      	bx	lr
	...

00402b6c <TC3_Handler>:
//Timer interuppty
TC3_Handler()
{
  402b6c:	b580      	push	{r7, lr}
  402b6e:	b084      	sub	sp, #16
  402b70:	af00      	add	r7, sp, #0
	if ((tc_get_status(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL) & TC_SR_CPCS) == TC_SR_CPCS)
  402b72:	2100      	movs	r1, #0
  402b74:	480d      	ldr	r0, [pc, #52]	; (402bac <TC3_Handler+0x40>)
  402b76:	4b0e      	ldr	r3, [pc, #56]	; (402bb0 <TC3_Handler+0x44>)
  402b78:	4798      	blx	r3
  402b7a:	4603      	mov	r3, r0
  402b7c:	f003 0310 	and.w	r3, r3, #16
  402b80:	2b10      	cmp	r3, #16
  402b82:	d10f      	bne.n	402ba4 <TC3_Handler+0x38>
	{
		NVIC_ClearPendingIRQ(TC3_IRQn);
  402b84:	2018      	movs	r0, #24
  402b86:	4b0b      	ldr	r3, [pc, #44]	; (402bb4 <TC3_Handler+0x48>)
  402b88:	4798      	blx	r3
		TimeoutCB();
  402b8a:	4b0b      	ldr	r3, [pc, #44]	; (402bb8 <TC3_Handler+0x4c>)
  402b8c:	681b      	ldr	r3, [r3, #0]
  402b8e:	4798      	blx	r3
		
		Error_T TPTImeoutError;
		TPTImeoutError.ThrowerID = THROWER_ID_ISO_TP;
  402b90:	2303      	movs	r3, #3
  402b92:	607b      	str	r3, [r7, #4]
		TPTImeoutError.ErrorMajor = TP_TIMEOUT;
  402b94:	230f      	movs	r3, #15
  402b96:	60bb      	str	r3, [r7, #8]
		TPTImeoutError.ErrorMinor = ERROR_NO_MINOR_CODE;
  402b98:	2300      	movs	r3, #0
  402b9a:	60fb      	str	r3, [r7, #12]
		ThrowError(&TPTImeoutError);
  402b9c:	1d3b      	adds	r3, r7, #4
  402b9e:	4618      	mov	r0, r3
  402ba0:	4b06      	ldr	r3, [pc, #24]	; (402bbc <TC3_Handler+0x50>)
  402ba2:	4798      	blx	r3
	}
}
  402ba4:	bf00      	nop
  402ba6:	3710      	adds	r7, #16
  402ba8:	46bd      	mov	sp, r7
  402baa:	bd80      	pop	{r7, pc}
  402bac:	40094000 	.word	0x40094000
  402bb0:	0040160b 	.word	0x0040160b
  402bb4:	00402371 	.word	0x00402371
  402bb8:	20008934 	.word	0x20008934
  402bbc:	00401631 	.word	0x00401631

00402bc0 <CAN0_Handler>:
//CAN interrupt
CAN0_Handler()
 {
  402bc0:	b580      	push	{r7, lr}
  402bc2:	b08e      	sub	sp, #56	; 0x38
  402bc4:	af00      	add	r7, sp, #0
	 uint8_t FlowControlMessageSize;
	 uint8_t retval;
	 uint8_t Mailbox;
	 uint32_t CanStatusReg;
	 
	  iram_size_t error = SYSTEM_CAN->CAN_SR & (CAN_IMR_ERRA | CAN_IMR_WARN | CAN_IMR_ERRP | CAN_IMR_BOFF | CAN_IMR_BERR);
  402bc6:	4b40      	ldr	r3, [pc, #256]	; (402cc8 <CAN0_Handler+0x108>)
  402bc8:	691a      	ldr	r2, [r3, #16]
  402bca:	4b40      	ldr	r3, [pc, #256]	; (402ccc <CAN0_Handler+0x10c>)
  402bcc:	4013      	ands	r3, r2
  402bce:	633b      	str	r3, [r7, #48]	; 0x30
	  if(error)
  402bd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402bd2:	2b00      	cmp	r3, #0
  402bd4:	d005      	beq.n	402be2 <CAN0_Handler+0x22>
	  {
		  CanStatusReg = CAN0->CAN_SR;
  402bd6:	4b3c      	ldr	r3, [pc, #240]	; (402cc8 <CAN0_Handler+0x108>)
  402bd8:	691b      	ldr	r3, [r3, #16]
  402bda:	62fb      	str	r3, [r7, #44]	; 0x2c
		  SYSTEM_CAN->CAN_MR = CAN_MR_CANEN;  
  402bdc:	4b3a      	ldr	r3, [pc, #232]	; (402cc8 <CAN0_Handler+0x108>)
  402bde:	2201      	movs	r2, #1
  402be0:	601a      	str	r2, [r3, #0]
	  }
//Check each mailbox
	 for(Mailbox = CAN_COMM_RXMB_ID; Mailbox < MAX_NUMBER_OF_MAILBOXES; Mailbox++)
  402be2:	2301      	movs	r3, #1
  402be4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  402be8:	e066      	b.n	402cb8 <CAN0_Handler+0xf8>
	 {
		//IF one is ready handle it
		 iram_size_t ready = SYSTEM_CAN->CAN_MB[Mailbox].CAN_MSR & CAN_MSR_MRDY;
  402bea:	4a37      	ldr	r2, [pc, #220]	; (402cc8 <CAN0_Handler+0x108>)
  402bec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  402bf0:	015b      	lsls	r3, r3, #5
  402bf2:	4413      	add	r3, r2
  402bf4:	f503 7304 	add.w	r3, r3, #528	; 0x210
  402bf8:	681b      	ldr	r3, [r3, #0]
  402bfa:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  402bfe:	62bb      	str	r3, [r7, #40]	; 0x28
		 if (  ready == CAN_MSR_MRDY)
  402c00:	6abb      	ldr	r3, [r7, #40]	; 0x28
  402c02:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
  402c06:	d152      	bne.n	402cae <CAN0_Handler+0xee>
		 {
			 rx_mailbox.ul_mb_idx = Mailbox;
  402c08:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  402c0c:	4a30      	ldr	r2, [pc, #192]	; (402cd0 <CAN0_Handler+0x110>)
  402c0e:	6013      	str	r3, [r2, #0]
			 //read the mailbox
			 can_mailbox_read(SYSTEM_CAN, &rx_mailbox);
  402c10:	492f      	ldr	r1, [pc, #188]	; (402cd0 <CAN0_Handler+0x110>)
  402c12:	482d      	ldr	r0, [pc, #180]	; (402cc8 <CAN0_Handler+0x108>)
  402c14:	4b2f      	ldr	r3, [pc, #188]	; (402cd4 <CAN0_Handler+0x114>)
  402c16:	4798      	blx	r3
		
			 
			 
			 /*This code will attempt to process the isoTP messages in the driver software*/
			 
			 uint32_t MessageID = (( rx_mailbox.ul_id & 0x1FFC0000) >> 18) |  rx_mailbox.ul_fid;
  402c18:	4b2d      	ldr	r3, [pc, #180]	; (402cd0 <CAN0_Handler+0x110>)
  402c1a:	691b      	ldr	r3, [r3, #16]
  402c1c:	0c9b      	lsrs	r3, r3, #18
  402c1e:	f3c3 020a 	ubfx	r2, r3, #0, #11
  402c22:	4b2b      	ldr	r3, [pc, #172]	; (402cd0 <CAN0_Handler+0x110>)
  402c24:	695b      	ldr	r3, [r3, #20]
  402c26:	4313      	orrs	r3, r2
  402c28:	627b      	str	r3, [r7, #36]	; 0x24
			 uint8_t MessageIDArr[5];
			 
			 MessageIDArr[0] = (MessageID >> 24) & 0xFF;
  402c2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c2c:	0e1b      	lsrs	r3, r3, #24
  402c2e:	b2db      	uxtb	r3, r3
  402c30:	773b      	strb	r3, [r7, #28]
			 MessageIDArr[1] = (MessageID >> 16) & 0xFF;
  402c32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c34:	0c1b      	lsrs	r3, r3, #16
  402c36:	b2db      	uxtb	r3, r3
  402c38:	777b      	strb	r3, [r7, #29]
			 MessageIDArr[2] = (MessageID >> 8) & 0xFF;
  402c3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c3c:	0a1b      	lsrs	r3, r3, #8
  402c3e:	b2db      	uxtb	r3, r3
  402c40:	77bb      	strb	r3, [r7, #30]
			 MessageIDArr[3] = MessageID & 0xFF;
  402c42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c44:	b2db      	uxtb	r3, r3
  402c46:	77fb      	strb	r3, [r7, #31]
			 
			 uint8_t CANMessageReceived[17] = {START_BYTE, 0x00, 0x0E, NETWORK_MESSAGE, 0x02 ,MessageIDArr[0], MessageIDArr[1], MessageIDArr[2], MessageIDArr[3], 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa};
  402c48:	2302      	movs	r3, #2
  402c4a:	723b      	strb	r3, [r7, #8]
  402c4c:	2300      	movs	r3, #0
  402c4e:	727b      	strb	r3, [r7, #9]
  402c50:	230e      	movs	r3, #14
  402c52:	72bb      	strb	r3, [r7, #10]
  402c54:	23aa      	movs	r3, #170	; 0xaa
  402c56:	72fb      	strb	r3, [r7, #11]
  402c58:	2302      	movs	r3, #2
  402c5a:	733b      	strb	r3, [r7, #12]
  402c5c:	7f3b      	ldrb	r3, [r7, #28]
  402c5e:	737b      	strb	r3, [r7, #13]
  402c60:	7f7b      	ldrb	r3, [r7, #29]
  402c62:	73bb      	strb	r3, [r7, #14]
  402c64:	7fbb      	ldrb	r3, [r7, #30]
  402c66:	73fb      	strb	r3, [r7, #15]
  402c68:	7ffb      	ldrb	r3, [r7, #31]
  402c6a:	743b      	strb	r3, [r7, #16]
  402c6c:	23aa      	movs	r3, #170	; 0xaa
  402c6e:	747b      	strb	r3, [r7, #17]
  402c70:	23aa      	movs	r3, #170	; 0xaa
  402c72:	74bb      	strb	r3, [r7, #18]
  402c74:	23aa      	movs	r3, #170	; 0xaa
  402c76:	74fb      	strb	r3, [r7, #19]
  402c78:	23aa      	movs	r3, #170	; 0xaa
  402c7a:	753b      	strb	r3, [r7, #20]
  402c7c:	23aa      	movs	r3, #170	; 0xaa
  402c7e:	757b      	strb	r3, [r7, #21]
  402c80:	23aa      	movs	r3, #170	; 0xaa
  402c82:	75bb      	strb	r3, [r7, #22]
  402c84:	23aa      	movs	r3, #170	; 0xaa
  402c86:	75fb      	strb	r3, [r7, #23]
  402c88:	23aa      	movs	r3, #170	; 0xaa
  402c8a:	763b      	strb	r3, [r7, #24]
			 //if(MessageIDArr[2] == 0x03)
			 //{
			 //return;
			 //}
			 memcpy(CANMessageReceived+9,&rx_mailbox.ul_datal,8);
  402c8c:	f107 0308 	add.w	r3, r7, #8
  402c90:	3309      	adds	r3, #9
  402c92:	2208      	movs	r2, #8
  402c94:	4910      	ldr	r1, [pc, #64]	; (402cd8 <CAN0_Handler+0x118>)
  402c96:	4618      	mov	r0, r3
  402c98:	4b10      	ldr	r3, [pc, #64]	; (402cdc <CAN0_Handler+0x11c>)
  402c9a:	4798      	blx	r3
			 
			 Message_t CanSfMessage;
			 CanSfMessage.buf = CANMessageReceived;
  402c9c:	f107 0308 	add.w	r3, r7, #8
  402ca0:	603b      	str	r3, [r7, #0]
			 CanSfMessage.Size = 17;
  402ca2:	2311      	movs	r3, #17
  402ca4:	80bb      	strh	r3, [r7, #4]
			 WriteMessage(&CanSfMessage);
  402ca6:	463b      	mov	r3, r7
  402ca8:	4618      	mov	r0, r3
  402caa:	4b0d      	ldr	r3, [pc, #52]	; (402ce0 <CAN0_Handler+0x120>)
  402cac:	4798      	blx	r3
	 for(Mailbox = CAN_COMM_RXMB_ID; Mailbox < MAX_NUMBER_OF_MAILBOXES; Mailbox++)
  402cae:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  402cb2:	3301      	adds	r3, #1
  402cb4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  402cb8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  402cbc:	2b07      	cmp	r3, #7
  402cbe:	d994      	bls.n	402bea <CAN0_Handler+0x2a>
				 //9
				 //);
			 //}
		 } 
	 }
 }
  402cc0:	bf00      	nop
  402cc2:	3738      	adds	r7, #56	; 0x38
  402cc4:	46bd      	mov	sp, r7
  402cc6:	bd80      	pop	{r7, pc}
  402cc8:	40010000 	.word	0x40010000
  402ccc:	100f0000 	.word	0x100f0000
  402cd0:	200031b8 	.word	0x200031b8
  402cd4:	00401091 	.word	0x00401091
  402cd8:	200031d0 	.word	0x200031d0
  402cdc:	0040a635 	.word	0x0040a635
  402ce0:	00401a3d 	.word	0x00401a3d

00402ce4 <RunTimer>:
 
 /* ISO-TP SHIMS*/
 bool RunTimer(uint16_t time_ms,bool stop, TimeoutCallback cb)
 {
  402ce4:	b590      	push	{r4, r7, lr}
  402ce6:	b083      	sub	sp, #12
  402ce8:	af00      	add	r7, sp, #0
  402cea:	4603      	mov	r3, r0
  402cec:	603a      	str	r2, [r7, #0]
  402cee:	80fb      	strh	r3, [r7, #6]
  402cf0:	460b      	mov	r3, r1
  402cf2:	717b      	strb	r3, [r7, #5]
	 if(stop)
  402cf4:	797b      	ldrb	r3, [r7, #5]
  402cf6:	2b00      	cmp	r3, #0
  402cf8:	d008      	beq.n	402d0c <RunTimer+0x28>
	 {
		 tc_stop(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL);
  402cfa:	2100      	movs	r1, #0
  402cfc:	482b      	ldr	r0, [pc, #172]	; (402dac <RunTimer+0xc8>)
  402cfe:	4b2c      	ldr	r3, [pc, #176]	; (402db0 <RunTimer+0xcc>)
  402d00:	4798      	blx	r3
		 NVIC_DisableIRQ(TC3_IRQn);
  402d02:	2018      	movs	r0, #24
  402d04:	4b2b      	ldr	r3, [pc, #172]	; (402db4 <RunTimer+0xd0>)
  402d06:	4798      	blx	r3
		 return true;
  402d08:	2301      	movs	r3, #1
  402d0a:	e04a      	b.n	402da2 <RunTimer+0xbe>
	 }
	 //Run the timer for X milliseconds
	 tc_write_rc(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL, cpu_ms_2_cy(time_ms,96000000));
  402d0c:	88fb      	ldrh	r3, [r7, #6]
  402d0e:	f04f 0400 	mov.w	r4, #0
  402d12:	4a29      	ldr	r2, [pc, #164]	; (402db8 <RunTimer+0xd4>)
  402d14:	fb02 f104 	mul.w	r1, r2, r4
  402d18:	2200      	movs	r2, #0
  402d1a:	fb02 f203 	mul.w	r2, r2, r3
  402d1e:	440a      	add	r2, r1
  402d20:	4925      	ldr	r1, [pc, #148]	; (402db8 <RunTimer+0xd4>)
  402d22:	fba3 0101 	umull	r0, r1, r3, r1
  402d26:	1853      	adds	r3, r2, r1
  402d28:	4619      	mov	r1, r3
  402d2a:	4c24      	ldr	r4, [pc, #144]	; (402dbc <RunTimer+0xd8>)
  402d2c:	f04f 0206 	mov.w	r2, #6
  402d30:	f04f 0300 	mov.w	r3, #0
  402d34:	47a0      	blx	r4
  402d36:	4603      	mov	r3, r0
  402d38:	460c      	mov	r4, r1
  402d3a:	4619      	mov	r1, r3
  402d3c:	4622      	mov	r2, r4
  402d3e:	f240 33e7 	movw	r3, #999	; 0x3e7
  402d42:	f04f 0400 	mov.w	r4, #0
  402d46:	185b      	adds	r3, r3, r1
  402d48:	eb44 0402 	adc.w	r4, r4, r2
  402d4c:	4a1c      	ldr	r2, [pc, #112]	; (402dc0 <RunTimer+0xdc>)
  402d4e:	4618      	mov	r0, r3
  402d50:	4621      	mov	r1, r4
  402d52:	4790      	blx	r2
  402d54:	4c1b      	ldr	r4, [pc, #108]	; (402dc4 <RunTimer+0xe0>)
  402d56:	f04f 0200 	mov.w	r2, #0
  402d5a:	4b1b      	ldr	r3, [pc, #108]	; (402dc8 <RunTimer+0xe4>)
  402d5c:	47a0      	blx	r4
  402d5e:	4603      	mov	r3, r0
  402d60:	460c      	mov	r4, r1
  402d62:	4619      	mov	r1, r3
  402d64:	4622      	mov	r2, r4
  402d66:	4b19      	ldr	r3, [pc, #100]	; (402dcc <RunTimer+0xe8>)
  402d68:	4608      	mov	r0, r1
  402d6a:	4611      	mov	r1, r2
  402d6c:	4798      	blx	r3
  402d6e:	4603      	mov	r3, r0
  402d70:	461a      	mov	r2, r3
  402d72:	2100      	movs	r1, #0
  402d74:	480d      	ldr	r0, [pc, #52]	; (402dac <RunTimer+0xc8>)
  402d76:	4b16      	ldr	r3, [pc, #88]	; (402dd0 <RunTimer+0xec>)
  402d78:	4798      	blx	r3
	 tc_enable_interrupt(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL,  TC_IER_CPCS);
  402d7a:	2210      	movs	r2, #16
  402d7c:	2100      	movs	r1, #0
  402d7e:	480b      	ldr	r0, [pc, #44]	; (402dac <RunTimer+0xc8>)
  402d80:	4b14      	ldr	r3, [pc, #80]	; (402dd4 <RunTimer+0xf0>)
  402d82:	4798      	blx	r3
	 NVIC_EnableIRQ(TC3_IRQn);
  402d84:	2018      	movs	r0, #24
  402d86:	4b14      	ldr	r3, [pc, #80]	; (402dd8 <RunTimer+0xf4>)
  402d88:	4798      	blx	r3
	 NVIC_SetPriority(TC3_IRQn,0);
  402d8a:	2100      	movs	r1, #0
  402d8c:	2018      	movs	r0, #24
  402d8e:	4b13      	ldr	r3, [pc, #76]	; (402ddc <RunTimer+0xf8>)
  402d90:	4798      	blx	r3
	 tc_start(TP_TIMEOUT_TIMER, TP_TIMEOUT_TIMER_CHANNEL);
  402d92:	2100      	movs	r1, #0
  402d94:	4805      	ldr	r0, [pc, #20]	; (402dac <RunTimer+0xc8>)
  402d96:	4b12      	ldr	r3, [pc, #72]	; (402de0 <RunTimer+0xfc>)
  402d98:	4798      	blx	r3
	 TimeoutCB = cb;
  402d9a:	4a12      	ldr	r2, [pc, #72]	; (402de4 <RunTimer+0x100>)
  402d9c:	683b      	ldr	r3, [r7, #0]
  402d9e:	6013      	str	r3, [r2, #0]
	 return true;
  402da0:	2301      	movs	r3, #1
 }
  402da2:	4618      	mov	r0, r3
  402da4:	370c      	adds	r7, #12
  402da6:	46bd      	mov	sp, r7
  402da8:	bd90      	pop	{r4, r7, pc}
  402daa:	bf00      	nop
  402dac:	40094000 	.word	0x40094000
  402db0:	00401579 	.word	0x00401579
  402db4:	0040233d 	.word	0x0040233d
  402db8:	05b8d800 	.word	0x05b8d800
  402dbc:	00409d55 	.word	0x00409d55
  402dc0:	00409885 	.word	0x00409885
  402dc4:	00409b45 	.word	0x00409b45
  402dc8:	408f4000 	.word	0x408f4000
  402dcc:	00409d15 	.word	0x00409d15
  402dd0:	004015bd 	.word	0x004015bd
  402dd4:	004015e3 	.word	0x004015e3
  402dd8:	00402309 	.word	0x00402309
  402ddc:	004023a5 	.word	0x004023a5
  402de0:	00401557 	.word	0x00401557
  402de4:	20008934 	.word	0x20008934

00402de8 <message_received>:

 //Called when a complete can message is received
 //TODO: Proper Formatting here
 void message_received( const IsoTpMessage* message) {
  402de8:	b580      	push	{r7, lr}
  402dea:	b086      	sub	sp, #24
  402dec:	af00      	add	r7, sp, #0
  402dee:	6078      	str	r0, [r7, #4]
	 Message_t CanMessageReceived;
	  uint8_t MessageIDArr[5];
	  
	MessageIDArr[0] = (message->arbitration_id >> 24) & 0xFF;
  402df0:	687b      	ldr	r3, [r7, #4]
  402df2:	681b      	ldr	r3, [r3, #0]
  402df4:	0e1b      	lsrs	r3, r3, #24
  402df6:	b2db      	uxtb	r3, r3
  402df8:	723b      	strb	r3, [r7, #8]
	MessageIDArr[1] = (message->arbitration_id >> 16) & 0xFF;
  402dfa:	687b      	ldr	r3, [r7, #4]
  402dfc:	681b      	ldr	r3, [r3, #0]
  402dfe:	0c1b      	lsrs	r3, r3, #16
  402e00:	b2db      	uxtb	r3, r3
  402e02:	727b      	strb	r3, [r7, #9]
	MessageIDArr[2] = (message->arbitration_id >> 8) & 0xFF;
  402e04:	687b      	ldr	r3, [r7, #4]
  402e06:	681b      	ldr	r3, [r3, #0]
  402e08:	0a1b      	lsrs	r3, r3, #8
  402e0a:	b2db      	uxtb	r3, r3
  402e0c:	72bb      	strb	r3, [r7, #10]
	MessageIDArr[3] = message->arbitration_id & 0xFF;
  402e0e:	687b      	ldr	r3, [r7, #4]
  402e10:	681b      	ldr	r3, [r3, #0]
  402e12:	b2db      	uxtb	r3, r3
  402e14:	72fb      	strb	r3, [r7, #11]
	message->payload[0] = START_BYTE;
  402e16:	687b      	ldr	r3, [r7, #4]
  402e18:	68db      	ldr	r3, [r3, #12]
  402e1a:	2202      	movs	r2, #2
  402e1c:	701a      	strb	r2, [r3, #0]
	 
	message->payload[1] = ( ((message->size) - 3) & 0xFF00) >> 8;
  402e1e:	687b      	ldr	r3, [r7, #4]
  402e20:	68db      	ldr	r3, [r3, #12]
  402e22:	3301      	adds	r3, #1
  402e24:	687a      	ldr	r2, [r7, #4]
  402e26:	8912      	ldrh	r2, [r2, #8]
  402e28:	3a03      	subs	r2, #3
  402e2a:	1212      	asrs	r2, r2, #8
  402e2c:	b2d2      	uxtb	r2, r2
  402e2e:	701a      	strb	r2, [r3, #0]
	message->payload[2] = (message->size) - 3 & 0x00FF;
  402e30:	687b      	ldr	r3, [r7, #4]
  402e32:	68db      	ldr	r3, [r3, #12]
  402e34:	3302      	adds	r3, #2
  402e36:	687a      	ldr	r2, [r7, #4]
  402e38:	8912      	ldrh	r2, [r2, #8]
  402e3a:	b2d2      	uxtb	r2, r2
  402e3c:	3a03      	subs	r2, #3
  402e3e:	b2d2      	uxtb	r2, r2
  402e40:	701a      	strb	r2, [r3, #0]
	message->payload[3] = NETWORK_MESSAGE;
  402e42:	687b      	ldr	r3, [r7, #4]
  402e44:	68db      	ldr	r3, [r3, #12]
  402e46:	3303      	adds	r3, #3
  402e48:	22aa      	movs	r2, #170	; 0xaa
  402e4a:	701a      	strb	r2, [r3, #0]
	message->payload[4] = 3;
  402e4c:	687b      	ldr	r3, [r7, #4]
  402e4e:	68db      	ldr	r3, [r3, #12]
  402e50:	3304      	adds	r3, #4
  402e52:	2203      	movs	r2, #3
  402e54:	701a      	strb	r2, [r3, #0]
	message->payload[5] = MessageIDArr[0];
  402e56:	687b      	ldr	r3, [r7, #4]
  402e58:	68db      	ldr	r3, [r3, #12]
  402e5a:	3305      	adds	r3, #5
  402e5c:	7a3a      	ldrb	r2, [r7, #8]
  402e5e:	701a      	strb	r2, [r3, #0]
	message->payload[6] = MessageIDArr[1];
  402e60:	687b      	ldr	r3, [r7, #4]
  402e62:	68db      	ldr	r3, [r3, #12]
  402e64:	3306      	adds	r3, #6
  402e66:	7a7a      	ldrb	r2, [r7, #9]
  402e68:	701a      	strb	r2, [r3, #0]
	message->payload[7] = MessageIDArr[2]; 
  402e6a:	687b      	ldr	r3, [r7, #4]
  402e6c:	68db      	ldr	r3, [r3, #12]
  402e6e:	3307      	adds	r3, #7
  402e70:	7aba      	ldrb	r2, [r7, #10]
  402e72:	701a      	strb	r2, [r3, #0]
	message->payload[8] = MessageIDArr[3];
  402e74:	687b      	ldr	r3, [r7, #4]
  402e76:	68db      	ldr	r3, [r3, #12]
  402e78:	3308      	adds	r3, #8
  402e7a:	7afa      	ldrb	r2, [r7, #11]
  402e7c:	701a      	strb	r2, [r3, #0]
	 
	CanMessageReceived.buf = message->payload;
  402e7e:	687b      	ldr	r3, [r7, #4]
  402e80:	68db      	ldr	r3, [r3, #12]
  402e82:	613b      	str	r3, [r7, #16]
	CanMessageReceived.Size = message->size;
  402e84:	687b      	ldr	r3, [r7, #4]
  402e86:	891b      	ldrh	r3, [r3, #8]
  402e88:	b21b      	sxth	r3, r3
  402e8a:	82bb      	strh	r3, [r7, #20]
	WriteMessage(&CanMessageReceived);
  402e8c:	f107 0310 	add.w	r3, r7, #16
  402e90:	4618      	mov	r0, r3
  402e92:	4b03      	ldr	r3, [pc, #12]	; (402ea0 <message_received+0xb8>)
  402e94:	4798      	blx	r3
 }
  402e96:	bf00      	nop
  402e98:	3718      	adds	r7, #24
  402e9a:	46bd      	mov	sp, r7
  402e9c:	bd80      	pop	{r7, pc}
  402e9e:	bf00      	nop
  402ea0:	00401a3d 	.word	0x00401a3d

00402ea4 <NVIC_EnableIRQ>:
{
  402ea4:	b480      	push	{r7}
  402ea6:	b083      	sub	sp, #12
  402ea8:	af00      	add	r7, sp, #0
  402eaa:	4603      	mov	r3, r0
  402eac:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  402eae:	4909      	ldr	r1, [pc, #36]	; (402ed4 <NVIC_EnableIRQ+0x30>)
  402eb0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402eb4:	095b      	lsrs	r3, r3, #5
  402eb6:	79fa      	ldrb	r2, [r7, #7]
  402eb8:	f002 021f 	and.w	r2, r2, #31
  402ebc:	2001      	movs	r0, #1
  402ebe:	fa00 f202 	lsl.w	r2, r0, r2
  402ec2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402ec6:	bf00      	nop
  402ec8:	370c      	adds	r7, #12
  402eca:	46bd      	mov	sp, r7
  402ecc:	f85d 7b04 	ldr.w	r7, [sp], #4
  402ed0:	4770      	bx	lr
  402ed2:	bf00      	nop
  402ed4:	e000e100 	.word	0xe000e100

00402ed8 <NVIC_DisableIRQ>:
{
  402ed8:	b480      	push	{r7}
  402eda:	b083      	sub	sp, #12
  402edc:	af00      	add	r7, sp, #0
  402ede:	4603      	mov	r3, r0
  402ee0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  402ee2:	4909      	ldr	r1, [pc, #36]	; (402f08 <NVIC_DisableIRQ+0x30>)
  402ee4:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402ee8:	095b      	lsrs	r3, r3, #5
  402eea:	79fa      	ldrb	r2, [r7, #7]
  402eec:	f002 021f 	and.w	r2, r2, #31
  402ef0:	2001      	movs	r0, #1
  402ef2:	fa00 f202 	lsl.w	r2, r0, r2
  402ef6:	3320      	adds	r3, #32
  402ef8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402efc:	bf00      	nop
  402efe:	370c      	adds	r7, #12
  402f00:	46bd      	mov	sp, r7
  402f02:	f85d 7b04 	ldr.w	r7, [sp], #4
  402f06:	4770      	bx	lr
  402f08:	e000e100 	.word	0xe000e100

00402f0c <NVIC_SetPriority>:
{
  402f0c:	b480      	push	{r7}
  402f0e:	b083      	sub	sp, #12
  402f10:	af00      	add	r7, sp, #0
  402f12:	4603      	mov	r3, r0
  402f14:	6039      	str	r1, [r7, #0]
  402f16:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  402f18:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402f1c:	2b00      	cmp	r3, #0
  402f1e:	da0b      	bge.n	402f38 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  402f20:	490d      	ldr	r1, [pc, #52]	; (402f58 <NVIC_SetPriority+0x4c>)
  402f22:	79fb      	ldrb	r3, [r7, #7]
  402f24:	f003 030f 	and.w	r3, r3, #15
  402f28:	3b04      	subs	r3, #4
  402f2a:	683a      	ldr	r2, [r7, #0]
  402f2c:	b2d2      	uxtb	r2, r2
  402f2e:	0112      	lsls	r2, r2, #4
  402f30:	b2d2      	uxtb	r2, r2
  402f32:	440b      	add	r3, r1
  402f34:	761a      	strb	r2, [r3, #24]
}
  402f36:	e009      	b.n	402f4c <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  402f38:	4908      	ldr	r1, [pc, #32]	; (402f5c <NVIC_SetPriority+0x50>)
  402f3a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402f3e:	683a      	ldr	r2, [r7, #0]
  402f40:	b2d2      	uxtb	r2, r2
  402f42:	0112      	lsls	r2, r2, #4
  402f44:	b2d2      	uxtb	r2, r2
  402f46:	440b      	add	r3, r1
  402f48:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  402f4c:	bf00      	nop
  402f4e:	370c      	adds	r7, #12
  402f50:	46bd      	mov	sp, r7
  402f52:	f85d 7b04 	ldr.w	r7, [sp], #4
  402f56:	4770      	bx	lr
  402f58:	e000ed00 	.word	0xe000ed00
  402f5c:	e000e100 	.word	0xe000e100

00402f60 <sysclk_enable_peripheral_clock>:
{
  402f60:	b580      	push	{r7, lr}
  402f62:	b082      	sub	sp, #8
  402f64:	af00      	add	r7, sp, #0
  402f66:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  402f68:	6878      	ldr	r0, [r7, #4]
  402f6a:	4b03      	ldr	r3, [pc, #12]	; (402f78 <sysclk_enable_peripheral_clock+0x18>)
  402f6c:	4798      	blx	r3
}
  402f6e:	bf00      	nop
  402f70:	3708      	adds	r7, #8
  402f72:	46bd      	mov	sp, r7
  402f74:	bd80      	pop	{r7, pc}
  402f76:	bf00      	nop
  402f78:	0040823d 	.word	0x0040823d

00402f7c <sysclk_disable_peripheral_clock>:
 * \brief Disable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_disable_peripheral_clock(uint32_t ul_id)
{
  402f7c:	b580      	push	{r7, lr}
  402f7e:	b082      	sub	sp, #8
  402f80:	af00      	add	r7, sp, #0
  402f82:	6078      	str	r0, [r7, #4]
	pmc_disable_periph_clk(ul_id);
  402f84:	6878      	ldr	r0, [r7, #4]
  402f86:	4b03      	ldr	r3, [pc, #12]	; (402f94 <sysclk_disable_peripheral_clock+0x18>)
  402f88:	4798      	blx	r3
}
  402f8a:	bf00      	nop
  402f8c:	3708      	adds	r7, #8
  402f8e:	46bd      	mov	sp, r7
  402f90:	bd80      	pop	{r7, pc}
  402f92:	bf00      	nop
  402f94:	004082c1 	.word	0x004082c1

00402f98 <ioport_set_pin_level>:
{
  402f98:	b480      	push	{r7}
  402f9a:	b08b      	sub	sp, #44	; 0x2c
  402f9c:	af00      	add	r7, sp, #0
  402f9e:	6078      	str	r0, [r7, #4]
  402fa0:	460b      	mov	r3, r1
  402fa2:	70fb      	strb	r3, [r7, #3]
  402fa4:	687b      	ldr	r3, [r7, #4]
  402fa6:	627b      	str	r3, [r7, #36]	; 0x24
  402fa8:	78fb      	ldrb	r3, [r7, #3]
  402faa:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  402fae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402fb0:	61fb      	str	r3, [r7, #28]
  402fb2:	69fb      	ldr	r3, [r7, #28]
  402fb4:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  402fb6:	69bb      	ldr	r3, [r7, #24]
  402fb8:	095b      	lsrs	r3, r3, #5
  402fba:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  402fbc:	697b      	ldr	r3, [r7, #20]
  402fbe:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402fc2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402fc6:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  402fc8:	613b      	str	r3, [r7, #16]
	if (level) {
  402fca:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  402fce:	2b00      	cmp	r3, #0
  402fd0:	d009      	beq.n	402fe6 <ioport_set_pin_level+0x4e>
  402fd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402fd4:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  402fd6:	68fb      	ldr	r3, [r7, #12]
  402fd8:	f003 031f 	and.w	r3, r3, #31
  402fdc:	2201      	movs	r2, #1
  402fde:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  402fe0:	693b      	ldr	r3, [r7, #16]
  402fe2:	631a      	str	r2, [r3, #48]	; 0x30
}
  402fe4:	e008      	b.n	402ff8 <ioport_set_pin_level+0x60>
  402fe6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402fe8:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  402fea:	68bb      	ldr	r3, [r7, #8]
  402fec:	f003 031f 	and.w	r3, r3, #31
  402ff0:	2201      	movs	r2, #1
  402ff2:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  402ff4:	693b      	ldr	r3, [r7, #16]
  402ff6:	635a      	str	r2, [r3, #52]	; 0x34
  402ff8:	bf00      	nop
  402ffa:	372c      	adds	r7, #44	; 0x2c
  402ffc:	46bd      	mov	sp, r7
  402ffe:	f85d 7b04 	ldr.w	r7, [sp], #4
  403002:	4770      	bx	lr

00403004 <ioport_get_pin_level>:
{
  403004:	b480      	push	{r7}
  403006:	b089      	sub	sp, #36	; 0x24
  403008:	af00      	add	r7, sp, #0
  40300a:	6078      	str	r0, [r7, #4]
  40300c:	687b      	ldr	r3, [r7, #4]
  40300e:	61fb      	str	r3, [r7, #28]
  403010:	69fb      	ldr	r3, [r7, #28]
  403012:	61bb      	str	r3, [r7, #24]
  403014:	69bb      	ldr	r3, [r7, #24]
  403016:	617b      	str	r3, [r7, #20]
	return pin >> 5;
  403018:	697b      	ldr	r3, [r7, #20]
  40301a:	095b      	lsrs	r3, r3, #5
  40301c:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40301e:	693b      	ldr	r3, [r7, #16]
  403020:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403024:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403028:	025b      	lsls	r3, r3, #9
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  40302a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  40302c:	69fb      	ldr	r3, [r7, #28]
  40302e:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  403030:	68fb      	ldr	r3, [r7, #12]
  403032:	f003 031f 	and.w	r3, r3, #31
  403036:	2101      	movs	r1, #1
  403038:	fa01 f303 	lsl.w	r3, r1, r3
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  40303c:	4013      	ands	r3, r2
  40303e:	2b00      	cmp	r3, #0
  403040:	bf14      	ite	ne
  403042:	2301      	movne	r3, #1
  403044:	2300      	moveq	r3, #0
  403046:	b2db      	uxtb	r3, r3
}
  403048:	4618      	mov	r0, r3
  40304a:	3724      	adds	r7, #36	; 0x24
  40304c:	46bd      	mov	sp, r7
  40304e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403052:	4770      	bx	lr

00403054 <VPWEnable>:

static void VPWNetworkMessageStartDetect(const uint32_t id, const uint32_t index);


void VPWEnable()
{
  403054:	b590      	push	{r4, r7, lr}
  403056:	b083      	sub	sp, #12
  403058:	af02      	add	r7, sp, #8
	sysclk_enable_peripheral_clock(VPW_TX_TIMER_ID);
  40305a:	2015      	movs	r0, #21
  40305c:	4b1d      	ldr	r3, [pc, #116]	; (4030d4 <VPWEnable+0x80>)
  40305e:	4798      	blx	r3
	sysclk_enable_peripheral_clock(VPW_RX_TIMER_ID);
  403060:	2016      	movs	r0, #22
  403062:	4b1c      	ldr	r3, [pc, #112]	; (4030d4 <VPWEnable+0x80>)
  403064:	4798      	blx	r3
	sysclk_enable_peripheral_clock(VPW_PIO_CHANNEL_ID);
  403066:	2009      	movs	r0, #9
  403068:	4b1a      	ldr	r3, [pc, #104]	; (4030d4 <VPWEnable+0x80>)
  40306a:	4798      	blx	r3
	
	pio_set_input(VPW_PIO_CHANNEL,J1850_VPW_RX,PIO_DEFAULT);
  40306c:	2200      	movs	r2, #0
  40306e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  403072:	4819      	ldr	r0, [pc, #100]	; (4030d8 <VPWEnable+0x84>)
  403074:	4b19      	ldr	r3, [pc, #100]	; (4030dc <VPWEnable+0x88>)
  403076:	4798      	blx	r3
	pio_handler_set(VPW_PIO_CHANNEL, VPW_PIO_CHANNEL_ID, J1850_VPW_RX, PIO_IT_FALL_EDGE, VPWNetworkMessageStartDetect);
  403078:	4b19      	ldr	r3, [pc, #100]	; (4030e0 <VPWEnable+0x8c>)
  40307a:	9300      	str	r3, [sp, #0]
  40307c:	2350      	movs	r3, #80	; 0x50
  40307e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  403082:	2109      	movs	r1, #9
  403084:	4814      	ldr	r0, [pc, #80]	; (4030d8 <VPWEnable+0x84>)
  403086:	4c17      	ldr	r4, [pc, #92]	; (4030e4 <VPWEnable+0x90>)
  403088:	47a0      	blx	r4
	pio_enable_interrupt(PIOA, J1850_VPW_RX);
  40308a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  40308e:	4812      	ldr	r0, [pc, #72]	; (4030d8 <VPWEnable+0x84>)
  403090:	4b15      	ldr	r3, [pc, #84]	; (4030e8 <VPWEnable+0x94>)
  403092:	4798      	blx	r3
	
	tc_stop(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  403094:	2101      	movs	r1, #1
  403096:	4815      	ldr	r0, [pc, #84]	; (4030ec <VPWEnable+0x98>)
  403098:	4b15      	ldr	r3, [pc, #84]	; (4030f0 <VPWEnable+0x9c>)
  40309a:	4798      	blx	r3
	tc_init(
  40309c:	2201      	movs	r2, #1
  40309e:	2101      	movs	r1, #1
  4030a0:	4812      	ldr	r0, [pc, #72]	; (4030ec <VPWEnable+0x98>)
  4030a2:	4b14      	ldr	r3, [pc, #80]	; (4030f4 <VPWEnable+0xa0>)
  4030a4:	4798      	blx	r3
	VPW_TIMER,
	VPW_RX_TIMER_CHANNEL,
	TC_CMR_TCCLKS_TIMER_CLOCK2|
	TC_CMR_BURST_NONE 
	);
	tc_start(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  4030a6:	2101      	movs	r1, #1
  4030a8:	4810      	ldr	r0, [pc, #64]	; (4030ec <VPWEnable+0x98>)
  4030aa:	4b13      	ldr	r3, [pc, #76]	; (4030f8 <VPWEnable+0xa4>)
  4030ac:	4798      	blx	r3
	
	NVIC_EnableIRQ(PIOA_IRQn);
  4030ae:	2009      	movs	r0, #9
  4030b0:	4b12      	ldr	r3, [pc, #72]	; (4030fc <VPWEnable+0xa8>)
  4030b2:	4798      	blx	r3
	NVIC_SetPriority(PIOA_IRQn,5);
  4030b4:	2105      	movs	r1, #5
  4030b6:	2009      	movs	r0, #9
  4030b8:	4b11      	ldr	r3, [pc, #68]	; (403100 <VPWEnable+0xac>)
  4030ba:	4798      	blx	r3
	GO_PASSIVE
  4030bc:	2100      	movs	r1, #0
  4030be:	200f      	movs	r0, #15
  4030c0:	4b10      	ldr	r3, [pc, #64]	; (403104 <VPWEnable+0xb0>)
  4030c2:	4798      	blx	r3
	VPWEnter1xMode();
  4030c4:	4b10      	ldr	r3, [pc, #64]	; (403108 <VPWEnable+0xb4>)
  4030c6:	4798      	blx	r3
	VPWInitalizeCRCLUT();
  4030c8:	4b10      	ldr	r3, [pc, #64]	; (40310c <VPWEnable+0xb8>)
  4030ca:	4798      	blx	r3
}
  4030cc:	bf00      	nop
  4030ce:	3704      	adds	r7, #4
  4030d0:	46bd      	mov	sp, r7
  4030d2:	bd90      	pop	{r4, r7, pc}
  4030d4:	00402f61 	.word	0x00402f61
  4030d8:	400e0e00 	.word	0x400e0e00
  4030dc:	0040748d 	.word	0x0040748d
  4030e0:	0040314d 	.word	0x0040314d
  4030e4:	004051d5 	.word	0x004051d5
  4030e8:	00407579 	.word	0x00407579
  4030ec:	40090000 	.word	0x40090000
  4030f0:	00401579 	.word	0x00401579
  4030f4:	00401501 	.word	0x00401501
  4030f8:	00401557 	.word	0x00401557
  4030fc:	00402ea5 	.word	0x00402ea5
  403100:	00402f0d 	.word	0x00402f0d
  403104:	00402f99 	.word	0x00402f99
  403108:	004035f1 	.word	0x004035f1
  40310c:	004036e1 	.word	0x004036e1

00403110 <VPWDisable>:

void VPWDisable()
{
  403110:	b580      	push	{r7, lr}
  403112:	af00      	add	r7, sp, #0
	pio_disable_interrupt(PIOA, J1850_VPW_RX);
  403114:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  403118:	4808      	ldr	r0, [pc, #32]	; (40313c <VPWDisable+0x2c>)
  40311a:	4b09      	ldr	r3, [pc, #36]	; (403140 <VPWDisable+0x30>)
  40311c:	4798      	blx	r3
	NVIC_DisableIRQ(PIOA_IRQn);
  40311e:	2009      	movs	r0, #9
  403120:	4b08      	ldr	r3, [pc, #32]	; (403144 <VPWDisable+0x34>)
  403122:	4798      	blx	r3
	sysclk_disable_peripheral_clock(VPW_TX_TIMER_ID);
  403124:	2015      	movs	r0, #21
  403126:	4b08      	ldr	r3, [pc, #32]	; (403148 <VPWDisable+0x38>)
  403128:	4798      	blx	r3
	sysclk_disable_peripheral_clock(VPW_RX_TIMER_ID);
  40312a:	2016      	movs	r0, #22
  40312c:	4b06      	ldr	r3, [pc, #24]	; (403148 <VPWDisable+0x38>)
  40312e:	4798      	blx	r3
	sysclk_disable_peripheral_clock(VPW_PIO_CHANNEL_ID);
  403130:	2009      	movs	r0, #9
  403132:	4b05      	ldr	r3, [pc, #20]	; (403148 <VPWDisable+0x38>)
  403134:	4798      	blx	r3
	
}
  403136:	bf00      	nop
  403138:	bd80      	pop	{r7, pc}
  40313a:	bf00      	nop
  40313c:	400e0e00 	.word	0x400e0e00
  403140:	00407595 	.word	0x00407595
  403144:	00402ed9 	.word	0x00402ed9
  403148:	00402f7d 	.word	0x00402f7d

0040314c <VPWNetworkMessageStartDetect>:

static void VPWNetworkMessageStartDetect(const uint32_t id, const uint32_t index)
{
  40314c:	b580      	push	{r7, lr}
  40314e:	b082      	sub	sp, #8
  403150:	af00      	add	r7, sp, #0
  403152:	6078      	str	r0, [r7, #4]
  403154:	6039      	str	r1, [r7, #0]
	if(id == VPW_PIO_CHANNEL_ID && index == J1850_VPW_RX)
  403156:	687b      	ldr	r3, [r7, #4]
  403158:	2b09      	cmp	r3, #9
  40315a:	d114      	bne.n	403186 <VPWNetworkMessageStartDetect+0x3a>
  40315c:	683b      	ldr	r3, [r7, #0]
  40315e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  403162:	d110      	bne.n	403186 <VPWNetworkMessageStartDetect+0x3a>
  __ASM volatile ("cpsid i" : : : "memory");
  403164:	b672      	cpsid	i
  403166:	f3bf 8f5f 	dmb	sy
	{
		//Possible SOF, lets check that!
		cpu_irq_disable();
  40316a:	4b09      	ldr	r3, [pc, #36]	; (403190 <VPWNetworkMessageStartDetect+0x44>)
  40316c:	2200      	movs	r2, #0
  40316e:	701a      	strb	r2, [r3, #0]
		VPWReceiveNetworkMessage(VehicleMessageBuffer, VPW_BUF_SIZE);	
  403170:	f241 3188 	movw	r1, #5000	; 0x1388
  403174:	4807      	ldr	r0, [pc, #28]	; (403194 <VPWNetworkMessageStartDetect+0x48>)
  403176:	4b08      	ldr	r3, [pc, #32]	; (403198 <VPWNetworkMessageStartDetect+0x4c>)
  403178:	4798      	blx	r3
		cpu_irq_enable();
  40317a:	4b05      	ldr	r3, [pc, #20]	; (403190 <VPWNetworkMessageStartDetect+0x44>)
  40317c:	2201      	movs	r2, #1
  40317e:	701a      	strb	r2, [r3, #0]
  403180:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  403184:	b662      	cpsie	i
	}	
}
  403186:	bf00      	nop
  403188:	3708      	adds	r7, #8
  40318a:	46bd      	mov	sp, r7
  40318c:	bd80      	pop	{r7, pc}
  40318e:	bf00      	nop
  403190:	200001aa 	.word	0x200001aa
  403194:	200031d8 	.word	0x200031d8
  403198:	0040319d 	.word	0x0040319d

0040319c <VPWReceiveNetworkMessage>:

void VPWReceiveNetworkMessage(unsigned char *mbuf, uint32_t MaxBytes)
{
  40319c:	b590      	push	{r4, r7, lr}
  40319e:	b093      	sub	sp, #76	; 0x4c
  4031a0:	af00      	add	r7, sp, #0
  4031a2:	6078      	str	r0, [r7, #4]
  4031a4:	6039      	str	r1, [r7, #0]
	uint32_t TimerValue = 0;
  4031a6:	2300      	movs	r3, #0
  4031a8:	63bb      	str	r3, [r7, #56]	; 0x38
	uint32_t ByteCount = 0;
  4031aa:	2300      	movs	r3, #0
  4031ac:	647b      	str	r3, [r7, #68]	; 0x44
	uint8_t CurrentByte = 0;
  4031ae:	2300      	movs	r3, #0
  4031b0:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
	uint8_t ShiftValue = 0;
  4031b4:	2300      	movs	r3, #0
  4031b6:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
	uint32_t BusState = 0;
  4031ba:	2300      	movs	r3, #0
  4031bc:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t *MessageBufferStartAddress = mbuf;
  4031be:	687b      	ldr	r3, [r7, #4]
  4031c0:	633b      	str	r3, [r7, #48]	; 0x30
	Message_t NetworkMessage;
	//Advance the buffer by 4 to leave room for KAVI Header
	mbuf += 5;
  4031c2:	687b      	ldr	r3, [r7, #4]
  4031c4:	3305      	adds	r3, #5
  4031c6:	607b      	str	r3, [r7, #4]

	//Start the timer
	tc_start(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  4031c8:	2101      	movs	r1, #1
  4031ca:	4893      	ldr	r0, [pc, #588]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  4031cc:	4b93      	ldr	r3, [pc, #588]	; (40341c <VPWReceiveNetworkMessage+0x280>)
  4031ce:	4798      	blx	r3

	//Time the possible SOF
	while(CURRENT_BUS_RX_STATE == VPW_RX_ACTIVE)
  4031d0:	e019      	b.n	403206 <VPWReceiveNetworkMessage+0x6a>
	{
		if(tc_read_cv(VPW_TIMER, VPW_RX_TIMER_CHANNEL) > (RX_SOF_MAX / PulseWidthDivisor) )
  4031d2:	2101      	movs	r1, #1
  4031d4:	4890      	ldr	r0, [pc, #576]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  4031d6:	4b92      	ldr	r3, [pc, #584]	; (403420 <VPWReceiveNetworkMessage+0x284>)
  4031d8:	4798      	blx	r3
  4031da:	4601      	mov	r1, r0
  4031dc:	4b91      	ldr	r3, [pc, #580]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  4031de:	681b      	ldr	r3, [r3, #0]
  4031e0:	f640 3228 	movw	r2, #2856	; 0xb28
  4031e4:	fbb2 f3f3 	udiv	r3, r2, r3
  4031e8:	4299      	cmp	r1, r3
  4031ea:	d90c      	bls.n	403206 <VPWReceiveNetworkMessage+0x6a>
		{
			Error_T InvalidLengthByteError;
			InvalidLengthByteError.ThrowerID = NETWORK_MESSAGE;
  4031ec:	23aa      	movs	r3, #170	; 0xaa
  4031ee:	61bb      	str	r3, [r7, #24]
			InvalidLengthByteError.ErrorMajor = VPW_RETURN_CODE_SOF_TOO_LONG_EXCEPTION;
  4031f0:	2303      	movs	r3, #3
  4031f2:	61fb      	str	r3, [r7, #28]
			InvalidLengthByteError.ErrorMinor = ERROR_NO_MINOR_CODE;
  4031f4:	2300      	movs	r3, #0
  4031f6:	623b      	str	r3, [r7, #32]
			ThrowError(&InvalidLengthByteError);
  4031f8:	f107 0318 	add.w	r3, r7, #24
  4031fc:	4618      	mov	r0, r3
  4031fe:	4b8a      	ldr	r3, [pc, #552]	; (403428 <VPWReceiveNetworkMessage+0x28c>)
  403200:	4798      	blx	r3

			return;
  403202:	bf00      	nop
  403204:	e104      	b.n	403410 <VPWReceiveNetworkMessage+0x274>
	while(CURRENT_BUS_RX_STATE == VPW_RX_ACTIVE)
  403206:	2010      	movs	r0, #16
  403208:	4b88      	ldr	r3, [pc, #544]	; (40342c <VPWReceiveNetworkMessage+0x290>)
  40320a:	4798      	blx	r3
  40320c:	4603      	mov	r3, r0
  40320e:	f083 0301 	eor.w	r3, r3, #1
  403212:	b2db      	uxtb	r3, r3
  403214:	2b00      	cmp	r3, #0
  403216:	d1dc      	bne.n	4031d2 <VPWReceiveNetworkMessage+0x36>
		}
	}
	//Check possible SOF Length and handle accordingly
	TimerValue = tc_read_cv(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  403218:	2101      	movs	r1, #1
  40321a:	487f      	ldr	r0, [pc, #508]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  40321c:	4b80      	ldr	r3, [pc, #512]	; (403420 <VPWReceiveNetworkMessage+0x284>)
  40321e:	4798      	blx	r3
  403220:	63b8      	str	r0, [r7, #56]	; 0x38

	if( TimerValue > (RX_SOF_MIN/ PulseWidthDivisor))
  403222:	4b80      	ldr	r3, [pc, #512]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  403224:	681b      	ldr	r3, [r3, #0]
  403226:	f44f 62d2 	mov.w	r2, #1680	; 0x690
  40322a:	fbb2 f2f3 	udiv	r2, r2, r3
  40322e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  403230:	429a      	cmp	r2, r3
  403232:	f080 80ea 	bcs.w	40340a <VPWReceiveNetworkMessage+0x26e>
	{
		//It was an SOF, start receiving the message
		while (ByteCount < MaxBytes)
  403236:	e086      	b.n	403346 <VPWReceiveNetworkMessage+0x1aa>
		{
			//Reset current byte
			CurrentByte = 0;
  403238:	2300      	movs	r3, #0
  40323a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
			for(int bitNumber = 7; bitNumber >= 0; bitNumber--)
  40323e:	2307      	movs	r3, #7
  403240:	63fb      	str	r3, [r7, #60]	; 0x3c
  403242:	e074      	b.n	40332e <VPWReceiveNetworkMessage+0x192>
			{
				//Log bus state and start timing the state
				BusState = CURRENT_BUS_RX_STATE;
  403244:	2010      	movs	r0, #16
  403246:	4b79      	ldr	r3, [pc, #484]	; (40342c <VPWReceiveNetworkMessage+0x290>)
  403248:	4798      	blx	r3
  40324a:	4603      	mov	r3, r0
  40324c:	637b      	str	r3, [r7, #52]	; 0x34
				tc_start(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  40324e:	2101      	movs	r1, #1
  403250:	4871      	ldr	r0, [pc, #452]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  403252:	4b72      	ldr	r3, [pc, #456]	; (40341c <VPWReceiveNetworkMessage+0x280>)
  403254:	4798      	blx	r3

				while(CURRENT_BUS_RX_STATE == BusState)
  403256:	e00c      	b.n	403272 <VPWReceiveNetworkMessage+0xd6>
				{
					//Wait until the bus state changes, if we wait longer than EOD then were done!
					if(tc_read_cv(VPW_TIMER, VPW_RX_TIMER_CHANNEL) > (RX_EOD_MIN/ PulseWidthDivisor) )
  403258:	2101      	movs	r1, #1
  40325a:	486f      	ldr	r0, [pc, #444]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  40325c:	4b70      	ldr	r3, [pc, #448]	; (403420 <VPWReceiveNetworkMessage+0x284>)
  40325e:	4798      	blx	r3
  403260:	4601      	mov	r1, r0
  403262:	4b70      	ldr	r3, [pc, #448]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  403264:	681b      	ldr	r3, [r3, #0]
  403266:	f44f 6201 	mov.w	r2, #2064	; 0x810
  40326a:	fbb2 f3f3 	udiv	r3, r2, r3
  40326e:	4299      	cmp	r1, r3
  403270:	d86f      	bhi.n	403352 <VPWReceiveNetworkMessage+0x1b6>
				while(CURRENT_BUS_RX_STATE == BusState)
  403272:	2010      	movs	r0, #16
  403274:	4b6d      	ldr	r3, [pc, #436]	; (40342c <VPWReceiveNetworkMessage+0x290>)
  403276:	4798      	blx	r3
  403278:	4603      	mov	r3, r0
  40327a:	461a      	mov	r2, r3
  40327c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40327e:	429a      	cmp	r2, r3
  403280:	d0ea      	beq.n	403258 <VPWReceiveNetworkMessage+0xbc>
						goto HitEOD;
					}
				}

				//Get pulse width
				TimerValue = tc_read_cv(VPW_TIMER, VPW_RX_TIMER_CHANNEL);
  403282:	2101      	movs	r1, #1
  403284:	4864      	ldr	r0, [pc, #400]	; (403418 <VPWReceiveNetworkMessage+0x27c>)
  403286:	4b66      	ldr	r3, [pc, #408]	; (403420 <VPWReceiveNetworkMessage+0x284>)
  403288:	4798      	blx	r3
  40328a:	63b8      	str	r0, [r7, #56]	; 0x38
				//Assign a value based on the length of the pulse
				if(TimerValue >= (RX_SHORT_MIN/ PulseWidthDivisor) && TimerValue <= (RX_SHORT_MAX/ PulseWidthDivisor))
  40328c:	4b65      	ldr	r3, [pc, #404]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  40328e:	681b      	ldr	r3, [r3, #0]
  403290:	2200      	movs	r2, #0
  403292:	fbb2 f2f3 	udiv	r2, r2, r3
  403296:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  403298:	429a      	cmp	r2, r3
  40329a:	d80c      	bhi.n	4032b6 <VPWReceiveNetworkMessage+0x11a>
  40329c:	4b61      	ldr	r3, [pc, #388]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  40329e:	681b      	ldr	r3, [r3, #0]
  4032a0:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
  4032a4:	fbb2 f2f3 	udiv	r2, r2, r3
  4032a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4032aa:	429a      	cmp	r2, r3
  4032ac:	d303      	bcc.n	4032b6 <VPWReceiveNetworkMessage+0x11a>
				{
					ShiftValue = 1;
  4032ae:	2301      	movs	r3, #1
  4032b0:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  4032b4:	e020      	b.n	4032f8 <VPWReceiveNetworkMessage+0x15c>
				}else if(TimerValue >= (RX_LONG_MIN/ PulseWidthDivisor) && TimerValue <= (RX_LONG_MAX/ PulseWidthDivisor))
  4032b6:	4b5b      	ldr	r3, [pc, #364]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  4032b8:	681b      	ldr	r3, [r3, #0]
  4032ba:	f240 42bc 	movw	r2, #1212	; 0x4bc
  4032be:	fbb2 f2f3 	udiv	r2, r2, r3
  4032c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4032c4:	429a      	cmp	r2, r3
  4032c6:	d80c      	bhi.n	4032e2 <VPWReceiveNetworkMessage+0x146>
  4032c8:	4b56      	ldr	r3, [pc, #344]	; (403424 <VPWReceiveNetworkMessage+0x288>)
  4032ca:	681b      	ldr	r3, [r3, #0]
  4032cc:	f241 7270 	movw	r2, #6000	; 0x1770
  4032d0:	fbb2 f2f3 	udiv	r2, r2, r3
  4032d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4032d6:	429a      	cmp	r2, r3
  4032d8:	d303      	bcc.n	4032e2 <VPWReceiveNetworkMessage+0x146>
				{
					ShiftValue = 0;
  4032da:	2300      	movs	r3, #0
  4032dc:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  4032e0:	e00a      	b.n	4032f8 <VPWReceiveNetworkMessage+0x15c>
				}
				else
				{
					Error_T InvalidLengthByteError;
					InvalidLengthByteError.ThrowerID = NETWORK_MESSAGE;
  4032e2:	23aa      	movs	r3, #170	; 0xaa
  4032e4:	60fb      	str	r3, [r7, #12]
					InvalidLengthByteError.ErrorMajor = VPW_RETURN_CODE_PULSE_TIMING_UNKOWN;
  4032e6:	2307      	movs	r3, #7
  4032e8:	613b      	str	r3, [r7, #16]
					InvalidLengthByteError.ErrorMinor = ERROR_NO_MINOR_CODE;
  4032ea:	2300      	movs	r3, #0
  4032ec:	617b      	str	r3, [r7, #20]
					ThrowError(&InvalidLengthByteError);
  4032ee:	f107 030c 	add.w	r3, r7, #12
  4032f2:	4618      	mov	r0, r3
  4032f4:	4b4c      	ldr	r3, [pc, #304]	; (403428 <VPWReceiveNetworkMessage+0x28c>)
  4032f6:	4798      	blx	r3
				}
				//Flip if assumed wrong state above
				if(BusState)
  4032f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4032fa:	2b00      	cmp	r3, #0
  4032fc:	d008      	beq.n	403310 <VPWReceiveNetworkMessage+0x174>
				{
					ShiftValue = !ShiftValue;
  4032fe:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
  403302:	2b00      	cmp	r3, #0
  403304:	bf0c      	ite	eq
  403306:	2301      	moveq	r3, #1
  403308:	2300      	movne	r3, #0
  40330a:	b2db      	uxtb	r3, r3
  40330c:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
				}
				//Shift the value into the current byte
				CurrentByte |= (ShiftValue << bitNumber);
  403310:	f897 2042 	ldrb.w	r2, [r7, #66]	; 0x42
  403314:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  403316:	fa02 f303 	lsl.w	r3, r2, r3
  40331a:	b25a      	sxtb	r2, r3
  40331c:	f997 3043 	ldrsb.w	r3, [r7, #67]	; 0x43
  403320:	4313      	orrs	r3, r2
  403322:	b25b      	sxtb	r3, r3
  403324:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
			for(int bitNumber = 7; bitNumber >= 0; bitNumber--)
  403328:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40332a:	3b01      	subs	r3, #1
  40332c:	63fb      	str	r3, [r7, #60]	; 0x3c
  40332e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  403330:	2b00      	cmp	r3, #0
  403332:	da87      	bge.n	403244 <VPWReceiveNetworkMessage+0xa8>
			}
			//Add the current byte to the main recieve buffer and increment the byte counter.
			*mbuf++ = CurrentByte;
  403334:	687b      	ldr	r3, [r7, #4]
  403336:	1c5a      	adds	r2, r3, #1
  403338:	607a      	str	r2, [r7, #4]
  40333a:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
  40333e:	701a      	strb	r2, [r3, #0]
			ByteCount++;
  403340:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  403342:	3301      	adds	r3, #1
  403344:	647b      	str	r3, [r7, #68]	; 0x44
		while (ByteCount < MaxBytes)
  403346:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  403348:	683b      	ldr	r3, [r7, #0]
  40334a:	429a      	cmp	r2, r3
  40334c:	f4ff af74 	bcc.w	403238 <VPWReceiveNetworkMessage+0x9c>
  403350:	e000      	b.n	403354 <VPWReceiveNetworkMessage+0x1b8>
						goto HitEOD;
  403352:	bf00      	nop
		return;
	}

 HitEOD:
	 //Reset buffer pointer to beginning
	 mbuf = MessageBufferStartAddress;
  403354:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  403356:	607b      	str	r3, [r7, #4]
	 //Check the CRCs to ensure we got a good message
	 char crc = mbuf[ByteCount+4];
  403358:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40335a:	3304      	adds	r3, #4
  40335c:	687a      	ldr	r2, [r7, #4]
  40335e:	4413      	add	r3, r2
  403360:	781b      	ldrb	r3, [r3, #0]
  403362:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	 char actualCRC = VPWFastCRC(mbuf+5, ByteCount-1);
  403366:	687b      	ldr	r3, [r7, #4]
  403368:	1d5a      	adds	r2, r3, #5
  40336a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40336c:	3b01      	subs	r3, #1
  40336e:	4619      	mov	r1, r3
  403370:	4610      	mov	r0, r2
  403372:	4b2f      	ldr	r3, [pc, #188]	; (403430 <VPWReceiveNetworkMessage+0x294>)
  403374:	4798      	blx	r3
  403376:	4603      	mov	r3, r0
  403378:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	 if(mbuf[ByteCount+4] != VPWFastCRC(mbuf+5, ByteCount-1))
  40337c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40337e:	3304      	adds	r3, #4
  403380:	687a      	ldr	r2, [r7, #4]
  403382:	4413      	add	r3, r2
  403384:	781c      	ldrb	r4, [r3, #0]
  403386:	687b      	ldr	r3, [r7, #4]
  403388:	1d5a      	adds	r2, r3, #5
  40338a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40338c:	3b01      	subs	r3, #1
  40338e:	4619      	mov	r1, r3
  403390:	4610      	mov	r0, r2
  403392:	4b27      	ldr	r3, [pc, #156]	; (403430 <VPWReceiveNetworkMessage+0x294>)
  403394:	4798      	blx	r3
  403396:	4603      	mov	r3, r0
  403398:	429c      	cmp	r4, r3
  40339a:	d138      	bne.n	40340e <VPWReceiveNetworkMessage+0x272>
		// uint8_t errrtn[] = {START_BYTE, 0x00,0x03,ERROR_RESPONSE, 0x00, VPW_RETURN_CODE_DATA_EXCEPTION};
		// WriteBufferOut(errrtn,6);
		 return;
	 }
	 
	ui_vehicle_vpw_rx_notify_off();
  40339c:	4b25      	ldr	r3, [pc, #148]	; (403434 <VPWReceiveNetworkMessage+0x298>)
  40339e:	4798      	blx	r3
	
	if(RunFilters(mbuf+4, ByteCount, NULL, NULL))
  4033a0:	687b      	ldr	r3, [r7, #4]
  4033a2:	1d18      	adds	r0, r3, #4
  4033a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4033a6:	b299      	uxth	r1, r3
  4033a8:	2300      	movs	r3, #0
  4033aa:	2200      	movs	r2, #0
  4033ac:	4c22      	ldr	r4, [pc, #136]	; (403438 <VPWReceiveNetworkMessage+0x29c>)
  4033ae:	47a0      	blx	r4
  4033b0:	4603      	mov	r3, r0
  4033b2:	2b00      	cmp	r3, #0
  4033b4:	d02c      	beq.n	403410 <VPWReceiveNetworkMessage+0x274>
	{
		//It passed the filters prep message with KAVI header
		
		//Increment ByteCount to account for command byte and network byte
		ByteCount++;
  4033b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4033b8:	3301      	adds	r3, #1
  4033ba:	647b      	str	r3, [r7, #68]	; 0x44
		ByteCount++;
  4033bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4033be:	3301      	adds	r3, #1
  4033c0:	647b      	str	r3, [r7, #68]	; 0x44
		
		//Add KAVI header
		mbuf[0] = 0x02;
  4033c2:	687b      	ldr	r3, [r7, #4]
  4033c4:	2202      	movs	r2, #2
  4033c6:	701a      	strb	r2, [r3, #0]
		mbuf[1] = (ByteCount >> 8) & 0xFF;
  4033c8:	687b      	ldr	r3, [r7, #4]
  4033ca:	3301      	adds	r3, #1
  4033cc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  4033ce:	0a12      	lsrs	r2, r2, #8
  4033d0:	b2d2      	uxtb	r2, r2
  4033d2:	701a      	strb	r2, [r3, #0]
		mbuf[2] = (ByteCount & 0xFF);
  4033d4:	687b      	ldr	r3, [r7, #4]
  4033d6:	3302      	adds	r3, #2
  4033d8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  4033da:	b2d2      	uxtb	r2, r2
  4033dc:	701a      	strb	r2, [r3, #0]
		mbuf[3] = NETWORK_MESSAGE;
  4033de:	687b      	ldr	r3, [r7, #4]
  4033e0:	3303      	adds	r3, #3
  4033e2:	22aa      	movs	r2, #170	; 0xaa
  4033e4:	701a      	strb	r2, [r3, #0]
		mbuf[4] = 0x01;
  4033e6:	687b      	ldr	r3, [r7, #4]
  4033e8:	3304      	adds	r3, #4
  4033ea:	2201      	movs	r2, #1
  4033ec:	701a      	strb	r2, [r3, #0]
		ByteCount += 3;
  4033ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4033f0:	3303      	adds	r3, #3
  4033f2:	647b      	str	r3, [r7, #68]	; 0x44
		//Send it out USB/BT
		NetworkMessage.buf = MessageBufferStartAddress;
  4033f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4033f6:	627b      	str	r3, [r7, #36]	; 0x24
		NetworkMessage.Size = ByteCount;
  4033f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4033fa:	b21b      	sxth	r3, r3
  4033fc:	853b      	strh	r3, [r7, #40]	; 0x28
		WriteMessage(&NetworkMessage);
  4033fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
  403402:	4618      	mov	r0, r3
  403404:	4b0d      	ldr	r3, [pc, #52]	; (40343c <VPWReceiveNetworkMessage+0x2a0>)
  403406:	4798      	blx	r3
  403408:	e002      	b.n	403410 <VPWReceiveNetworkMessage+0x274>
		return;
  40340a:	bf00      	nop
  40340c:	e000      	b.n	403410 <VPWReceiveNetworkMessage+0x274>
		 return;
  40340e:	bf00      	nop
	}
 }
  403410:	374c      	adds	r7, #76	; 0x4c
  403412:	46bd      	mov	sp, r7
  403414:	bd90      	pop	{r4, r7, pc}
  403416:	bf00      	nop
  403418:	40090000 	.word	0x40090000
  40341c:	00401557 	.word	0x00401557
  403420:	0040159b 	.word	0x0040159b
  403424:	20000178 	.word	0x20000178
  403428:	00401631 	.word	0x00401631
  40342c:	00403005 	.word	0x00403005
  403430:	00403749 	.word	0x00403749
  403434:	00401f7d 	.word	0x00401f7d
  403438:	004021dd 	.word	0x004021dd
  40343c:	00401a3d 	.word	0x00401a3d

00403440 <VPWSendNetworkMessage>:
	 WriteMessage(&NetworkMessage);
}
*/

uint8_t VPWSendNetworkMessage(unsigned char *mbuf, unsigned short n)
{
  403440:	b580      	push	{r7, lr}
  403442:	b084      	sub	sp, #16
  403444:	af00      	add	r7, sp, #0
  403446:	6078      	str	r0, [r7, #4]
  403448:	460b      	mov	r3, r1
  40344a:	807b      	strh	r3, [r7, #2]
	
	pio_disable_interrupt(PIOA, J1850_VPW_RX);
  40344c:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  403450:	485a      	ldr	r0, [pc, #360]	; (4035bc <VPWSendNetworkMessage+0x17c>)
  403452:	4b5b      	ldr	r3, [pc, #364]	; (4035c0 <VPWSendNetworkMessage+0x180>)
  403454:	4798      	blx	r3
	char bits, ch, mask;
	unsigned int period;
	tc_stop(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  403456:	2100      	movs	r1, #0
  403458:	485a      	ldr	r0, [pc, #360]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  40345a:	4b5b      	ldr	r3, [pc, #364]	; (4035c8 <VPWSendNetworkMessage+0x188>)
  40345c:	4798      	blx	r3
	tc_start(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  40345e:	2100      	movs	r1, #0
  403460:	4858      	ldr	r0, [pc, #352]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403462:	4b5a      	ldr	r3, [pc, #360]	; (4035cc <VPWSendNetworkMessage+0x18c>)
  403464:	4798      	blx	r3
	//Append CRC
	char crc = VPWFastCRC(mbuf,n);
  403466:	887b      	ldrh	r3, [r7, #2]
  403468:	4619      	mov	r1, r3
  40346a:	6878      	ldr	r0, [r7, #4]
  40346c:	4b58      	ldr	r3, [pc, #352]	; (4035d0 <VPWSendNetworkMessage+0x190>)
  40346e:	4798      	blx	r3
  403470:	4603      	mov	r3, r0
  403472:	73bb      	strb	r3, [r7, #14]
	mbuf[n] = crc;
  403474:	887b      	ldrh	r3, [r7, #2]
  403476:	687a      	ldr	r2, [r7, #4]
  403478:	4413      	add	r3, r2
  40347a:	7bba      	ldrb	r2, [r7, #14]
  40347c:	701a      	strb	r2, [r3, #0]
	n++;
  40347e:	887b      	ldrh	r3, [r7, #2]
  403480:	3301      	adds	r3, #1
  403482:	807b      	strh	r3, [r7, #2]
	// wait_vpw_idle();
	//Resets timer
	tc_sync_trigger(VPW_TIMER);
  403484:	484f      	ldr	r0, [pc, #316]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403486:	4b53      	ldr	r3, [pc, #332]	; (4035d4 <VPWSendNetworkMessage+0x194>)
  403488:	4798      	blx	r3
	//Go Active on the J1850+ pin
	//ToggleVehicleVPWSend();
	GO_ACTIVE
  40348a:	2101      	movs	r1, #1
  40348c:	200f      	movs	r0, #15
  40348e:	4b52      	ldr	r3, [pc, #328]	; (4035d8 <VPWSendNetworkMessage+0x198>)
  403490:	4798      	blx	r3
	while(tc_read_cv(VPW_TIMER,VPW_TX_TIMER_CHANNEL) < TX_SOF);
  403492:	bf00      	nop
  403494:	2100      	movs	r1, #0
  403496:	484b      	ldr	r0, [pc, #300]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403498:	4b50      	ldr	r3, [pc, #320]	; (4035dc <VPWSendNetworkMessage+0x19c>)
  40349a:	4798      	blx	r3
  40349c:	4603      	mov	r3, r0
  40349e:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
  4034a2:	d3f7      	bcc.n	403494 <VPWSendNetworkMessage+0x54>

	while(n != 0)
  4034a4:	e066      	b.n	403574 <VPWSendNetworkMessage+0x134>
	{
		ui_vehicle_vpw_tx_notify();
  4034a6:	4b4e      	ldr	r3, [pc, #312]	; (4035e0 <VPWSendNetworkMessage+0x1a0>)
  4034a8:	4798      	blx	r3
		n--;
  4034aa:	887b      	ldrh	r3, [r7, #2]
  4034ac:	3b01      	subs	r3, #1
  4034ae:	807b      	strh	r3, [r7, #2]
		ch=*mbuf++;
  4034b0:	687b      	ldr	r3, [r7, #4]
  4034b2:	1c5a      	adds	r2, r3, #1
  4034b4:	607a      	str	r2, [r7, #4]
  4034b6:	781b      	ldrb	r3, [r3, #0]
  4034b8:	737b      	strb	r3, [r7, #13]
		bits = 8;
  4034ba:	2308      	movs	r3, #8
  4034bc:	73fb      	strb	r3, [r7, #15]
		mask = 1;
  4034be:	2301      	movs	r3, #1
  4034c0:	733b      	strb	r3, [r7, #12]
		while(bits)
  4034c2:	e054      	b.n	40356e <VPWSendNetworkMessage+0x12e>
		{
			bits--;
  4034c4:	7bfb      	ldrb	r3, [r7, #15]
  4034c6:	3b01      	subs	r3, #1
  4034c8:	73fb      	strb	r3, [r7, #15]
			if(bits&1)
  4034ca:	7bfb      	ldrb	r3, [r7, #15]
  4034cc:	f003 0301 	and.w	r3, r3, #1
  4034d0:	2b00      	cmp	r3, #0
  4034d2:	d02b      	beq.n	40352c <VPWSendNetworkMessage+0xec>
			{
				//Go passive on the J1850+ pin
				GO_PASSIVE
  4034d4:	2100      	movs	r1, #0
  4034d6:	200f      	movs	r0, #15
  4034d8:	4b3f      	ldr	r3, [pc, #252]	; (4035d8 <VPWSendNetworkMessage+0x198>)
  4034da:	4798      	blx	r3
				tc_sync_trigger(VPW_TIMER);
  4034dc:	4839      	ldr	r0, [pc, #228]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  4034de:	4b3d      	ldr	r3, [pc, #244]	; (4035d4 <VPWSendNetworkMessage+0x194>)
  4034e0:	4798      	blx	r3
				period = ((ch & (mask << bits)) >> bits) ? TX_LONG : TX_SHORT;
  4034e2:	7b7a      	ldrb	r2, [r7, #13]
  4034e4:	7b39      	ldrb	r1, [r7, #12]
  4034e6:	7bfb      	ldrb	r3, [r7, #15]
  4034e8:	fa01 f303 	lsl.w	r3, r1, r3
  4034ec:	401a      	ands	r2, r3
  4034ee:	7bfb      	ldrb	r3, [r7, #15]
  4034f0:	fa42 f303 	asr.w	r3, r2, r3
  4034f4:	2b00      	cmp	r3, #0
  4034f6:	d002      	beq.n	4034fe <VPWSendNetworkMessage+0xbe>
  4034f8:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  4034fc:	e001      	b.n	403502 <VPWSendNetworkMessage+0xc2>
  4034fe:	f44f 7340 	mov.w	r3, #768	; 0x300
  403502:	60bb      	str	r3, [r7, #8]
				while(tc_read_cv(VPW_TIMER,VPW_TX_TIMER_CHANNEL) <= period)
  403504:	e009      	b.n	40351a <VPWSendNetworkMessage+0xda>
				{
					if(IS_VPW_ACTIVE_LEVEL)
  403506:	200f      	movs	r0, #15
  403508:	4b36      	ldr	r3, [pc, #216]	; (4035e4 <VPWSendNetworkMessage+0x1a4>)
  40350a:	4798      	blx	r3
  40350c:	4603      	mov	r3, r0
  40350e:	2b00      	cmp	r3, #0
  403510:	d003      	beq.n	40351a <VPWSendNetworkMessage+0xda>
					{
						//Need to reset pointers and resend here, this was a bus collision.
						ui_vehicle_vpw_tx_notify_off();
  403512:	4b35      	ldr	r3, [pc, #212]	; (4035e8 <VPWSendNetworkMessage+0x1a8>)
  403514:	4798      	blx	r3
						return 0; //Bus collision :(
  403516:	2300      	movs	r3, #0
  403518:	e04c      	b.n	4035b4 <VPWSendNetworkMessage+0x174>
				while(tc_read_cv(VPW_TIMER,VPW_TX_TIMER_CHANNEL) <= period)
  40351a:	2100      	movs	r1, #0
  40351c:	4829      	ldr	r0, [pc, #164]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  40351e:	4b2f      	ldr	r3, [pc, #188]	; (4035dc <VPWSendNetworkMessage+0x19c>)
  403520:	4798      	blx	r3
  403522:	4602      	mov	r2, r0
  403524:	68bb      	ldr	r3, [r7, #8]
  403526:	429a      	cmp	r2, r3
  403528:	d9ed      	bls.n	403506 <VPWSendNetworkMessage+0xc6>
  40352a:	e020      	b.n	40356e <VPWSendNetworkMessage+0x12e>
					}
				}
			}
			else
			{
				GO_ACTIVE
  40352c:	2101      	movs	r1, #1
  40352e:	200f      	movs	r0, #15
  403530:	4b29      	ldr	r3, [pc, #164]	; (4035d8 <VPWSendNetworkMessage+0x198>)
  403532:	4798      	blx	r3
				tc_sync_trigger(VPW_TIMER);
  403534:	4823      	ldr	r0, [pc, #140]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403536:	4b27      	ldr	r3, [pc, #156]	; (4035d4 <VPWSendNetworkMessage+0x194>)
  403538:	4798      	blx	r3
				period = ((ch & (mask << bits)) >> bits) ? TX_SHORT : TX_LONG;
  40353a:	7b7a      	ldrb	r2, [r7, #13]
  40353c:	7b39      	ldrb	r1, [r7, #12]
  40353e:	7bfb      	ldrb	r3, [r7, #15]
  403540:	fa01 f303 	lsl.w	r3, r1, r3
  403544:	401a      	ands	r2, r3
  403546:	7bfb      	ldrb	r3, [r7, #15]
  403548:	fa42 f303 	asr.w	r3, r2, r3
  40354c:	2b00      	cmp	r3, #0
  40354e:	d002      	beq.n	403556 <VPWSendNetworkMessage+0x116>
  403550:	f44f 7340 	mov.w	r3, #768	; 0x300
  403554:	e001      	b.n	40355a <VPWSendNetworkMessage+0x11a>
  403556:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  40355a:	60bb      	str	r3, [r7, #8]
				while(tc_read_cv(VPW_TIMER,VPW_TX_TIMER_CHANNEL) <= period);
  40355c:	bf00      	nop
  40355e:	2100      	movs	r1, #0
  403560:	4818      	ldr	r0, [pc, #96]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403562:	4b1e      	ldr	r3, [pc, #120]	; (4035dc <VPWSendNetworkMessage+0x19c>)
  403564:	4798      	blx	r3
  403566:	4602      	mov	r2, r0
  403568:	68bb      	ldr	r3, [r7, #8]
  40356a:	429a      	cmp	r2, r3
  40356c:	d9f7      	bls.n	40355e <VPWSendNetworkMessage+0x11e>
		while(bits)
  40356e:	7bfb      	ldrb	r3, [r7, #15]
  403570:	2b00      	cmp	r3, #0
  403572:	d1a7      	bne.n	4034c4 <VPWSendNetworkMessage+0x84>
	while(n != 0)
  403574:	887b      	ldrh	r3, [r7, #2]
  403576:	2b00      	cmp	r3, #0
  403578:	d195      	bne.n	4034a6 <VPWSendNetworkMessage+0x66>
			}
		}//while bits
	}//while n
	GO_PASSIVE
  40357a:	2100      	movs	r1, #0
  40357c:	200f      	movs	r0, #15
  40357e:	4b16      	ldr	r3, [pc, #88]	; (4035d8 <VPWSendNetworkMessage+0x198>)
  403580:	4798      	blx	r3
	tc_sync_trigger(VPW_TIMER);
  403582:	4810      	ldr	r0, [pc, #64]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  403584:	4b13      	ldr	r3, [pc, #76]	; (4035d4 <VPWSendNetworkMessage+0x194>)
  403586:	4798      	blx	r3
	while(tc_read_cv(VPW_TIMER,VPW_TX_TIMER_CHANNEL) < TX_EOF);
  403588:	bf00      	nop
  40358a:	2100      	movs	r1, #0
  40358c:	480d      	ldr	r0, [pc, #52]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  40358e:	4b13      	ldr	r3, [pc, #76]	; (4035dc <VPWSendNetworkMessage+0x19c>)
  403590:	4798      	blx	r3
  403592:	4602      	mov	r2, r0
  403594:	f640 238b 	movw	r3, #2699	; 0xa8b
  403598:	429a      	cmp	r2, r3
  40359a:	d9f6      	bls.n	40358a <VPWSendNetworkMessage+0x14a>

	tc_stop(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  40359c:	2100      	movs	r1, #0
  40359e:	4809      	ldr	r0, [pc, #36]	; (4035c4 <VPWSendNetworkMessage+0x184>)
  4035a0:	4b09      	ldr	r3, [pc, #36]	; (4035c8 <VPWSendNetworkMessage+0x188>)
  4035a2:	4798      	blx	r3
	pio_enable_interrupt(PIOA, J1850_VPW_RX);
  4035a4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  4035a8:	4804      	ldr	r0, [pc, #16]	; (4035bc <VPWSendNetworkMessage+0x17c>)
  4035aa:	4b10      	ldr	r3, [pc, #64]	; (4035ec <VPWSendNetworkMessage+0x1ac>)
  4035ac:	4798      	blx	r3
	ui_vehicle_vpw_tx_notify_off();
  4035ae:	4b0e      	ldr	r3, [pc, #56]	; (4035e8 <VPWSendNetworkMessage+0x1a8>)
  4035b0:	4798      	blx	r3
	return VPW_RETURN_CODE_OK;
  4035b2:	2301      	movs	r3, #1
}
  4035b4:	4618      	mov	r0, r3
  4035b6:	3710      	adds	r7, #16
  4035b8:	46bd      	mov	sp, r7
  4035ba:	bd80      	pop	{r7, pc}
  4035bc:	400e0e00 	.word	0x400e0e00
  4035c0:	00407595 	.word	0x00407595
  4035c4:	40090000 	.word	0x40090000
  4035c8:	00401579 	.word	0x00401579
  4035cc:	00401557 	.word	0x00401557
  4035d0:	00403749 	.word	0x00403749
  4035d4:	0040153b 	.word	0x0040153b
  4035d8:	00402f99 	.word	0x00402f99
  4035dc:	0040159b 	.word	0x0040159b
  4035e0:	00401f69 	.word	0x00401f69
  4035e4:	00403005 	.word	0x00403005
  4035e8:	00401f91 	.word	0x00401f91
  4035ec:	00407579 	.word	0x00407579

004035f0 <VPWEnter1xMode>:

void VPWEnter1xMode(void)
{
  4035f0:	b580      	push	{r7, lr}
  4035f2:	b084      	sub	sp, #16
  4035f4:	af00      	add	r7, sp, #0
	tc_stop(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  4035f6:	2100      	movs	r1, #0
  4035f8:	4813      	ldr	r0, [pc, #76]	; (403648 <VPWEnter1xMode+0x58>)
  4035fa:	4b14      	ldr	r3, [pc, #80]	; (40364c <VPWEnter1xMode+0x5c>)
  4035fc:	4798      	blx	r3

	tc_init(VPW_TIMER,VPW_TX_TIMER_CHANNEL,
  4035fe:	2201      	movs	r2, #1
  403600:	2100      	movs	r1, #0
  403602:	4811      	ldr	r0, [pc, #68]	; (403648 <VPWEnter1xMode+0x58>)
  403604:	4b12      	ldr	r3, [pc, #72]	; (403650 <VPWEnter1xMode+0x60>)
  403606:	4798      	blx	r3
	TC_CMR_TCCLKS_TIMER_CLOCK2|
	TC_CMR_BURST_NONE
	);
	tc_start(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  403608:	2100      	movs	r1, #0
  40360a:	480f      	ldr	r0, [pc, #60]	; (403648 <VPWEnter1xMode+0x58>)
  40360c:	4b11      	ldr	r3, [pc, #68]	; (403654 <VPWEnter1xMode+0x64>)
  40360e:	4798      	blx	r3

	Is4xMode = false;
  403610:	4b11      	ldr	r3, [pc, #68]	; (403658 <VPWEnter1xMode+0x68>)
  403612:	2200      	movs	r2, #0
  403614:	701a      	strb	r2, [r3, #0]
	PulseWidthDivisor = 1;
  403616:	4b11      	ldr	r3, [pc, #68]	; (40365c <VPWEnter1xMode+0x6c>)
  403618:	2201      	movs	r2, #1
  40361a:	601a      	str	r2, [r3, #0]

	uint8_t tmpRtn[] = {START_BYTE, 0x00,0x02,ENTER_VPW_1X, 0x01};
  40361c:	4a10      	ldr	r2, [pc, #64]	; (403660 <VPWEnter1xMode+0x70>)
  40361e:	f107 0308 	add.w	r3, r7, #8
  403622:	e892 0003 	ldmia.w	r2, {r0, r1}
  403626:	6018      	str	r0, [r3, #0]
  403628:	3304      	adds	r3, #4
  40362a:	7019      	strb	r1, [r3, #0]
	Message_t EnterLowSpeedMessage;
	EnterLowSpeedMessage.buf = tmpRtn;
  40362c:	f107 0308 	add.w	r3, r7, #8
  403630:	603b      	str	r3, [r7, #0]
	EnterLowSpeedMessage.Size = 5;
  403632:	2305      	movs	r3, #5
  403634:	80bb      	strh	r3, [r7, #4]
	WriteMessage(&EnterLowSpeedMessage);
  403636:	463b      	mov	r3, r7
  403638:	4618      	mov	r0, r3
  40363a:	4b0a      	ldr	r3, [pc, #40]	; (403664 <VPWEnter1xMode+0x74>)
  40363c:	4798      	blx	r3
}
  40363e:	bf00      	nop
  403640:	3710      	adds	r7, #16
  403642:	46bd      	mov	sp, r7
  403644:	bd80      	pop	{r7, pc}
  403646:	bf00      	nop
  403648:	40090000 	.word	0x40090000
  40364c:	00401579 	.word	0x00401579
  403650:	00401501 	.word	0x00401501
  403654:	00401557 	.word	0x00401557
  403658:	20004660 	.word	0x20004660
  40365c:	20000178 	.word	0x20000178
  403660:	0040acc8 	.word	0x0040acc8
  403664:	00401a3d 	.word	0x00401a3d

00403668 <VPWEnter4xMode>:

void VPWEnter4xMode(void)
{
  403668:	b580      	push	{r7, lr}
  40366a:	b084      	sub	sp, #16
  40366c:	af00      	add	r7, sp, #0
	tc_stop(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  40366e:	2100      	movs	r1, #0
  403670:	4813      	ldr	r0, [pc, #76]	; (4036c0 <VPWEnter4xMode+0x58>)
  403672:	4b14      	ldr	r3, [pc, #80]	; (4036c4 <VPWEnter4xMode+0x5c>)
  403674:	4798      	blx	r3

	tc_init(VPW_TIMER,VPW_TX_TIMER_CHANNEL,
  403676:	2200      	movs	r2, #0
  403678:	2100      	movs	r1, #0
  40367a:	4811      	ldr	r0, [pc, #68]	; (4036c0 <VPWEnter4xMode+0x58>)
  40367c:	4b12      	ldr	r3, [pc, #72]	; (4036c8 <VPWEnter4xMode+0x60>)
  40367e:	4798      	blx	r3
	TC_CMR_TCCLKS_TIMER_CLOCK1|
	TC_CMR_BURST_NONE
	);
	
	tc_start(VPW_TIMER, VPW_TX_TIMER_CHANNEL);
  403680:	2100      	movs	r1, #0
  403682:	480f      	ldr	r0, [pc, #60]	; (4036c0 <VPWEnter4xMode+0x58>)
  403684:	4b11      	ldr	r3, [pc, #68]	; (4036cc <VPWEnter4xMode+0x64>)
  403686:	4798      	blx	r3

	Is4xMode = true;
  403688:	4b11      	ldr	r3, [pc, #68]	; (4036d0 <VPWEnter4xMode+0x68>)
  40368a:	2201      	movs	r2, #1
  40368c:	701a      	strb	r2, [r3, #0]
	PulseWidthDivisor = 4;
  40368e:	4b11      	ldr	r3, [pc, #68]	; (4036d4 <VPWEnter4xMode+0x6c>)
  403690:	2204      	movs	r2, #4
  403692:	601a      	str	r2, [r3, #0]
	
	uint8_t tmpRtn[] = {START_BYTE, 0x00,0x02,ENTER_VPW_4X, 0x01};
  403694:	4a10      	ldr	r2, [pc, #64]	; (4036d8 <VPWEnter4xMode+0x70>)
  403696:	f107 0308 	add.w	r3, r7, #8
  40369a:	e892 0003 	ldmia.w	r2, {r0, r1}
  40369e:	6018      	str	r0, [r3, #0]
  4036a0:	3304      	adds	r3, #4
  4036a2:	7019      	strb	r1, [r3, #0]
	Message_t EnterHighSpeedMessage;
	EnterHighSpeedMessage.buf = tmpRtn;
  4036a4:	f107 0308 	add.w	r3, r7, #8
  4036a8:	603b      	str	r3, [r7, #0]
	EnterHighSpeedMessage.Size = 5;
  4036aa:	2305      	movs	r3, #5
  4036ac:	80bb      	strh	r3, [r7, #4]
	WriteMessage(&EnterHighSpeedMessage);
  4036ae:	463b      	mov	r3, r7
  4036b0:	4618      	mov	r0, r3
  4036b2:	4b0a      	ldr	r3, [pc, #40]	; (4036dc <VPWEnter4xMode+0x74>)
  4036b4:	4798      	blx	r3


}
  4036b6:	bf00      	nop
  4036b8:	3710      	adds	r7, #16
  4036ba:	46bd      	mov	sp, r7
  4036bc:	bd80      	pop	{r7, pc}
  4036be:	bf00      	nop
  4036c0:	40090000 	.word	0x40090000
  4036c4:	00401579 	.word	0x00401579
  4036c8:	00401501 	.word	0x00401501
  4036cc:	00401557 	.word	0x00401557
  4036d0:	20004660 	.word	0x20004660
  4036d4:	20000178 	.word	0x20000178
  4036d8:	0040acd0 	.word	0x0040acd0
  4036dc:	00401a3d 	.word	0x00401a3d

004036e0 <VPWInitalizeCRCLUT>:

void VPWInitalizeCRCLUT()
{
  4036e0:	b480      	push	{r7}
  4036e2:	b085      	sub	sp, #20
  4036e4:	af00      	add	r7, sp, #0
    uint8_t  remainder;
   
    for (int dividend = 0; dividend < 256; ++dividend)
  4036e6:	2300      	movs	r3, #0
  4036e8:	60bb      	str	r3, [r7, #8]
  4036ea:	e021      	b.n	403730 <VPWInitalizeCRCLUT+0x50>
    {
        remainder = dividend << (WIDTH - 8);
  4036ec:	68bb      	ldr	r3, [r7, #8]
  4036ee:	73fb      	strb	r3, [r7, #15]
        
        for (uint8_t bit = 8; bit > 0; --bit)
  4036f0:	2308      	movs	r3, #8
  4036f2:	71fb      	strb	r3, [r7, #7]
  4036f4:	e011      	b.n	40371a <VPWInitalizeCRCLUT+0x3a>
        { 		
            if (remainder & TOPBIT)
  4036f6:	f997 300f 	ldrsb.w	r3, [r7, #15]
  4036fa:	2b00      	cmp	r3, #0
  4036fc:	da07      	bge.n	40370e <VPWInitalizeCRCLUT+0x2e>
            {
                remainder = (remainder << 1) ^ POLYNOMIAL;
  4036fe:	7bfb      	ldrb	r3, [r7, #15]
  403700:	005b      	lsls	r3, r3, #1
  403702:	b25b      	sxtb	r3, r3
  403704:	f083 031d 	eor.w	r3, r3, #29
  403708:	b25b      	sxtb	r3, r3
  40370a:	73fb      	strb	r3, [r7, #15]
  40370c:	e002      	b.n	403714 <VPWInitalizeCRCLUT+0x34>
            }
            else
            {
                remainder = (remainder << 1);
  40370e:	7bfb      	ldrb	r3, [r7, #15]
  403710:	005b      	lsls	r3, r3, #1
  403712:	73fb      	strb	r3, [r7, #15]
        for (uint8_t bit = 8; bit > 0; --bit)
  403714:	79fb      	ldrb	r3, [r7, #7]
  403716:	3b01      	subs	r3, #1
  403718:	71fb      	strb	r3, [r7, #7]
  40371a:	79fb      	ldrb	r3, [r7, #7]
  40371c:	2b00      	cmp	r3, #0
  40371e:	d1ea      	bne.n	4036f6 <VPWInitalizeCRCLUT+0x16>
            }
        }
        crcTable[dividend] = remainder;
  403720:	4a08      	ldr	r2, [pc, #32]	; (403744 <VPWInitalizeCRCLUT+0x64>)
  403722:	68bb      	ldr	r3, [r7, #8]
  403724:	4413      	add	r3, r2
  403726:	7bfa      	ldrb	r2, [r7, #15]
  403728:	701a      	strb	r2, [r3, #0]
    for (int dividend = 0; dividend < 256; ++dividend)
  40372a:	68bb      	ldr	r3, [r7, #8]
  40372c:	3301      	adds	r3, #1
  40372e:	60bb      	str	r3, [r7, #8]
  403730:	68bb      	ldr	r3, [r7, #8]
  403732:	2bff      	cmp	r3, #255	; 0xff
  403734:	ddda      	ble.n	4036ec <VPWInitalizeCRCLUT+0xc>
    }
}   
  403736:	bf00      	nop
  403738:	3714      	adds	r7, #20
  40373a:	46bd      	mov	sp, r7
  40373c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403740:	4770      	bx	lr
  403742:	bf00      	nop
  403744:	20004560 	.word	0x20004560

00403748 <VPWFastCRC>:

uint8_t VPWFastCRC(uint8_t const message[], int nBytes)
{
  403748:	b480      	push	{r7}
  40374a:	b087      	sub	sp, #28
  40374c:	af00      	add	r7, sp, #0
  40374e:	6078      	str	r0, [r7, #4]
  403750:	6039      	str	r1, [r7, #0]
    uint8_t data;
    uint8_t remainder = 0xFF;
  403752:	23ff      	movs	r3, #255	; 0xff
  403754:	75fb      	strb	r3, [r7, #23]

   
    for (int byte = 0; byte < nBytes; ++byte)
  403756:	2300      	movs	r3, #0
  403758:	613b      	str	r3, [r7, #16]
  40375a:	e013      	b.n	403784 <VPWFastCRC+0x3c>
    {
        data = message[byte] ^ (remainder >> (WIDTH - 8));
  40375c:	693b      	ldr	r3, [r7, #16]
  40375e:	687a      	ldr	r2, [r7, #4]
  403760:	4413      	add	r3, r2
  403762:	781a      	ldrb	r2, [r3, #0]
  403764:	7dfb      	ldrb	r3, [r7, #23]
  403766:	4053      	eors	r3, r2
  403768:	73fb      	strb	r3, [r7, #15]
        remainder = crcTable[data] ^ (remainder << 8);
  40376a:	7bfb      	ldrb	r3, [r7, #15]
  40376c:	4a0c      	ldr	r2, [pc, #48]	; (4037a0 <VPWFastCRC+0x58>)
  40376e:	5cd3      	ldrb	r3, [r2, r3]
  403770:	b25a      	sxtb	r2, r3
  403772:	7dfb      	ldrb	r3, [r7, #23]
  403774:	021b      	lsls	r3, r3, #8
  403776:	b25b      	sxtb	r3, r3
  403778:	4053      	eors	r3, r2
  40377a:	b25b      	sxtb	r3, r3
  40377c:	75fb      	strb	r3, [r7, #23]
    for (int byte = 0; byte < nBytes; ++byte)
  40377e:	693b      	ldr	r3, [r7, #16]
  403780:	3301      	adds	r3, #1
  403782:	613b      	str	r3, [r7, #16]
  403784:	693a      	ldr	r2, [r7, #16]
  403786:	683b      	ldr	r3, [r7, #0]
  403788:	429a      	cmp	r2, r3
  40378a:	dbe7      	blt.n	40375c <VPWFastCRC+0x14>
    }
    return (~remainder);
  40378c:	7dfb      	ldrb	r3, [r7, #23]
  40378e:	43db      	mvns	r3, r3
  403790:	b2db      	uxtb	r3, r3

} 
  403792:	4618      	mov	r0, r3
  403794:	371c      	adds	r7, #28
  403796:	46bd      	mov	sp, r7
  403798:	f85d 7b04 	ldr.w	r7, [sp], #4
  40379c:	4770      	bx	lr
  40379e:	bf00      	nop
  4037a0:	20004560 	.word	0x20004560

004037a4 <cpu_irq_save>:
{
  4037a4:	b480      	push	{r7}
  4037a6:	b083      	sub	sp, #12
  4037a8:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4037aa:	f3ef 8310 	mrs	r3, PRIMASK
  4037ae:	607b      	str	r3, [r7, #4]
  return(result);
  4037b0:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4037b2:	2b00      	cmp	r3, #0
  4037b4:	bf0c      	ite	eq
  4037b6:	2301      	moveq	r3, #1
  4037b8:	2300      	movne	r3, #0
  4037ba:	b2db      	uxtb	r3, r3
  4037bc:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4037be:	b672      	cpsid	i
  4037c0:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4037c4:	4b04      	ldr	r3, [pc, #16]	; (4037d8 <cpu_irq_save+0x34>)
  4037c6:	2200      	movs	r2, #0
  4037c8:	701a      	strb	r2, [r3, #0]
	return flags;
  4037ca:	683b      	ldr	r3, [r7, #0]
}
  4037cc:	4618      	mov	r0, r3
  4037ce:	370c      	adds	r7, #12
  4037d0:	46bd      	mov	sp, r7
  4037d2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4037d6:	4770      	bx	lr
  4037d8:	200001aa 	.word	0x200001aa

004037dc <cpu_irq_is_enabled_flags>:
{
  4037dc:	b480      	push	{r7}
  4037de:	b083      	sub	sp, #12
  4037e0:	af00      	add	r7, sp, #0
  4037e2:	6078      	str	r0, [r7, #4]
	return (flags);
  4037e4:	687b      	ldr	r3, [r7, #4]
  4037e6:	2b00      	cmp	r3, #0
  4037e8:	bf14      	ite	ne
  4037ea:	2301      	movne	r3, #1
  4037ec:	2300      	moveq	r3, #0
  4037ee:	b2db      	uxtb	r3, r3
}
  4037f0:	4618      	mov	r0, r3
  4037f2:	370c      	adds	r7, #12
  4037f4:	46bd      	mov	sp, r7
  4037f6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4037fa:	4770      	bx	lr

004037fc <cpu_irq_restore>:
{
  4037fc:	b580      	push	{r7, lr}
  4037fe:	b082      	sub	sp, #8
  403800:	af00      	add	r7, sp, #0
  403802:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  403804:	6878      	ldr	r0, [r7, #4]
  403806:	4b07      	ldr	r3, [pc, #28]	; (403824 <cpu_irq_restore+0x28>)
  403808:	4798      	blx	r3
  40380a:	4603      	mov	r3, r0
  40380c:	2b00      	cmp	r3, #0
  40380e:	d005      	beq.n	40381c <cpu_irq_restore+0x20>
		cpu_irq_enable();
  403810:	4b05      	ldr	r3, [pc, #20]	; (403828 <cpu_irq_restore+0x2c>)
  403812:	2201      	movs	r2, #1
  403814:	701a      	strb	r2, [r3, #0]
  403816:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40381a:	b662      	cpsie	i
}
  40381c:	bf00      	nop
  40381e:	3708      	adds	r7, #8
  403820:	46bd      	mov	sp, r7
  403822:	bd80      	pop	{r7, pc}
  403824:	004037dd 	.word	0x004037dd
  403828:	200001aa 	.word	0x200001aa

0040382c <udi_cdc_comm_enable>:
static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];

//@}

bool udi_cdc_comm_enable(void)
{
  40382c:	b480      	push	{r7}
  40382e:	b083      	sub	sp, #12
  403830:	af00      	add	r7, sp, #0
	uint8_t port;
	uint8_t iface_comm_num;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  403832:	2300      	movs	r3, #0
  403834:	71bb      	strb	r3, [r7, #6]
	udi_cdc_nb_comm_enabled = 0;
  403836:	4b44      	ldr	r3, [pc, #272]	; (403948 <udi_cdc_comm_enable+0x11c>)
  403838:	2200      	movs	r2, #0
  40383a:	701a      	strb	r2, [r3, #0]
	}
	port = udi_cdc_nb_comm_enabled;
#endif

	// Initialize control signal management
	udi_cdc_state[port] = CPU_TO_LE16(0);
  40383c:	79bb      	ldrb	r3, [r7, #6]
  40383e:	4a43      	ldr	r2, [pc, #268]	; (40394c <udi_cdc_comm_enable+0x120>)
  403840:	2100      	movs	r1, #0
  403842:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]

	uid_cdc_state_msg[port].header.bmRequestType =
  403846:	79ba      	ldrb	r2, [r7, #6]
  403848:	4941      	ldr	r1, [pc, #260]	; (403950 <udi_cdc_comm_enable+0x124>)
  40384a:	4613      	mov	r3, r2
  40384c:	009b      	lsls	r3, r3, #2
  40384e:	4413      	add	r3, r2
  403850:	005b      	lsls	r3, r3, #1
  403852:	440b      	add	r3, r1
  403854:	22a1      	movs	r2, #161	; 0xa1
  403856:	701a      	strb	r2, [r3, #0]
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE;
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
  403858:	79ba      	ldrb	r2, [r7, #6]
  40385a:	493d      	ldr	r1, [pc, #244]	; (403950 <udi_cdc_comm_enable+0x124>)
  40385c:	4613      	mov	r3, r2
  40385e:	009b      	lsls	r3, r3, #2
  403860:	4413      	add	r3, r2
  403862:	005b      	lsls	r3, r3, #1
  403864:	440b      	add	r3, r1
  403866:	3301      	adds	r3, #1
  403868:	2220      	movs	r2, #32
  40386a:	701a      	strb	r2, [r3, #0]
	uid_cdc_state_msg[port].header.wValue = LE16(0);
  40386c:	79ba      	ldrb	r2, [r7, #6]
  40386e:	4938      	ldr	r1, [pc, #224]	; (403950 <udi_cdc_comm_enable+0x124>)
  403870:	4613      	mov	r3, r2
  403872:	009b      	lsls	r3, r3, #2
  403874:	4413      	add	r3, r2
  403876:	005b      	lsls	r3, r3, #1
  403878:	440b      	add	r3, r1
  40387a:	3302      	adds	r3, #2
  40387c:	2200      	movs	r2, #0
  40387e:	801a      	strh	r2, [r3, #0]

	switch (port) {
  403880:	79bb      	ldrb	r3, [r7, #6]
  403882:	2b00      	cmp	r3, #0
  403884:	d102      	bne.n	40388c <udi_cdc_comm_enable+0x60>
#define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
	case index: \
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
  403886:	2300      	movs	r3, #0
  403888:	71fb      	strb	r3, [r7, #7]
  40388a:	e002      	b.n	403892 <udi_cdc_comm_enable+0x66>
#undef UDI_CDC_PORT_TO_IFACE_COMM
	default:
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
  40388c:	2300      	movs	r3, #0
  40388e:	71fb      	strb	r3, [r7, #7]
		break;
  403890:	bf00      	nop
	}

	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
  403892:	79ba      	ldrb	r2, [r7, #6]
  403894:	79fb      	ldrb	r3, [r7, #7]
  403896:	b298      	uxth	r0, r3
  403898:	492d      	ldr	r1, [pc, #180]	; (403950 <udi_cdc_comm_enable+0x124>)
  40389a:	4613      	mov	r3, r2
  40389c:	009b      	lsls	r3, r3, #2
  40389e:	4413      	add	r3, r2
  4038a0:	005b      	lsls	r3, r3, #1
  4038a2:	440b      	add	r3, r1
  4038a4:	3304      	adds	r3, #4
  4038a6:	4602      	mov	r2, r0
  4038a8:	801a      	strh	r2, [r3, #0]
	uid_cdc_state_msg[port].header.wLength = LE16(2);
  4038aa:	79ba      	ldrb	r2, [r7, #6]
  4038ac:	4928      	ldr	r1, [pc, #160]	; (403950 <udi_cdc_comm_enable+0x124>)
  4038ae:	4613      	mov	r3, r2
  4038b0:	009b      	lsls	r3, r3, #2
  4038b2:	4413      	add	r3, r2
  4038b4:	005b      	lsls	r3, r3, #1
  4038b6:	440b      	add	r3, r1
  4038b8:	3306      	adds	r3, #6
  4038ba:	2202      	movs	r2, #2
  4038bc:	801a      	strh	r2, [r3, #0]
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
  4038be:	79ba      	ldrb	r2, [r7, #6]
  4038c0:	4923      	ldr	r1, [pc, #140]	; (403950 <udi_cdc_comm_enable+0x124>)
  4038c2:	4613      	mov	r3, r2
  4038c4:	009b      	lsls	r3, r3, #2
  4038c6:	4413      	add	r3, r2
  4038c8:	005b      	lsls	r3, r3, #1
  4038ca:	440b      	add	r3, r1
  4038cc:	3308      	adds	r3, #8
  4038ce:	2200      	movs	r2, #0
  4038d0:	801a      	strh	r2, [r3, #0]

	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
  4038d2:	79ba      	ldrb	r2, [r7, #6]
  4038d4:	491f      	ldr	r1, [pc, #124]	; (403954 <udi_cdc_comm_enable+0x128>)
  4038d6:	4613      	mov	r3, r2
  4038d8:	00db      	lsls	r3, r3, #3
  4038da:	1a9b      	subs	r3, r3, r2
  4038dc:	440b      	add	r3, r1
  4038de:	2200      	movs	r2, #0
  4038e0:	701a      	strb	r2, [r3, #0]
  4038e2:	2200      	movs	r2, #0
  4038e4:	f062 023d 	orn	r2, r2, #61	; 0x3d
  4038e8:	705a      	strb	r2, [r3, #1]
  4038ea:	2200      	movs	r2, #0
  4038ec:	f042 0201 	orr.w	r2, r2, #1
  4038f0:	709a      	strb	r2, [r3, #2]
  4038f2:	2200      	movs	r2, #0
  4038f4:	70da      	strb	r2, [r3, #3]
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
  4038f6:	79ba      	ldrb	r2, [r7, #6]
  4038f8:	4916      	ldr	r1, [pc, #88]	; (403954 <udi_cdc_comm_enable+0x128>)
  4038fa:	4613      	mov	r3, r2
  4038fc:	00db      	lsls	r3, r3, #3
  4038fe:	1a9b      	subs	r3, r3, r2
  403900:	440b      	add	r3, r1
  403902:	3304      	adds	r3, #4
  403904:	2200      	movs	r2, #0
  403906:	701a      	strb	r2, [r3, #0]
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
  403908:	79ba      	ldrb	r2, [r7, #6]
  40390a:	4912      	ldr	r1, [pc, #72]	; (403954 <udi_cdc_comm_enable+0x128>)
  40390c:	4613      	mov	r3, r2
  40390e:	00db      	lsls	r3, r3, #3
  403910:	1a9b      	subs	r3, r3, r2
  403912:	440b      	add	r3, r1
  403914:	3305      	adds	r3, #5
  403916:	2200      	movs	r2, #0
  403918:	701a      	strb	r2, [r3, #0]
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
  40391a:	79ba      	ldrb	r2, [r7, #6]
  40391c:	490d      	ldr	r1, [pc, #52]	; (403954 <udi_cdc_comm_enable+0x128>)
  40391e:	4613      	mov	r3, r2
  403920:	00db      	lsls	r3, r3, #3
  403922:	1a9b      	subs	r3, r3, r2
  403924:	440b      	add	r3, r1
  403926:	3306      	adds	r3, #6
  403928:	2208      	movs	r2, #8
  40392a:	701a      	strb	r2, [r3, #0]
	// to initialize memories or indicate that interface is enabled
	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
	if (!UDI_CDC_ENABLE_EXT(port)) {
		return false;
	}
	udi_cdc_nb_comm_enabled++;
  40392c:	4b06      	ldr	r3, [pc, #24]	; (403948 <udi_cdc_comm_enable+0x11c>)
  40392e:	781b      	ldrb	r3, [r3, #0]
  403930:	b2db      	uxtb	r3, r3
  403932:	3301      	adds	r3, #1
  403934:	b2da      	uxtb	r2, r3
  403936:	4b04      	ldr	r3, [pc, #16]	; (403948 <udi_cdc_comm_enable+0x11c>)
  403938:	701a      	strb	r2, [r3, #0]
	return true;
  40393a:	2301      	movs	r3, #1
}
  40393c:	4618      	mov	r0, r3
  40393e:	370c      	adds	r7, #12
  403940:	46bd      	mov	sp, r7
  403942:	f85d 7b04 	ldr.w	r7, [sp], #4
  403946:	4770      	bx	lr
  403948:	2000467a 	.word	0x2000467a
  40394c:	2000466c 	.word	0x2000466c
  403950:	20004670 	.word	0x20004670
  403954:	20004664 	.word	0x20004664

00403958 <udi_cdc_data_enable>:

bool udi_cdc_data_enable(void)
{
  403958:	b580      	push	{r7, lr}
  40395a:	b082      	sub	sp, #8
  40395c:	af00      	add	r7, sp, #0
	uint8_t port;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  40395e:	2300      	movs	r3, #0
  403960:	71fb      	strb	r3, [r7, #7]
	udi_cdc_nb_data_enabled = 0;
  403962:	4b2d      	ldr	r3, [pc, #180]	; (403a18 <udi_cdc_data_enable+0xc0>)
  403964:	2200      	movs	r2, #0
  403966:	701a      	strb	r2, [r3, #0]
	}
	port = udi_cdc_nb_data_enabled;
#endif

	// Initialize TX management
	udi_cdc_tx_trans_ongoing[port] = false;
  403968:	79fb      	ldrb	r3, [r7, #7]
  40396a:	4a2c      	ldr	r2, [pc, #176]	; (403a1c <udi_cdc_data_enable+0xc4>)
  40396c:	2100      	movs	r1, #0
  40396e:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_both_buf_to_send[port] = false;
  403970:	79fb      	ldrb	r3, [r7, #7]
  403972:	4a2b      	ldr	r2, [pc, #172]	; (403a20 <udi_cdc_data_enable+0xc8>)
  403974:	2100      	movs	r1, #0
  403976:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_buf_sel[port] = 0;
  403978:	79fb      	ldrb	r3, [r7, #7]
  40397a:	4a2a      	ldr	r2, [pc, #168]	; (403a24 <udi_cdc_data_enable+0xcc>)
  40397c:	2100      	movs	r1, #0
  40397e:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_buf_nb[port][0] = 0;
  403980:	79fb      	ldrb	r3, [r7, #7]
  403982:	4a29      	ldr	r2, [pc, #164]	; (403a28 <udi_cdc_data_enable+0xd0>)
  403984:	2100      	movs	r1, #0
  403986:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
	udi_cdc_tx_buf_nb[port][1] = 0;
  40398a:	79fb      	ldrb	r3, [r7, #7]
  40398c:	4a26      	ldr	r2, [pc, #152]	; (403a28 <udi_cdc_data_enable+0xd0>)
  40398e:	009b      	lsls	r3, r3, #2
  403990:	4413      	add	r3, r2
  403992:	2200      	movs	r2, #0
  403994:	805a      	strh	r2, [r3, #2]
	udi_cdc_tx_sof_num[port] = 0;
  403996:	79fb      	ldrb	r3, [r7, #7]
  403998:	4a24      	ldr	r2, [pc, #144]	; (403a2c <udi_cdc_data_enable+0xd4>)
  40399a:	2100      	movs	r1, #0
  40399c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	udi_cdc_tx_send(port);
  4039a0:	79fb      	ldrb	r3, [r7, #7]
  4039a2:	4618      	mov	r0, r3
  4039a4:	4b22      	ldr	r3, [pc, #136]	; (403a30 <udi_cdc_data_enable+0xd8>)
  4039a6:	4798      	blx	r3

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[port] = false;
  4039a8:	79fb      	ldrb	r3, [r7, #7]
  4039aa:	4a22      	ldr	r2, [pc, #136]	; (403a34 <udi_cdc_data_enable+0xdc>)
  4039ac:	2100      	movs	r1, #0
  4039ae:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_buf_sel[port] = 0;
  4039b0:	79fb      	ldrb	r3, [r7, #7]
  4039b2:	4a21      	ldr	r2, [pc, #132]	; (403a38 <udi_cdc_data_enable+0xe0>)
  4039b4:	2100      	movs	r1, #0
  4039b6:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_buf_nb[port][0] = 0;
  4039b8:	79fb      	ldrb	r3, [r7, #7]
  4039ba:	4a20      	ldr	r2, [pc, #128]	; (403a3c <udi_cdc_data_enable+0xe4>)
  4039bc:	2100      	movs	r1, #0
  4039be:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
	udi_cdc_rx_buf_nb[port][1] = 0;
  4039c2:	79fb      	ldrb	r3, [r7, #7]
  4039c4:	4a1d      	ldr	r2, [pc, #116]	; (403a3c <udi_cdc_data_enable+0xe4>)
  4039c6:	009b      	lsls	r3, r3, #2
  4039c8:	4413      	add	r3, r2
  4039ca:	2200      	movs	r2, #0
  4039cc:	805a      	strh	r2, [r3, #2]
	udi_cdc_rx_pos[port] = 0;
  4039ce:	79fb      	ldrb	r3, [r7, #7]
  4039d0:	4a1b      	ldr	r2, [pc, #108]	; (403a40 <udi_cdc_data_enable+0xe8>)
  4039d2:	2100      	movs	r1, #0
  4039d4:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	if (!udi_cdc_rx_start(port)) {
  4039d8:	79fb      	ldrb	r3, [r7, #7]
  4039da:	4618      	mov	r0, r3
  4039dc:	4b19      	ldr	r3, [pc, #100]	; (403a44 <udi_cdc_data_enable+0xec>)
  4039de:	4798      	blx	r3
  4039e0:	4603      	mov	r3, r0
  4039e2:	f083 0301 	eor.w	r3, r3, #1
  4039e6:	b2db      	uxtb	r3, r3
  4039e8:	2b00      	cmp	r3, #0
  4039ea:	d001      	beq.n	4039f0 <udi_cdc_data_enable+0x98>
		return false;
  4039ec:	2300      	movs	r3, #0
  4039ee:	e00f      	b.n	403a10 <udi_cdc_data_enable+0xb8>
	}
	udi_cdc_nb_data_enabled++;
  4039f0:	4b09      	ldr	r3, [pc, #36]	; (403a18 <udi_cdc_data_enable+0xc0>)
  4039f2:	781b      	ldrb	r3, [r3, #0]
  4039f4:	b2db      	uxtb	r3, r3
  4039f6:	3301      	adds	r3, #1
  4039f8:	b2da      	uxtb	r2, r3
  4039fa:	4b07      	ldr	r3, [pc, #28]	; (403a18 <udi_cdc_data_enable+0xc0>)
  4039fc:	701a      	strb	r2, [r3, #0]
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
  4039fe:	4b06      	ldr	r3, [pc, #24]	; (403a18 <udi_cdc_data_enable+0xc0>)
  403a00:	781b      	ldrb	r3, [r3, #0]
  403a02:	b2db      	uxtb	r3, r3
  403a04:	2b01      	cmp	r3, #1
  403a06:	d102      	bne.n	403a0e <udi_cdc_data_enable+0xb6>
		udi_cdc_data_running = true;
  403a08:	4b0f      	ldr	r3, [pc, #60]	; (403a48 <udi_cdc_data_enable+0xf0>)
  403a0a:	2201      	movs	r2, #1
  403a0c:	701a      	strb	r2, [r3, #0]
	}
	return true;
  403a0e:	2301      	movs	r3, #1
}
  403a10:	4618      	mov	r0, r3
  403a12:	3708      	adds	r7, #8
  403a14:	46bd      	mov	sp, r7
  403a16:	bd80      	pop	{r7, pc}
  403a18:	2000467b 	.word	0x2000467b
  403a1c:	2000879c 	.word	0x2000879c
  403a20:	200087a0 	.word	0x200087a0
  403a24:	20008794 	.word	0x20008794
  403a28:	20008790 	.word	0x20008790
  403a2c:	20008798 	.word	0x20008798
  403a30:	00403e2d 	.word	0x00403e2d
  403a34:	2000670c 	.word	0x2000670c
  403a38:	20006704 	.word	0x20006704
  403a3c:	20006700 	.word	0x20006700
  403a40:	20006708 	.word	0x20006708
  403a44:	00403be9 	.word	0x00403be9
  403a48:	2000467c 	.word	0x2000467c

00403a4c <udi_cdc_comm_disable>:

void udi_cdc_comm_disable(void)
{
  403a4c:	b480      	push	{r7}
  403a4e:	af00      	add	r7, sp, #0
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
  403a50:	4b05      	ldr	r3, [pc, #20]	; (403a68 <udi_cdc_comm_disable+0x1c>)
  403a52:	781b      	ldrb	r3, [r3, #0]
  403a54:	b2db      	uxtb	r3, r3
  403a56:	3b01      	subs	r3, #1
  403a58:	b2da      	uxtb	r2, r3
  403a5a:	4b03      	ldr	r3, [pc, #12]	; (403a68 <udi_cdc_comm_disable+0x1c>)
  403a5c:	701a      	strb	r2, [r3, #0]
}
  403a5e:	bf00      	nop
  403a60:	46bd      	mov	sp, r7
  403a62:	f85d 7b04 	ldr.w	r7, [sp], #4
  403a66:	4770      	bx	lr
  403a68:	2000467a 	.word	0x2000467a

00403a6c <udi_cdc_data_disable>:

void udi_cdc_data_disable(void)
{
  403a6c:	b480      	push	{r7}
  403a6e:	b083      	sub	sp, #12
  403a70:	af00      	add	r7, sp, #0
	uint8_t port;

	Assert(udi_cdc_nb_data_enabled != 0);
	udi_cdc_nb_data_enabled--;
  403a72:	4b09      	ldr	r3, [pc, #36]	; (403a98 <udi_cdc_data_disable+0x2c>)
  403a74:	781b      	ldrb	r3, [r3, #0]
  403a76:	b2db      	uxtb	r3, r3
  403a78:	3b01      	subs	r3, #1
  403a7a:	b2da      	uxtb	r2, r3
  403a7c:	4b06      	ldr	r3, [pc, #24]	; (403a98 <udi_cdc_data_disable+0x2c>)
  403a7e:	701a      	strb	r2, [r3, #0]
	port = udi_cdc_nb_data_enabled;
  403a80:	4b05      	ldr	r3, [pc, #20]	; (403a98 <udi_cdc_data_disable+0x2c>)
  403a82:	781b      	ldrb	r3, [r3, #0]
  403a84:	71fb      	strb	r3, [r7, #7]
	UDI_CDC_DISABLE_EXT(port);
	udi_cdc_data_running = false;
  403a86:	4b05      	ldr	r3, [pc, #20]	; (403a9c <udi_cdc_data_disable+0x30>)
  403a88:	2200      	movs	r2, #0
  403a8a:	701a      	strb	r2, [r3, #0]
}
  403a8c:	bf00      	nop
  403a8e:	370c      	adds	r7, #12
  403a90:	46bd      	mov	sp, r7
  403a92:	f85d 7b04 	ldr.w	r7, [sp], #4
  403a96:	4770      	bx	lr
  403a98:	2000467b 	.word	0x2000467b
  403a9c:	2000467c 	.word	0x2000467c

00403aa0 <udi_cdc_comm_setup>:

bool udi_cdc_comm_setup(void)
{
  403aa0:	b580      	push	{r7, lr}
  403aa2:	b082      	sub	sp, #8
  403aa4:	af00      	add	r7, sp, #0
	uint8_t port = udi_cdc_setup_to_port();
  403aa6:	4b2a      	ldr	r3, [pc, #168]	; (403b50 <udi_cdc_comm_setup+0xb0>)
  403aa8:	4798      	blx	r3
  403aaa:	4603      	mov	r3, r0
  403aac:	71fb      	strb	r3, [r7, #7]

	if (Udd_setup_is_in()) {
  403aae:	4b29      	ldr	r3, [pc, #164]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403ab0:	781b      	ldrb	r3, [r3, #0]
  403ab2:	b25b      	sxtb	r3, r3
  403ab4:	2b00      	cmp	r3, #0
  403ab6:	da1c      	bge.n	403af2 <udi_cdc_comm_setup+0x52>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
  403ab8:	4b26      	ldr	r3, [pc, #152]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403aba:	781b      	ldrb	r3, [r3, #0]
  403abc:	f003 0360 	and.w	r3, r3, #96	; 0x60
  403ac0:	2b20      	cmp	r3, #32
  403ac2:	d116      	bne.n	403af2 <udi_cdc_comm_setup+0x52>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
  403ac4:	4b23      	ldr	r3, [pc, #140]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403ac6:	785b      	ldrb	r3, [r3, #1]
  403ac8:	2b21      	cmp	r3, #33	; 0x21
  403aca:	d112      	bne.n	403af2 <udi_cdc_comm_setup+0x52>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
  403acc:	4b21      	ldr	r3, [pc, #132]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403ace:	88db      	ldrh	r3, [r3, #6]
				if (sizeof(usb_cdc_line_coding_t) !=
  403ad0:	2b07      	cmp	r3, #7
  403ad2:	d001      	beq.n	403ad8 <udi_cdc_comm_setup+0x38>
					return false; // Error for USB host
  403ad4:	2300      	movs	r3, #0
  403ad6:	e037      	b.n	403b48 <udi_cdc_comm_setup+0xa8>
				udd_g_ctrlreq.payload =
						(uint8_t *) &
						udi_cdc_line_coding[port];
  403ad8:	79fa      	ldrb	r2, [r7, #7]
						(uint8_t *) &
  403ada:	4613      	mov	r3, r2
  403adc:	00db      	lsls	r3, r3, #3
  403ade:	1a9b      	subs	r3, r3, r2
  403ae0:	4a1d      	ldr	r2, [pc, #116]	; (403b58 <udi_cdc_comm_setup+0xb8>)
  403ae2:	4413      	add	r3, r2
				udd_g_ctrlreq.payload =
  403ae4:	4a1b      	ldr	r2, [pc, #108]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403ae6:	6093      	str	r3, [r2, #8]
				udd_g_ctrlreq.payload_size =
  403ae8:	4b1a      	ldr	r3, [pc, #104]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403aea:	2207      	movs	r2, #7
  403aec:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
  403aee:	2301      	movs	r3, #1
  403af0:	e02a      	b.n	403b48 <udi_cdc_comm_setup+0xa8>
			}
		}
	}
	if (Udd_setup_is_out()) {
  403af2:	4b18      	ldr	r3, [pc, #96]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403af4:	781b      	ldrb	r3, [r3, #0]
  403af6:	b25b      	sxtb	r3, r3
  403af8:	2b00      	cmp	r3, #0
  403afa:	db24      	blt.n	403b46 <udi_cdc_comm_setup+0xa6>
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
  403afc:	4b15      	ldr	r3, [pc, #84]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403afe:	781b      	ldrb	r3, [r3, #0]
  403b00:	f003 0360 	and.w	r3, r3, #96	; 0x60
  403b04:	2b20      	cmp	r3, #32
  403b06:	d11e      	bne.n	403b46 <udi_cdc_comm_setup+0xa6>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
  403b08:	4b12      	ldr	r3, [pc, #72]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403b0a:	785b      	ldrb	r3, [r3, #1]
  403b0c:	2b20      	cmp	r3, #32
  403b0e:	d002      	beq.n	403b16 <udi_cdc_comm_setup+0x76>
  403b10:	2b22      	cmp	r3, #34	; 0x22
  403b12:	d016      	beq.n	403b42 <udi_cdc_comm_setup+0xa2>
  403b14:	e017      	b.n	403b46 <udi_cdc_comm_setup+0xa6>
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
  403b16:	4b0f      	ldr	r3, [pc, #60]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403b18:	88db      	ldrh	r3, [r3, #6]
				if (sizeof(usb_cdc_line_coding_t) !=
  403b1a:	2b07      	cmp	r3, #7
  403b1c:	d001      	beq.n	403b22 <udi_cdc_comm_setup+0x82>
					return false; // Error for USB host
  403b1e:	2300      	movs	r3, #0
  403b20:	e012      	b.n	403b48 <udi_cdc_comm_setup+0xa8>
				udd_g_ctrlreq.callback =
  403b22:	4b0c      	ldr	r3, [pc, #48]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403b24:	4a0d      	ldr	r2, [pc, #52]	; (403b5c <udi_cdc_comm_setup+0xbc>)
  403b26:	611a      	str	r2, [r3, #16]
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
						udi_cdc_line_coding[port];
  403b28:	79fa      	ldrb	r2, [r7, #7]
						(uint8_t *) &
  403b2a:	4613      	mov	r3, r2
  403b2c:	00db      	lsls	r3, r3, #3
  403b2e:	1a9b      	subs	r3, r3, r2
  403b30:	4a09      	ldr	r2, [pc, #36]	; (403b58 <udi_cdc_comm_setup+0xb8>)
  403b32:	4413      	add	r3, r2
				udd_g_ctrlreq.payload =
  403b34:	4a07      	ldr	r2, [pc, #28]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403b36:	6093      	str	r3, [r2, #8]
				udd_g_ctrlreq.payload_size =
  403b38:	4b06      	ldr	r3, [pc, #24]	; (403b54 <udi_cdc_comm_setup+0xb4>)
  403b3a:	2207      	movs	r2, #7
  403b3c:	819a      	strh	r2, [r3, #12]
						sizeof(usb_cdc_line_coding_t);
				return true;
  403b3e:	2301      	movs	r3, #1
  403b40:	e002      	b.n	403b48 <udi_cdc_comm_setup+0xa8>
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_DTE_PRESENT)));
				UDI_CDC_SET_RTS_EXT(port, (0 !=
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
  403b42:	2301      	movs	r3, #1
  403b44:	e000      	b.n	403b48 <udi_cdc_comm_setup+0xa8>
			}
		}
	}
	return false;  // request Not supported
  403b46:	2300      	movs	r3, #0
}
  403b48:	4618      	mov	r0, r3
  403b4a:	3708      	adds	r7, #8
  403b4c:	46bd      	mov	sp, r7
  403b4e:	bd80      	pop	{r7, pc}
  403b50:	00403b9d 	.word	0x00403b9d
  403b54:	2000896c 	.word	0x2000896c
  403b58:	20004664 	.word	0x20004664
  403b5c:	00403bcd 	.word	0x00403bcd

00403b60 <udi_cdc_data_setup>:

bool udi_cdc_data_setup(void)
{
  403b60:	b480      	push	{r7}
  403b62:	af00      	add	r7, sp, #0
	return false;  // request Not supported
  403b64:	2300      	movs	r3, #0
}
  403b66:	4618      	mov	r0, r3
  403b68:	46bd      	mov	sp, r7
  403b6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b6e:	4770      	bx	lr

00403b70 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
  403b70:	b480      	push	{r7}
  403b72:	af00      	add	r7, sp, #0
	return 0;      // CDC don't have multiple alternate setting
  403b74:	2300      	movs	r3, #0
}
  403b76:	4618      	mov	r0, r3
  403b78:	46bd      	mov	sp, r7
  403b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b7e:	4770      	bx	lr

00403b80 <udi_cdc_data_sof_notify>:

void udi_cdc_data_sof_notify(void)
{
  403b80:	b580      	push	{r7, lr}
  403b82:	af00      	add	r7, sp, #0
	static uint8_t port_notify = 0;

	// A call of udi_cdc_data_sof_notify() is done for each port
	udi_cdc_tx_send(port_notify);
  403b84:	4b03      	ldr	r3, [pc, #12]	; (403b94 <udi_cdc_data_sof_notify+0x14>)
  403b86:	781b      	ldrb	r3, [r3, #0]
  403b88:	4618      	mov	r0, r3
  403b8a:	4b03      	ldr	r3, [pc, #12]	; (403b98 <udi_cdc_data_sof_notify+0x18>)
  403b8c:	4798      	blx	r3
	port_notify++;
	if (port_notify >= UDI_CDC_PORT_NB) {
		port_notify = 0;
	}
#endif
}
  403b8e:	bf00      	nop
  403b90:	bd80      	pop	{r7, pc}
  403b92:	bf00      	nop
  403b94:	200087a1 	.word	0x200087a1
  403b98:	00403e2d 	.word	0x00403e2d

00403b9c <udi_cdc_setup_to_port>:

//-------------------------------------------------
//------- Internal routines to control serial line

static uint8_t udi_cdc_setup_to_port(void)
{
  403b9c:	b480      	push	{r7}
  403b9e:	b083      	sub	sp, #12
  403ba0:	af00      	add	r7, sp, #0
	uint8_t port;

	switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
  403ba2:	4b09      	ldr	r3, [pc, #36]	; (403bc8 <udi_cdc_setup_to_port+0x2c>)
  403ba4:	889b      	ldrh	r3, [r3, #4]
  403ba6:	b2db      	uxtb	r3, r3
  403ba8:	2b00      	cmp	r3, #0
  403baa:	d102      	bne.n	403bb2 <udi_cdc_setup_to_port+0x16>
#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
	case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
  403bac:	2300      	movs	r3, #0
  403bae:	71fb      	strb	r3, [r7, #7]
  403bb0:	e002      	b.n	403bb8 <udi_cdc_setup_to_port+0x1c>
#undef UDI_CDC_IFACE_COMM_TO_PORT
	default:
		port = 0;
  403bb2:	2300      	movs	r3, #0
  403bb4:	71fb      	strb	r3, [r7, #7]
		break;
  403bb6:	bf00      	nop
	}
	return port;
  403bb8:	79fb      	ldrb	r3, [r7, #7]
}
  403bba:	4618      	mov	r0, r3
  403bbc:	370c      	adds	r7, #12
  403bbe:	46bd      	mov	sp, r7
  403bc0:	f85d 7b04 	ldr.w	r7, [sp], #4
  403bc4:	4770      	bx	lr
  403bc6:	bf00      	nop
  403bc8:	2000896c 	.word	0x2000896c

00403bcc <udi_cdc_line_coding_received>:

static void udi_cdc_line_coding_received(void)
{
  403bcc:	b580      	push	{r7, lr}
  403bce:	b082      	sub	sp, #8
  403bd0:	af00      	add	r7, sp, #0
	uint8_t port = udi_cdc_setup_to_port();
  403bd2:	4b04      	ldr	r3, [pc, #16]	; (403be4 <udi_cdc_line_coding_received+0x18>)
  403bd4:	4798      	blx	r3
  403bd6:	4603      	mov	r3, r0
  403bd8:	71fb      	strb	r3, [r7, #7]
	UNUSED(port);

	UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
}
  403bda:	bf00      	nop
  403bdc:	3708      	adds	r7, #8
  403bde:	46bd      	mov	sp, r7
  403be0:	bd80      	pop	{r7, pc}
  403be2:	bf00      	nop
  403be4:	00403b9d 	.word	0x00403b9d

00403be8 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
  403be8:	b590      	push	{r4, r7, lr}
  403bea:	b089      	sub	sp, #36	; 0x24
  403bec:	af02      	add	r7, sp, #8
  403bee:	4603      	mov	r3, r0
  403bf0:	71fb      	strb	r3, [r7, #7]
	irqflags_t flags;
	uint8_t buf_sel_trans;
	udd_ep_id_t ep;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  403bf2:	2300      	movs	r3, #0
  403bf4:	71fb      	strb	r3, [r7, #7]
#endif

	flags = cpu_irq_save();
  403bf6:	4b33      	ldr	r3, [pc, #204]	; (403cc4 <udi_cdc_rx_start+0xdc>)
  403bf8:	4798      	blx	r3
  403bfa:	6138      	str	r0, [r7, #16]
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
  403bfc:	79fb      	ldrb	r3, [r7, #7]
  403bfe:	4a32      	ldr	r2, [pc, #200]	; (403cc8 <udi_cdc_rx_start+0xe0>)
  403c00:	5cd3      	ldrb	r3, [r2, r3]
  403c02:	73fb      	strb	r3, [r7, #15]
	if (udi_cdc_rx_trans_ongoing[port] ||
  403c04:	79fb      	ldrb	r3, [r7, #7]
  403c06:	4a31      	ldr	r2, [pc, #196]	; (403ccc <udi_cdc_rx_start+0xe4>)
  403c08:	5cd3      	ldrb	r3, [r2, r3]
  403c0a:	b2db      	uxtb	r3, r3
  403c0c:	2b00      	cmp	r3, #0
  403c0e:	d10e      	bne.n	403c2e <udi_cdc_rx_start+0x46>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
  403c10:	79fb      	ldrb	r3, [r7, #7]
  403c12:	4a2f      	ldr	r2, [pc, #188]	; (403cd0 <udi_cdc_rx_start+0xe8>)
  403c14:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  403c18:	b29a      	uxth	r2, r3
  403c1a:	79f9      	ldrb	r1, [r7, #7]
  403c1c:	7bfb      	ldrb	r3, [r7, #15]
  403c1e:	482d      	ldr	r0, [pc, #180]	; (403cd4 <udi_cdc_rx_start+0xec>)
  403c20:	0049      	lsls	r1, r1, #1
  403c22:	440b      	add	r3, r1
  403c24:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
  403c28:	b29b      	uxth	r3, r3
	if (udi_cdc_rx_trans_ongoing[port] ||
  403c2a:	429a      	cmp	r2, r3
  403c2c:	d204      	bcs.n	403c38 <udi_cdc_rx_start+0x50>
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
  403c2e:	6938      	ldr	r0, [r7, #16]
  403c30:	4b29      	ldr	r3, [pc, #164]	; (403cd8 <udi_cdc_rx_start+0xf0>)
  403c32:	4798      	blx	r3
		return false;
  403c34:	2300      	movs	r3, #0
  403c36:	e040      	b.n	403cba <udi_cdc_rx_start+0xd2>
	}

	// Change current buffer
	udi_cdc_rx_pos[port] = 0;
  403c38:	79fb      	ldrb	r3, [r7, #7]
  403c3a:	4a25      	ldr	r2, [pc, #148]	; (403cd0 <udi_cdc_rx_start+0xe8>)
  403c3c:	2100      	movs	r1, #0
  403c3e:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
  403c42:	79fb      	ldrb	r3, [r7, #7]
  403c44:	7bfa      	ldrb	r2, [r7, #15]
  403c46:	2a00      	cmp	r2, #0
  403c48:	bf0c      	ite	eq
  403c4a:	2201      	moveq	r2, #1
  403c4c:	2200      	movne	r2, #0
  403c4e:	b2d2      	uxtb	r2, r2
  403c50:	4611      	mov	r1, r2
  403c52:	4a1d      	ldr	r2, [pc, #116]	; (403cc8 <udi_cdc_rx_start+0xe0>)
  403c54:	54d1      	strb	r1, [r2, r3]

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[port] = true;
  403c56:	79fb      	ldrb	r3, [r7, #7]
  403c58:	4a1c      	ldr	r2, [pc, #112]	; (403ccc <udi_cdc_rx_start+0xe4>)
  403c5a:	2101      	movs	r1, #1
  403c5c:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
  403c5e:	6938      	ldr	r0, [r7, #16]
  403c60:	4b1d      	ldr	r3, [pc, #116]	; (403cd8 <udi_cdc_rx_start+0xf0>)
  403c62:	4798      	blx	r3

	if (udi_cdc_multi_is_rx_ready(port)) {
  403c64:	79fb      	ldrb	r3, [r7, #7]
  403c66:	4618      	mov	r0, r3
  403c68:	4b1c      	ldr	r3, [pc, #112]	; (403cdc <udi_cdc_rx_start+0xf4>)
  403c6a:	4798      	blx	r3
  403c6c:	4603      	mov	r3, r0
  403c6e:	2b00      	cmp	r3, #0
  403c70:	d003      	beq.n	403c7a <udi_cdc_rx_start+0x92>
		UDI_CDC_RX_NOTIFY(port);
  403c72:	79fb      	ldrb	r3, [r7, #7]
  403c74:	4618      	mov	r0, r3
  403c76:	4b1a      	ldr	r3, [pc, #104]	; (403ce0 <udi_cdc_rx_start+0xf8>)
  403c78:	4798      	blx	r3
	}
	// Send the buffer with enable of short packet
	switch (port) {
  403c7a:	79fb      	ldrb	r3, [r7, #7]
  403c7c:	2b00      	cmp	r3, #0
  403c7e:	d102      	bne.n	403c86 <udi_cdc_rx_start+0x9e>
#define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_OUT_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
  403c80:	2302      	movs	r3, #2
  403c82:	75fb      	strb	r3, [r7, #23]
  403c84:	e002      	b.n	403c8c <udi_cdc_rx_start+0xa4>
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
  403c86:	2302      	movs	r3, #2
  403c88:	75fb      	strb	r3, [r7, #23]
		break;
  403c8a:	bf00      	nop
	}
	return udd_ep_run(ep,
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
  403c8c:	79f9      	ldrb	r1, [r7, #7]
  403c8e:	7bfb      	ldrb	r3, [r7, #15]
  403c90:	461a      	mov	r2, r3
  403c92:	0192      	lsls	r2, r2, #6
  403c94:	441a      	add	r2, r3
  403c96:	0193      	lsls	r3, r2, #6
  403c98:	461a      	mov	r2, r3
  403c9a:	460b      	mov	r3, r1
  403c9c:	019b      	lsls	r3, r3, #6
  403c9e:	440b      	add	r3, r1
  403ca0:	01db      	lsls	r3, r3, #7
  403ca2:	4413      	add	r3, r2
  403ca4:	4a0f      	ldr	r2, [pc, #60]	; (403ce4 <udi_cdc_rx_start+0xfc>)
  403ca6:	441a      	add	r2, r3
	return udd_ep_run(ep,
  403ca8:	7df8      	ldrb	r0, [r7, #23]
  403caa:	4b0f      	ldr	r3, [pc, #60]	; (403ce8 <udi_cdc_rx_start+0x100>)
  403cac:	9300      	str	r3, [sp, #0]
  403cae:	f44f 5382 	mov.w	r3, #4160	; 0x1040
  403cb2:	2101      	movs	r1, #1
  403cb4:	4c0d      	ldr	r4, [pc, #52]	; (403cec <udi_cdc_rx_start+0x104>)
  403cb6:	47a0      	blx	r4
  403cb8:	4603      	mov	r3, r0
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received);
}
  403cba:	4618      	mov	r0, r3
  403cbc:	371c      	adds	r7, #28
  403cbe:	46bd      	mov	sp, r7
  403cc0:	bd90      	pop	{r4, r7, pc}
  403cc2:	bf00      	nop
  403cc4:	004037a5 	.word	0x004037a5
  403cc8:	20006704 	.word	0x20006704
  403ccc:	2000670c 	.word	0x2000670c
  403cd0:	20006708 	.word	0x20006708
  403cd4:	20006700 	.word	0x20006700
  403cd8:	004037fd 	.word	0x004037fd
  403cdc:	00404075 	.word	0x00404075
  403ce0:	00401721 	.word	0x00401721
  403ce4:	20004680 	.word	0x20004680
  403ce8:	00403cf1 	.word	0x00403cf1
  403cec:	00405d5d 	.word	0x00405d5d

00403cf0 <udi_cdc_data_received>:


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
  403cf0:	b590      	push	{r4, r7, lr}
  403cf2:	b087      	sub	sp, #28
  403cf4:	af02      	add	r7, sp, #8
  403cf6:	4603      	mov	r3, r0
  403cf8:	6039      	str	r1, [r7, #0]
  403cfa:	71fb      	strb	r3, [r7, #7]
  403cfc:	4613      	mov	r3, r2
  403cfe:	71bb      	strb	r3, [r7, #6]
	uint8_t buf_sel_trans;
	uint8_t port;

	switch (ep) {
  403d00:	79bb      	ldrb	r3, [r7, #6]
  403d02:	2b02      	cmp	r3, #2
  403d04:	d102      	bne.n	403d0c <udi_cdc_data_received+0x1c>
#define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_OUT_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
  403d06:	2300      	movs	r3, #0
  403d08:	73fb      	strb	r3, [r7, #15]
  403d0a:	e002      	b.n	403d12 <udi_cdc_data_received+0x22>
#undef UDI_CDC_DATA_EP_OUT_TO_PORT
	default:
		port = 0;
  403d0c:	2300      	movs	r3, #0
  403d0e:	73fb      	strb	r3, [r7, #15]
		break;
  403d10:	bf00      	nop
	}

	if (UDD_EP_TRANSFER_OK != status) {
  403d12:	79fb      	ldrb	r3, [r7, #7]
  403d14:	2b00      	cmp	r3, #0
  403d16:	d136      	bne.n	403d86 <udi_cdc_data_received+0x96>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
  403d18:	7bfb      	ldrb	r3, [r7, #15]
  403d1a:	4a1d      	ldr	r2, [pc, #116]	; (403d90 <udi_cdc_data_received+0xa0>)
  403d1c:	5cd3      	ldrb	r3, [r2, r3]
  403d1e:	b2db      	uxtb	r3, r3
  403d20:	2b00      	cmp	r3, #0
  403d22:	bf0c      	ite	eq
  403d24:	2301      	moveq	r3, #1
  403d26:	2300      	movne	r3, #0
  403d28:	b2db      	uxtb	r3, r3
  403d2a:	73bb      	strb	r3, [r7, #14]
	if (!n) {
  403d2c:	683b      	ldr	r3, [r7, #0]
  403d2e:	2b00      	cmp	r3, #0
  403d30:	d116      	bne.n	403d60 <udi_cdc_data_received+0x70>
		udd_ep_run( ep,
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
  403d32:	7bf9      	ldrb	r1, [r7, #15]
  403d34:	7bbb      	ldrb	r3, [r7, #14]
  403d36:	461a      	mov	r2, r3
  403d38:	0192      	lsls	r2, r2, #6
  403d3a:	441a      	add	r2, r3
  403d3c:	0193      	lsls	r3, r2, #6
  403d3e:	461a      	mov	r2, r3
  403d40:	460b      	mov	r3, r1
  403d42:	019b      	lsls	r3, r3, #6
  403d44:	440b      	add	r3, r1
  403d46:	01db      	lsls	r3, r3, #7
  403d48:	4413      	add	r3, r2
  403d4a:	4a12      	ldr	r2, [pc, #72]	; (403d94 <udi_cdc_data_received+0xa4>)
  403d4c:	441a      	add	r2, r3
		udd_ep_run( ep,
  403d4e:	79b8      	ldrb	r0, [r7, #6]
  403d50:	4b11      	ldr	r3, [pc, #68]	; (403d98 <udi_cdc_data_received+0xa8>)
  403d52:	9300      	str	r3, [sp, #0]
  403d54:	f44f 5382 	mov.w	r3, #4160	; 0x1040
  403d58:	2101      	movs	r1, #1
  403d5a:	4c10      	ldr	r4, [pc, #64]	; (403d9c <udi_cdc_data_received+0xac>)
  403d5c:	47a0      	blx	r4
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received);
		return;
  403d5e:	e013      	b.n	403d88 <udi_cdc_data_received+0x98>
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
  403d60:	7bfa      	ldrb	r2, [r7, #15]
  403d62:	7bbb      	ldrb	r3, [r7, #14]
  403d64:	6839      	ldr	r1, [r7, #0]
  403d66:	b288      	uxth	r0, r1
  403d68:	490d      	ldr	r1, [pc, #52]	; (403da0 <udi_cdc_data_received+0xb0>)
  403d6a:	0052      	lsls	r2, r2, #1
  403d6c:	4413      	add	r3, r2
  403d6e:	4602      	mov	r2, r0
  403d70:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	udi_cdc_rx_trans_ongoing[port] = false;
  403d74:	7bfb      	ldrb	r3, [r7, #15]
  403d76:	4a0b      	ldr	r2, [pc, #44]	; (403da4 <udi_cdc_data_received+0xb4>)
  403d78:	2100      	movs	r1, #0
  403d7a:	54d1      	strb	r1, [r2, r3]
	udi_cdc_rx_start(port);
  403d7c:	7bfb      	ldrb	r3, [r7, #15]
  403d7e:	4618      	mov	r0, r3
  403d80:	4b09      	ldr	r3, [pc, #36]	; (403da8 <udi_cdc_data_received+0xb8>)
  403d82:	4798      	blx	r3
  403d84:	e000      	b.n	403d88 <udi_cdc_data_received+0x98>
		return;
  403d86:	bf00      	nop
}
  403d88:	3714      	adds	r7, #20
  403d8a:	46bd      	mov	sp, r7
  403d8c:	bd90      	pop	{r4, r7, pc}
  403d8e:	bf00      	nop
  403d90:	20006704 	.word	0x20006704
  403d94:	20004680 	.word	0x20004680
  403d98:	00403cf1 	.word	0x00403cf1
  403d9c:	00405d5d 	.word	0x00405d5d
  403da0:	20006700 	.word	0x20006700
  403da4:	2000670c 	.word	0x2000670c
  403da8:	00403be9 	.word	0x00403be9

00403dac <udi_cdc_data_sent>:


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
  403dac:	b580      	push	{r7, lr}
  403dae:	b084      	sub	sp, #16
  403db0:	af00      	add	r7, sp, #0
  403db2:	4603      	mov	r3, r0
  403db4:	6039      	str	r1, [r7, #0]
  403db6:	71fb      	strb	r3, [r7, #7]
  403db8:	4613      	mov	r3, r2
  403dba:	71bb      	strb	r3, [r7, #6]
	uint8_t port;
	UNUSED(n);

	switch (ep) {
  403dbc:	79bb      	ldrb	r3, [r7, #6]
  403dbe:	2b81      	cmp	r3, #129	; 0x81
  403dc0:	d102      	bne.n	403dc8 <udi_cdc_data_sent+0x1c>
#define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_IN_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
  403dc2:	2300      	movs	r3, #0
  403dc4:	73fb      	strb	r3, [r7, #15]
  403dc6:	e002      	b.n	403dce <udi_cdc_data_sent+0x22>
#undef UDI_CDC_DATA_EP_IN_TO_PORT
	default:
		port = 0;
  403dc8:	2300      	movs	r3, #0
  403dca:	73fb      	strb	r3, [r7, #15]
		break;
  403dcc:	bf00      	nop
	}

	if (UDD_EP_TRANSFER_OK != status) {
  403dce:	79fb      	ldrb	r3, [r7, #7]
  403dd0:	2b00      	cmp	r3, #0
  403dd2:	d11d      	bne.n	403e10 <udi_cdc_data_sent+0x64>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
  403dd4:	7bfb      	ldrb	r3, [r7, #15]
  403dd6:	7bfa      	ldrb	r2, [r7, #15]
  403dd8:	490f      	ldr	r1, [pc, #60]	; (403e18 <udi_cdc_data_sent+0x6c>)
  403dda:	5c8a      	ldrb	r2, [r1, r2]
  403ddc:	b2d2      	uxtb	r2, r2
  403dde:	2a00      	cmp	r2, #0
  403de0:	bf0c      	ite	eq
  403de2:	2201      	moveq	r2, #1
  403de4:	2200      	movne	r2, #0
  403de6:	b2d2      	uxtb	r2, r2
  403de8:	4611      	mov	r1, r2
  403dea:	4a0c      	ldr	r2, [pc, #48]	; (403e1c <udi_cdc_data_sent+0x70>)
  403dec:	005b      	lsls	r3, r3, #1
  403dee:	440b      	add	r3, r1
  403df0:	2100      	movs	r1, #0
  403df2:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	udi_cdc_tx_both_buf_to_send[port] = false;
  403df6:	7bfb      	ldrb	r3, [r7, #15]
  403df8:	4a09      	ldr	r2, [pc, #36]	; (403e20 <udi_cdc_data_sent+0x74>)
  403dfa:	2100      	movs	r1, #0
  403dfc:	54d1      	strb	r1, [r2, r3]
	udi_cdc_tx_trans_ongoing[port] = false;
  403dfe:	7bfb      	ldrb	r3, [r7, #15]
  403e00:	4a08      	ldr	r2, [pc, #32]	; (403e24 <udi_cdc_data_sent+0x78>)
  403e02:	2100      	movs	r1, #0
  403e04:	54d1      	strb	r1, [r2, r3]

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
  403e06:	7bfb      	ldrb	r3, [r7, #15]
  403e08:	4618      	mov	r0, r3
  403e0a:	4b07      	ldr	r3, [pc, #28]	; (403e28 <udi_cdc_data_sent+0x7c>)
  403e0c:	4798      	blx	r3
  403e0e:	e000      	b.n	403e12 <udi_cdc_data_sent+0x66>
		return;
  403e10:	bf00      	nop
}
  403e12:	3710      	adds	r7, #16
  403e14:	46bd      	mov	sp, r7
  403e16:	bd80      	pop	{r7, pc}
  403e18:	20008794 	.word	0x20008794
  403e1c:	20008790 	.word	0x20008790
  403e20:	200087a0 	.word	0x200087a0
  403e24:	2000879c 	.word	0x2000879c
  403e28:	00403e2d 	.word	0x00403e2d

00403e2c <udi_cdc_tx_send>:


static void udi_cdc_tx_send(uint8_t port)
{
  403e2c:	b590      	push	{r4, r7, lr}
  403e2e:	b089      	sub	sp, #36	; 0x24
  403e30:	af02      	add	r7, sp, #8
  403e32:	4603      	mov	r3, r0
  403e34:	71fb      	strb	r3, [r7, #7]
	bool b_short_packet;
	udd_ep_id_t ep;
	static uint16_t sof_zlp_counter = 0;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  403e36:	2300      	movs	r3, #0
  403e38:	71fb      	strb	r3, [r7, #7]
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
  403e3a:	79fb      	ldrb	r3, [r7, #7]
  403e3c:	4a66      	ldr	r2, [pc, #408]	; (403fd8 <udi_cdc_tx_send+0x1ac>)
  403e3e:	5cd3      	ldrb	r3, [r2, r3]
  403e40:	b2db      	uxtb	r3, r3
  403e42:	2b00      	cmp	r3, #0
  403e44:	f040 80c2 	bne.w	403fcc <udi_cdc_tx_send+0x1a0>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
  403e48:	4b64      	ldr	r3, [pc, #400]	; (403fdc <udi_cdc_tx_send+0x1b0>)
  403e4a:	4798      	blx	r3
  403e4c:	4603      	mov	r3, r0
  403e4e:	2b00      	cmp	r3, #0
  403e50:	d009      	beq.n	403e66 <udi_cdc_tx_send+0x3a>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
  403e52:	79fb      	ldrb	r3, [r7, #7]
  403e54:	4a62      	ldr	r2, [pc, #392]	; (403fe0 <udi_cdc_tx_send+0x1b4>)
  403e56:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
  403e5a:	4b62      	ldr	r3, [pc, #392]	; (403fe4 <udi_cdc_tx_send+0x1b8>)
  403e5c:	4798      	blx	r3
  403e5e:	4603      	mov	r3, r0
  403e60:	429c      	cmp	r4, r3
  403e62:	d10a      	bne.n	403e7a <udi_cdc_tx_send+0x4e>
			return; // Wait next SOF to send next data
  403e64:	e0b5      	b.n	403fd2 <udi_cdc_tx_send+0x1a6>
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
  403e66:	79fb      	ldrb	r3, [r7, #7]
  403e68:	4a5d      	ldr	r2, [pc, #372]	; (403fe0 <udi_cdc_tx_send+0x1b4>)
  403e6a:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
  403e6e:	4b5e      	ldr	r3, [pc, #376]	; (403fe8 <udi_cdc_tx_send+0x1bc>)
  403e70:	4798      	blx	r3
  403e72:	4603      	mov	r3, r0
  403e74:	429c      	cmp	r4, r3
  403e76:	f000 80ab 	beq.w	403fd0 <udi_cdc_tx_send+0x1a4>
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
  403e7a:	4b5c      	ldr	r3, [pc, #368]	; (403fec <udi_cdc_tx_send+0x1c0>)
  403e7c:	4798      	blx	r3
  403e7e:	6138      	str	r0, [r7, #16]
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
  403e80:	79fb      	ldrb	r3, [r7, #7]
  403e82:	4a5b      	ldr	r2, [pc, #364]	; (403ff0 <udi_cdc_tx_send+0x1c4>)
  403e84:	5cd3      	ldrb	r3, [r2, r3]
  403e86:	75fb      	strb	r3, [r7, #23]
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
  403e88:	79fa      	ldrb	r2, [r7, #7]
  403e8a:	7dfb      	ldrb	r3, [r7, #23]
  403e8c:	4959      	ldr	r1, [pc, #356]	; (403ff4 <udi_cdc_tx_send+0x1c8>)
  403e8e:	0052      	lsls	r2, r2, #1
  403e90:	4413      	add	r3, r2
  403e92:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  403e96:	2b00      	cmp	r3, #0
  403e98:	d11f      	bne.n	403eda <udi_cdc_tx_send+0xae>
		sof_zlp_counter++;
  403e9a:	4b57      	ldr	r3, [pc, #348]	; (403ff8 <udi_cdc_tx_send+0x1cc>)
  403e9c:	881b      	ldrh	r3, [r3, #0]
  403e9e:	3301      	adds	r3, #1
  403ea0:	b29a      	uxth	r2, r3
  403ea2:	4b55      	ldr	r3, [pc, #340]	; (403ff8 <udi_cdc_tx_send+0x1cc>)
  403ea4:	801a      	strh	r2, [r3, #0]
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
  403ea6:	4b4d      	ldr	r3, [pc, #308]	; (403fdc <udi_cdc_tx_send+0x1b0>)
  403ea8:	4798      	blx	r3
  403eaa:	4603      	mov	r3, r0
  403eac:	f083 0301 	eor.w	r3, r3, #1
  403eb0:	b2db      	uxtb	r3, r3
  403eb2:	2b00      	cmp	r3, #0
  403eb4:	d003      	beq.n	403ebe <udi_cdc_tx_send+0x92>
  403eb6:	4b50      	ldr	r3, [pc, #320]	; (403ff8 <udi_cdc_tx_send+0x1cc>)
  403eb8:	881b      	ldrh	r3, [r3, #0]
  403eba:	2b63      	cmp	r3, #99	; 0x63
  403ebc:	d909      	bls.n	403ed2 <udi_cdc_tx_send+0xa6>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
  403ebe:	4b47      	ldr	r3, [pc, #284]	; (403fdc <udi_cdc_tx_send+0x1b0>)
  403ec0:	4798      	blx	r3
  403ec2:	4603      	mov	r3, r0
  403ec4:	2b00      	cmp	r3, #0
  403ec6:	d008      	beq.n	403eda <udi_cdc_tx_send+0xae>
  403ec8:	4b4b      	ldr	r3, [pc, #300]	; (403ff8 <udi_cdc_tx_send+0x1cc>)
  403eca:	881b      	ldrh	r3, [r3, #0]
  403ecc:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
  403ed0:	d203      	bcs.n	403eda <udi_cdc_tx_send+0xae>
			cpu_irq_restore(flags);
  403ed2:	6938      	ldr	r0, [r7, #16]
  403ed4:	4b49      	ldr	r3, [pc, #292]	; (403ffc <udi_cdc_tx_send+0x1d0>)
  403ed6:	4798      	blx	r3
			return;
  403ed8:	e07b      	b.n	403fd2 <udi_cdc_tx_send+0x1a6>
		}
	}
	sof_zlp_counter = 0;
  403eda:	4b47      	ldr	r3, [pc, #284]	; (403ff8 <udi_cdc_tx_send+0x1cc>)
  403edc:	2200      	movs	r2, #0
  403ede:	801a      	strh	r2, [r3, #0]

	if (!udi_cdc_tx_both_buf_to_send[port]) {
  403ee0:	79fb      	ldrb	r3, [r7, #7]
  403ee2:	4a47      	ldr	r2, [pc, #284]	; (404000 <udi_cdc_tx_send+0x1d4>)
  403ee4:	5cd3      	ldrb	r3, [r2, r3]
  403ee6:	b2db      	uxtb	r3, r3
  403ee8:	f083 0301 	eor.w	r3, r3, #1
  403eec:	b2db      	uxtb	r3, r3
  403eee:	2b00      	cmp	r3, #0
  403ef0:	d00a      	beq.n	403f08 <udi_cdc_tx_send+0xdc>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
  403ef2:	79fb      	ldrb	r3, [r7, #7]
  403ef4:	7dfa      	ldrb	r2, [r7, #23]
  403ef6:	2a00      	cmp	r2, #0
  403ef8:	bf0c      	ite	eq
  403efa:	2201      	moveq	r2, #1
  403efc:	2200      	movne	r2, #0
  403efe:	b2d2      	uxtb	r2, r2
  403f00:	4611      	mov	r1, r2
  403f02:	4a3b      	ldr	r2, [pc, #236]	; (403ff0 <udi_cdc_tx_send+0x1c4>)
  403f04:	54d1      	strb	r1, [r2, r3]
  403f06:	e006      	b.n	403f16 <udi_cdc_tx_send+0xea>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
  403f08:	7dfb      	ldrb	r3, [r7, #23]
  403f0a:	2b00      	cmp	r3, #0
  403f0c:	bf0c      	ite	eq
  403f0e:	2301      	moveq	r3, #1
  403f10:	2300      	movne	r3, #0
  403f12:	b2db      	uxtb	r3, r3
  403f14:	75fb      	strb	r3, [r7, #23]
	}
	udi_cdc_tx_trans_ongoing[port] = true;
  403f16:	79fb      	ldrb	r3, [r7, #7]
  403f18:	4a2f      	ldr	r2, [pc, #188]	; (403fd8 <udi_cdc_tx_send+0x1ac>)
  403f1a:	2101      	movs	r1, #1
  403f1c:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
  403f1e:	6938      	ldr	r0, [r7, #16]
  403f20:	4b36      	ldr	r3, [pc, #216]	; (403ffc <udi_cdc_tx_send+0x1d0>)
  403f22:	4798      	blx	r3

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
  403f24:	79fa      	ldrb	r2, [r7, #7]
  403f26:	7dfb      	ldrb	r3, [r7, #23]
  403f28:	4932      	ldr	r1, [pc, #200]	; (403ff4 <udi_cdc_tx_send+0x1c8>)
  403f2a:	0052      	lsls	r2, r2, #1
  403f2c:	4413      	add	r3, r2
  403f2e:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  403f32:	f5b3 5f82 	cmp.w	r3, #4160	; 0x1040
  403f36:	bf14      	ite	ne
  403f38:	2301      	movne	r3, #1
  403f3a:	2300      	moveq	r3, #0
  403f3c:	73fb      	strb	r3, [r7, #15]
	if (b_short_packet) {
  403f3e:	7bfb      	ldrb	r3, [r7, #15]
  403f40:	2b00      	cmp	r3, #0
  403f42:	d016      	beq.n	403f72 <udi_cdc_tx_send+0x146>
		if (udd_is_high_speed()) {
  403f44:	4b25      	ldr	r3, [pc, #148]	; (403fdc <udi_cdc_tx_send+0x1b0>)
  403f46:	4798      	blx	r3
  403f48:	4603      	mov	r3, r0
  403f4a:	2b00      	cmp	r3, #0
  403f4c:	d008      	beq.n	403f60 <udi_cdc_tx_send+0x134>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
  403f4e:	79fc      	ldrb	r4, [r7, #7]
  403f50:	4b24      	ldr	r3, [pc, #144]	; (403fe4 <udi_cdc_tx_send+0x1b8>)
  403f52:	4798      	blx	r3
  403f54:	4603      	mov	r3, r0
  403f56:	461a      	mov	r2, r3
  403f58:	4b21      	ldr	r3, [pc, #132]	; (403fe0 <udi_cdc_tx_send+0x1b4>)
  403f5a:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  403f5e:	e00d      	b.n	403f7c <udi_cdc_tx_send+0x150>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
  403f60:	79fc      	ldrb	r4, [r7, #7]
  403f62:	4b21      	ldr	r3, [pc, #132]	; (403fe8 <udi_cdc_tx_send+0x1bc>)
  403f64:	4798      	blx	r3
  403f66:	4603      	mov	r3, r0
  403f68:	461a      	mov	r2, r3
  403f6a:	4b1d      	ldr	r3, [pc, #116]	; (403fe0 <udi_cdc_tx_send+0x1b4>)
  403f6c:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
  403f70:	e004      	b.n	403f7c <udi_cdc_tx_send+0x150>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
  403f72:	79fb      	ldrb	r3, [r7, #7]
  403f74:	4a1a      	ldr	r2, [pc, #104]	; (403fe0 <udi_cdc_tx_send+0x1b4>)
  403f76:	2100      	movs	r1, #0
  403f78:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	}

	// Send the buffer with enable of short packet
	switch (port) {
  403f7c:	79fb      	ldrb	r3, [r7, #7]
  403f7e:	2b00      	cmp	r3, #0
  403f80:	d102      	bne.n	403f88 <udi_cdc_tx_send+0x15c>
#define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_IN_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
  403f82:	2381      	movs	r3, #129	; 0x81
  403f84:	75bb      	strb	r3, [r7, #22]
  403f86:	e002      	b.n	403f8e <udi_cdc_tx_send+0x162>
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
  403f88:	2381      	movs	r3, #129	; 0x81
  403f8a:	75bb      	strb	r3, [r7, #22]
		break;
  403f8c:	bf00      	nop
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
  403f8e:	79f9      	ldrb	r1, [r7, #7]
  403f90:	7dfb      	ldrb	r3, [r7, #23]
  403f92:	461a      	mov	r2, r3
  403f94:	0192      	lsls	r2, r2, #6
  403f96:	441a      	add	r2, r3
  403f98:	0193      	lsls	r3, r2, #6
  403f9a:	461a      	mov	r2, r3
  403f9c:	460b      	mov	r3, r1
  403f9e:	019b      	lsls	r3, r3, #6
  403fa0:	440b      	add	r3, r1
  403fa2:	01db      	lsls	r3, r3, #7
  403fa4:	4413      	add	r3, r2
  403fa6:	4a17      	ldr	r2, [pc, #92]	; (404004 <udi_cdc_tx_send+0x1d8>)
  403fa8:	189c      	adds	r4, r3, r2
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
  403faa:	79fa      	ldrb	r2, [r7, #7]
  403fac:	7dfb      	ldrb	r3, [r7, #23]
  403fae:	4911      	ldr	r1, [pc, #68]	; (403ff4 <udi_cdc_tx_send+0x1c8>)
  403fb0:	0052      	lsls	r2, r2, #1
  403fb2:	4413      	add	r3, r2
  403fb4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
	udd_ep_run( ep,
  403fb8:	461a      	mov	r2, r3
  403fba:	7bf9      	ldrb	r1, [r7, #15]
  403fbc:	7db8      	ldrb	r0, [r7, #22]
  403fbe:	4b12      	ldr	r3, [pc, #72]	; (404008 <udi_cdc_tx_send+0x1dc>)
  403fc0:	9300      	str	r3, [sp, #0]
  403fc2:	4613      	mov	r3, r2
  403fc4:	4622      	mov	r2, r4
  403fc6:	4c11      	ldr	r4, [pc, #68]	; (40400c <udi_cdc_tx_send+0x1e0>)
  403fc8:	47a0      	blx	r4
  403fca:	e002      	b.n	403fd2 <udi_cdc_tx_send+0x1a6>
		return; // Already on going or wait next SOF to send next data
  403fcc:	bf00      	nop
  403fce:	e000      	b.n	403fd2 <udi_cdc_tx_send+0x1a6>
			return; // Wait next SOF to send next data
  403fd0:	bf00      	nop
			udi_cdc_data_sent);
}
  403fd2:	371c      	adds	r7, #28
  403fd4:	46bd      	mov	sp, r7
  403fd6:	bd90      	pop	{r4, r7, pc}
  403fd8:	2000879c 	.word	0x2000879c
  403fdc:	0040579d 	.word	0x0040579d
  403fe0:	20008798 	.word	0x20008798
  403fe4:	00405861 	.word	0x00405861
  403fe8:	00405841 	.word	0x00405841
  403fec:	004037a5 	.word	0x004037a5
  403ff0:	20008794 	.word	0x20008794
  403ff4:	20008790 	.word	0x20008790
  403ff8:	200087a2 	.word	0x200087a2
  403ffc:	004037fd 	.word	0x004037fd
  404000:	200087a0 	.word	0x200087a0
  404004:	20006710 	.word	0x20006710
  404008:	00403dad 	.word	0x00403dad
  40400c:	00405d5d 	.word	0x00405d5d

00404010 <udi_cdc_multi_get_nb_received_data>:
{
	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
}

iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
{
  404010:	b580      	push	{r7, lr}
  404012:	b086      	sub	sp, #24
  404014:	af00      	add	r7, sp, #0
  404016:	4603      	mov	r3, r0
  404018:	71fb      	strb	r3, [r7, #7]
	irqflags_t flags;
	uint16_t pos;
	iram_size_t nb_received;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  40401a:	2300      	movs	r3, #0
  40401c:	71fb      	strb	r3, [r7, #7]
#endif
	flags = cpu_irq_save();
  40401e:	4b10      	ldr	r3, [pc, #64]	; (404060 <udi_cdc_multi_get_nb_received_data+0x50>)
  404020:	4798      	blx	r3
  404022:	6178      	str	r0, [r7, #20]
	pos = udi_cdc_rx_pos[port];
  404024:	79fb      	ldrb	r3, [r7, #7]
  404026:	4a0f      	ldr	r2, [pc, #60]	; (404064 <udi_cdc_multi_get_nb_received_data+0x54>)
  404028:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  40402c:	827b      	strh	r3, [r7, #18]
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
  40402e:	79fb      	ldrb	r3, [r7, #7]
  404030:	79fa      	ldrb	r2, [r7, #7]
  404032:	490d      	ldr	r1, [pc, #52]	; (404068 <udi_cdc_multi_get_nb_received_data+0x58>)
  404034:	5c8a      	ldrb	r2, [r1, r2]
  404036:	b2d2      	uxtb	r2, r2
  404038:	4611      	mov	r1, r2
  40403a:	4a0c      	ldr	r2, [pc, #48]	; (40406c <udi_cdc_multi_get_nb_received_data+0x5c>)
  40403c:	005b      	lsls	r3, r3, #1
  40403e:	440b      	add	r3, r1
  404040:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  404044:	b29b      	uxth	r3, r3
  404046:	461a      	mov	r2, r3
  404048:	8a7b      	ldrh	r3, [r7, #18]
  40404a:	1ad3      	subs	r3, r2, r3
  40404c:	60fb      	str	r3, [r7, #12]
	cpu_irq_restore(flags);
  40404e:	6978      	ldr	r0, [r7, #20]
  404050:	4b07      	ldr	r3, [pc, #28]	; (404070 <udi_cdc_multi_get_nb_received_data+0x60>)
  404052:	4798      	blx	r3
	return nb_received;
  404054:	68fb      	ldr	r3, [r7, #12]
}
  404056:	4618      	mov	r0, r3
  404058:	3718      	adds	r7, #24
  40405a:	46bd      	mov	sp, r7
  40405c:	bd80      	pop	{r7, pc}
  40405e:	bf00      	nop
  404060:	004037a5 	.word	0x004037a5
  404064:	20006708 	.word	0x20006708
  404068:	20006704 	.word	0x20006704
  40406c:	20006700 	.word	0x20006700
  404070:	004037fd 	.word	0x004037fd

00404074 <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
  404074:	b580      	push	{r7, lr}
  404076:	b082      	sub	sp, #8
  404078:	af00      	add	r7, sp, #0
  40407a:	4603      	mov	r3, r0
  40407c:	71fb      	strb	r3, [r7, #7]
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
  40407e:	79fb      	ldrb	r3, [r7, #7]
  404080:	4618      	mov	r0, r3
  404082:	4b06      	ldr	r3, [pc, #24]	; (40409c <udi_cdc_multi_is_rx_ready+0x28>)
  404084:	4798      	blx	r3
  404086:	4603      	mov	r3, r0
  404088:	2b00      	cmp	r3, #0
  40408a:	bf14      	ite	ne
  40408c:	2301      	movne	r3, #1
  40408e:	2300      	moveq	r3, #0
  404090:	b2db      	uxtb	r3, r3
}
  404092:	4618      	mov	r0, r3
  404094:	3708      	adds	r7, #8
  404096:	46bd      	mov	sp, r7
  404098:	bd80      	pop	{r7, pc}
  40409a:	bf00      	nop
  40409c:	00404011 	.word	0x00404011

004040a0 <udi_cdc_multi_getc>:
{
	return udi_cdc_multi_is_rx_ready(0);
}

int udi_cdc_multi_getc(uint8_t port)
{
  4040a0:	b590      	push	{r4, r7, lr}
  4040a2:	b087      	sub	sp, #28
  4040a4:	af00      	add	r7, sp, #0
  4040a6:	4603      	mov	r3, r0
  4040a8:	71fb      	strb	r3, [r7, #7]
	irqflags_t flags;
	int rx_data = 0;
  4040aa:	2300      	movs	r3, #0
  4040ac:	617b      	str	r3, [r7, #20]
	uint16_t pos;
	uint8_t buf_sel;
	bool again;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  4040ae:	2300      	movs	r3, #0
  4040b0:	71fb      	strb	r3, [r7, #7]
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
  4040b2:	79fa      	ldrb	r2, [r7, #7]
  4040b4:	4931      	ldr	r1, [pc, #196]	; (40417c <udi_cdc_multi_getc+0xdc>)
  4040b6:	4613      	mov	r3, r2
  4040b8:	00db      	lsls	r3, r3, #3
  4040ba:	1a9b      	subs	r3, r3, r2
  4040bc:	440b      	add	r3, r1
  4040be:	3306      	adds	r3, #6
  4040c0:	781b      	ldrb	r3, [r3, #0]
  4040c2:	2b09      	cmp	r3, #9
  4040c4:	bf0c      	ite	eq
  4040c6:	2301      	moveq	r3, #1
  4040c8:	2300      	movne	r3, #0
  4040ca:	74fb      	strb	r3, [r7, #19]

udi_cdc_getc_process_one_byte:
	// Check available data
	flags = cpu_irq_save();
  4040cc:	4b2c      	ldr	r3, [pc, #176]	; (404180 <udi_cdc_multi_getc+0xe0>)
  4040ce:	4798      	blx	r3
  4040d0:	60f8      	str	r0, [r7, #12]
	pos = udi_cdc_rx_pos[port];
  4040d2:	79fb      	ldrb	r3, [r7, #7]
  4040d4:	4a2b      	ldr	r2, [pc, #172]	; (404184 <udi_cdc_multi_getc+0xe4>)
  4040d6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  4040da:	817b      	strh	r3, [r7, #10]
	buf_sel = udi_cdc_rx_buf_sel[port];
  4040dc:	79fb      	ldrb	r3, [r7, #7]
  4040de:	4a2a      	ldr	r2, [pc, #168]	; (404188 <udi_cdc_multi_getc+0xe8>)
  4040e0:	5cd3      	ldrb	r3, [r2, r3]
  4040e2:	727b      	strb	r3, [r7, #9]
	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
  4040e4:	79fa      	ldrb	r2, [r7, #7]
  4040e6:	7a7b      	ldrb	r3, [r7, #9]
  4040e8:	4928      	ldr	r1, [pc, #160]	; (40418c <udi_cdc_multi_getc+0xec>)
  4040ea:	0052      	lsls	r2, r2, #1
  4040ec:	4413      	add	r3, r2
  4040ee:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  4040f2:	b29b      	uxth	r3, r3
  4040f4:	897a      	ldrh	r2, [r7, #10]
  4040f6:	429a      	cmp	r2, r3
  4040f8:	bf2c      	ite	cs
  4040fa:	2301      	movcs	r3, #1
  4040fc:	2300      	movcc	r3, #0
  4040fe:	723b      	strb	r3, [r7, #8]
	cpu_irq_restore(flags);
  404100:	68f8      	ldr	r0, [r7, #12]
  404102:	4b23      	ldr	r3, [pc, #140]	; (404190 <udi_cdc_multi_getc+0xf0>)
  404104:	4798      	blx	r3
	while (again) {
  404106:	7a3b      	ldrb	r3, [r7, #8]
  404108:	2b00      	cmp	r3, #0
  40410a:	d009      	beq.n	404120 <udi_cdc_multi_getc+0x80>
		if (!udi_cdc_data_running) {
  40410c:	4b21      	ldr	r3, [pc, #132]	; (404194 <udi_cdc_multi_getc+0xf4>)
  40410e:	781b      	ldrb	r3, [r3, #0]
  404110:	b2db      	uxtb	r3, r3
  404112:	f083 0301 	eor.w	r3, r3, #1
  404116:	b2db      	uxtb	r3, r3
  404118:	2b00      	cmp	r3, #0
  40411a:	d0d7      	beq.n	4040cc <udi_cdc_multi_getc+0x2c>
			return 0;
  40411c:	2300      	movs	r3, #0
  40411e:	e029      	b.n	404174 <udi_cdc_multi_getc+0xd4>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
  404120:	79f9      	ldrb	r1, [r7, #7]
  404122:	7a7b      	ldrb	r3, [r7, #9]
  404124:	8978      	ldrh	r0, [r7, #10]
  404126:	4c1c      	ldr	r4, [pc, #112]	; (404198 <udi_cdc_multi_getc+0xf8>)
  404128:	461a      	mov	r2, r3
  40412a:	0192      	lsls	r2, r2, #6
  40412c:	441a      	add	r2, r3
  40412e:	0193      	lsls	r3, r2, #6
  404130:	461a      	mov	r2, r3
  404132:	460b      	mov	r3, r1
  404134:	019b      	lsls	r3, r3, #6
  404136:	440b      	add	r3, r1
  404138:	01db      	lsls	r3, r3, #7
  40413a:	4413      	add	r3, r2
  40413c:	4423      	add	r3, r4
  40413e:	4403      	add	r3, r0
  404140:	781b      	ldrb	r3, [r3, #0]
  404142:	461a      	mov	r2, r3
  404144:	697b      	ldr	r3, [r7, #20]
  404146:	4313      	orrs	r3, r2
  404148:	617b      	str	r3, [r7, #20]
	udi_cdc_rx_pos[port] = pos+1;
  40414a:	79fb      	ldrb	r3, [r7, #7]
  40414c:	897a      	ldrh	r2, [r7, #10]
  40414e:	3201      	adds	r2, #1
  404150:	b291      	uxth	r1, r2
  404152:	4a0c      	ldr	r2, [pc, #48]	; (404184 <udi_cdc_multi_getc+0xe4>)
  404154:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]

	udi_cdc_rx_start(port);
  404158:	79fb      	ldrb	r3, [r7, #7]
  40415a:	4618      	mov	r0, r3
  40415c:	4b0f      	ldr	r3, [pc, #60]	; (40419c <udi_cdc_multi_getc+0xfc>)
  40415e:	4798      	blx	r3

	if (b_databit_9) {
  404160:	7cfb      	ldrb	r3, [r7, #19]
  404162:	2b00      	cmp	r3, #0
  404164:	d005      	beq.n	404172 <udi_cdc_multi_getc+0xd2>
		// Receive MSB
		b_databit_9 = false;
  404166:	2300      	movs	r3, #0
  404168:	74fb      	strb	r3, [r7, #19]
		rx_data = rx_data << 8;
  40416a:	697b      	ldr	r3, [r7, #20]
  40416c:	021b      	lsls	r3, r3, #8
  40416e:	617b      	str	r3, [r7, #20]
		goto udi_cdc_getc_process_one_byte;
  404170:	e7ac      	b.n	4040cc <udi_cdc_multi_getc+0x2c>
	}
	return rx_data;
  404172:	697b      	ldr	r3, [r7, #20]
}
  404174:	4618      	mov	r0, r3
  404176:	371c      	adds	r7, #28
  404178:	46bd      	mov	sp, r7
  40417a:	bd90      	pop	{r4, r7, pc}
  40417c:	20004664 	.word	0x20004664
  404180:	004037a5 	.word	0x004037a5
  404184:	20006708 	.word	0x20006708
  404188:	20006704 	.word	0x20006704
  40418c:	20006700 	.word	0x20006700
  404190:	004037fd 	.word	0x004037fd
  404194:	2000467c 	.word	0x2000467c
  404198:	20004680 	.word	0x20004680
  40419c:	00403be9 	.word	0x00403be9

004041a0 <udi_cdc_getc>:

int udi_cdc_getc(void)
{
  4041a0:	b580      	push	{r7, lr}
  4041a2:	af00      	add	r7, sp, #0
	return udi_cdc_multi_getc(0);
  4041a4:	2000      	movs	r0, #0
  4041a6:	4b02      	ldr	r3, [pc, #8]	; (4041b0 <udi_cdc_getc+0x10>)
  4041a8:	4798      	blx	r3
  4041aa:	4603      	mov	r3, r0
}
  4041ac:	4618      	mov	r0, r3
  4041ae:	bd80      	pop	{r7, pc}
  4041b0:	004040a1 	.word	0x004040a1

004041b4 <udi_cdc_multi_read_buf>:

iram_size_t udi_cdc_multi_read_buf(uint8_t port, void* buf, iram_size_t size)
{
  4041b4:	b580      	push	{r7, lr}
  4041b6:	b088      	sub	sp, #32
  4041b8:	af00      	add	r7, sp, #0
  4041ba:	4603      	mov	r3, r0
  4041bc:	60b9      	str	r1, [r7, #8]
  4041be:	607a      	str	r2, [r7, #4]
  4041c0:	73fb      	strb	r3, [r7, #15]
	irqflags_t flags;
	uint8_t *ptr_buf = (uint8_t *)buf;
  4041c2:	68bb      	ldr	r3, [r7, #8]
  4041c4:	61fb      	str	r3, [r7, #28]
	uint16_t pos;
	uint8_t buf_sel;
	bool again;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  4041c6:	2300      	movs	r3, #0
  4041c8:	73fb      	strb	r3, [r7, #15]
#endif

udi_cdc_read_buf_loop_wait:
	// Check available data
	flags = cpu_irq_save();
  4041ca:	4b39      	ldr	r3, [pc, #228]	; (4042b0 <udi_cdc_multi_read_buf+0xfc>)
  4041cc:	4798      	blx	r3
  4041ce:	6178      	str	r0, [r7, #20]
	pos = udi_cdc_rx_pos[port];
  4041d0:	7bfb      	ldrb	r3, [r7, #15]
  4041d2:	4a38      	ldr	r2, [pc, #224]	; (4042b4 <udi_cdc_multi_read_buf+0x100>)
  4041d4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  4041d8:	827b      	strh	r3, [r7, #18]
	buf_sel = udi_cdc_rx_buf_sel[port];
  4041da:	7bfb      	ldrb	r3, [r7, #15]
  4041dc:	4a36      	ldr	r2, [pc, #216]	; (4042b8 <udi_cdc_multi_read_buf+0x104>)
  4041de:	5cd3      	ldrb	r3, [r2, r3]
  4041e0:	747b      	strb	r3, [r7, #17]
	again = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
  4041e2:	7bfa      	ldrb	r2, [r7, #15]
  4041e4:	7c7b      	ldrb	r3, [r7, #17]
  4041e6:	4935      	ldr	r1, [pc, #212]	; (4042bc <udi_cdc_multi_read_buf+0x108>)
  4041e8:	0052      	lsls	r2, r2, #1
  4041ea:	4413      	add	r3, r2
  4041ec:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  4041f0:	b29b      	uxth	r3, r3
  4041f2:	8a7a      	ldrh	r2, [r7, #18]
  4041f4:	429a      	cmp	r2, r3
  4041f6:	bf2c      	ite	cs
  4041f8:	2301      	movcs	r3, #1
  4041fa:	2300      	movcc	r3, #0
  4041fc:	743b      	strb	r3, [r7, #16]
	cpu_irq_restore(flags);
  4041fe:	6978      	ldr	r0, [r7, #20]
  404200:	4b2f      	ldr	r3, [pc, #188]	; (4042c0 <udi_cdc_multi_read_buf+0x10c>)
  404202:	4798      	blx	r3
	while (again) {
  404204:	7c3b      	ldrb	r3, [r7, #16]
  404206:	2b00      	cmp	r3, #0
  404208:	d009      	beq.n	40421e <udi_cdc_multi_read_buf+0x6a>
		if (!udi_cdc_data_running) {
  40420a:	4b2e      	ldr	r3, [pc, #184]	; (4042c4 <udi_cdc_multi_read_buf+0x110>)
  40420c:	781b      	ldrb	r3, [r3, #0]
  40420e:	b2db      	uxtb	r3, r3
  404210:	f083 0301 	eor.w	r3, r3, #1
  404214:	b2db      	uxtb	r3, r3
  404216:	2b00      	cmp	r3, #0
  404218:	d0d7      	beq.n	4041ca <udi_cdc_multi_read_buf+0x16>
			return size;
  40421a:	687b      	ldr	r3, [r7, #4]
  40421c:	e044      	b.n	4042a8 <udi_cdc_multi_read_buf+0xf4>
		}
		goto udi_cdc_read_buf_loop_wait;
	}

	// Read data
	copy_nb = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
  40421e:	7bfa      	ldrb	r2, [r7, #15]
  404220:	7c7b      	ldrb	r3, [r7, #17]
  404222:	4926      	ldr	r1, [pc, #152]	; (4042bc <udi_cdc_multi_read_buf+0x108>)
  404224:	0052      	lsls	r2, r2, #1
  404226:	4413      	add	r3, r2
  404228:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  40422c:	b29b      	uxth	r3, r3
  40422e:	461a      	mov	r2, r3
  404230:	8a7b      	ldrh	r3, [r7, #18]
  404232:	1ad3      	subs	r3, r2, r3
  404234:	61bb      	str	r3, [r7, #24]
	if (copy_nb>size) {
  404236:	69ba      	ldr	r2, [r7, #24]
  404238:	687b      	ldr	r3, [r7, #4]
  40423a:	429a      	cmp	r2, r3
  40423c:	d901      	bls.n	404242 <udi_cdc_multi_read_buf+0x8e>
		copy_nb = size;
  40423e:	687b      	ldr	r3, [r7, #4]
  404240:	61bb      	str	r3, [r7, #24]
	}
	memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], copy_nb);
  404242:	7bf9      	ldrb	r1, [r7, #15]
  404244:	7c7b      	ldrb	r3, [r7, #17]
  404246:	8a78      	ldrh	r0, [r7, #18]
  404248:	461a      	mov	r2, r3
  40424a:	0192      	lsls	r2, r2, #6
  40424c:	441a      	add	r2, r3
  40424e:	0193      	lsls	r3, r2, #6
  404250:	461a      	mov	r2, r3
  404252:	460b      	mov	r3, r1
  404254:	019b      	lsls	r3, r3, #6
  404256:	440b      	add	r3, r1
  404258:	01db      	lsls	r3, r3, #7
  40425a:	4413      	add	r3, r2
  40425c:	4403      	add	r3, r0
  40425e:	4a1a      	ldr	r2, [pc, #104]	; (4042c8 <udi_cdc_multi_read_buf+0x114>)
  404260:	4413      	add	r3, r2
  404262:	69ba      	ldr	r2, [r7, #24]
  404264:	4619      	mov	r1, r3
  404266:	69f8      	ldr	r0, [r7, #28]
  404268:	4b18      	ldr	r3, [pc, #96]	; (4042cc <udi_cdc_multi_read_buf+0x118>)
  40426a:	4798      	blx	r3
	udi_cdc_rx_pos[port] += copy_nb;
  40426c:	7bfb      	ldrb	r3, [r7, #15]
  40426e:	7bfa      	ldrb	r2, [r7, #15]
  404270:	4910      	ldr	r1, [pc, #64]	; (4042b4 <udi_cdc_multi_read_buf+0x100>)
  404272:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
  404276:	b291      	uxth	r1, r2
  404278:	69ba      	ldr	r2, [r7, #24]
  40427a:	b292      	uxth	r2, r2
  40427c:	440a      	add	r2, r1
  40427e:	b291      	uxth	r1, r2
  404280:	4a0c      	ldr	r2, [pc, #48]	; (4042b4 <udi_cdc_multi_read_buf+0x100>)
  404282:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	ptr_buf += copy_nb;
  404286:	69fa      	ldr	r2, [r7, #28]
  404288:	69bb      	ldr	r3, [r7, #24]
  40428a:	4413      	add	r3, r2
  40428c:	61fb      	str	r3, [r7, #28]
	size -= copy_nb;
  40428e:	687a      	ldr	r2, [r7, #4]
  404290:	69bb      	ldr	r3, [r7, #24]
  404292:	1ad3      	subs	r3, r2, r3
  404294:	607b      	str	r3, [r7, #4]
	udi_cdc_rx_start(port);
  404296:	7bfb      	ldrb	r3, [r7, #15]
  404298:	4618      	mov	r0, r3
  40429a:	4b0d      	ldr	r3, [pc, #52]	; (4042d0 <udi_cdc_multi_read_buf+0x11c>)
  40429c:	4798      	blx	r3

	if (size) {
  40429e:	687b      	ldr	r3, [r7, #4]
  4042a0:	2b00      	cmp	r3, #0
  4042a2:	d000      	beq.n	4042a6 <udi_cdc_multi_read_buf+0xf2>
		goto udi_cdc_read_buf_loop_wait;
  4042a4:	e791      	b.n	4041ca <udi_cdc_multi_read_buf+0x16>
	}
	return 0;
  4042a6:	2300      	movs	r3, #0
}
  4042a8:	4618      	mov	r0, r3
  4042aa:	3720      	adds	r7, #32
  4042ac:	46bd      	mov	sp, r7
  4042ae:	bd80      	pop	{r7, pc}
  4042b0:	004037a5 	.word	0x004037a5
  4042b4:	20006708 	.word	0x20006708
  4042b8:	20006704 	.word	0x20006704
  4042bc:	20006700 	.word	0x20006700
  4042c0:	004037fd 	.word	0x004037fd
  4042c4:	2000467c 	.word	0x2000467c
  4042c8:	20004680 	.word	0x20004680
  4042cc:	0040a635 	.word	0x0040a635
  4042d0:	00403be9 	.word	0x00403be9

004042d4 <udi_cdc_read_buf>:
{
	return udi_cdc_multi_read_no_polling(0, buf, size);
}

iram_size_t udi_cdc_read_buf(void* buf, iram_size_t size)
{
  4042d4:	b580      	push	{r7, lr}
  4042d6:	b082      	sub	sp, #8
  4042d8:	af00      	add	r7, sp, #0
  4042da:	6078      	str	r0, [r7, #4]
  4042dc:	6039      	str	r1, [r7, #0]
	return udi_cdc_multi_read_buf(0, buf, size);
  4042de:	683a      	ldr	r2, [r7, #0]
  4042e0:	6879      	ldr	r1, [r7, #4]
  4042e2:	2000      	movs	r0, #0
  4042e4:	4b03      	ldr	r3, [pc, #12]	; (4042f4 <udi_cdc_read_buf+0x20>)
  4042e6:	4798      	blx	r3
  4042e8:	4603      	mov	r3, r0
}
  4042ea:	4618      	mov	r0, r3
  4042ec:	3708      	adds	r7, #8
  4042ee:	46bd      	mov	sp, r7
  4042f0:	bd80      	pop	{r7, pc}
  4042f2:	bf00      	nop
  4042f4:	004041b5 	.word	0x004041b5

004042f8 <udi_cdc_multi_get_free_tx_buffer>:

iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port)
{
  4042f8:	b580      	push	{r7, lr}
  4042fa:	b086      	sub	sp, #24
  4042fc:	af00      	add	r7, sp, #0
  4042fe:	4603      	mov	r3, r0
  404300:	71fb      	strb	r3, [r7, #7]
	irqflags_t flags;
	iram_size_t buf_sel_nb, retval;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  404302:	2300      	movs	r3, #0
  404304:	71fb      	strb	r3, [r7, #7]
#endif

	flags = cpu_irq_save();
  404306:	4b20      	ldr	r3, [pc, #128]	; (404388 <udi_cdc_multi_get_free_tx_buffer+0x90>)
  404308:	4798      	blx	r3
  40430a:	6138      	str	r0, [r7, #16]
	buf_sel = udi_cdc_tx_buf_sel[port];
  40430c:	79fb      	ldrb	r3, [r7, #7]
  40430e:	4a1f      	ldr	r2, [pc, #124]	; (40438c <udi_cdc_multi_get_free_tx_buffer+0x94>)
  404310:	5cd3      	ldrb	r3, [r2, r3]
  404312:	73fb      	strb	r3, [r7, #15]
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
  404314:	79fa      	ldrb	r2, [r7, #7]
  404316:	7bfb      	ldrb	r3, [r7, #15]
  404318:	491d      	ldr	r1, [pc, #116]	; (404390 <udi_cdc_multi_get_free_tx_buffer+0x98>)
  40431a:	0052      	lsls	r2, r2, #1
  40431c:	4413      	add	r3, r2
  40431e:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  404322:	617b      	str	r3, [r7, #20]
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
  404324:	697b      	ldr	r3, [r7, #20]
  404326:	f5b3 5f82 	cmp.w	r3, #4160	; 0x1040
  40432a:	d121      	bne.n	404370 <udi_cdc_multi_get_free_tx_buffer+0x78>
		if ((!udi_cdc_tx_trans_ongoing[port])
  40432c:	79fb      	ldrb	r3, [r7, #7]
  40432e:	4a19      	ldr	r2, [pc, #100]	; (404394 <udi_cdc_multi_get_free_tx_buffer+0x9c>)
  404330:	5cd3      	ldrb	r3, [r2, r3]
  404332:	b2db      	uxtb	r3, r3
  404334:	f083 0301 	eor.w	r3, r3, #1
  404338:	b2db      	uxtb	r3, r3
  40433a:	2b00      	cmp	r3, #0
  40433c:	d018      	beq.n	404370 <udi_cdc_multi_get_free_tx_buffer+0x78>
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
  40433e:	79fb      	ldrb	r3, [r7, #7]
  404340:	4a15      	ldr	r2, [pc, #84]	; (404398 <udi_cdc_multi_get_free_tx_buffer+0xa0>)
  404342:	5cd3      	ldrb	r3, [r2, r3]
  404344:	b2db      	uxtb	r3, r3
  404346:	f083 0301 	eor.w	r3, r3, #1
  40434a:	b2db      	uxtb	r3, r3
  40434c:	2b00      	cmp	r3, #0
  40434e:	d00f      	beq.n	404370 <udi_cdc_multi_get_free_tx_buffer+0x78>
			/* One buffer is full, but the other buffer is not used.
			 * (not used = transfer on-going)
			 * then move to the other buffer to store data */
			udi_cdc_tx_both_buf_to_send[port] = true;
  404350:	79fb      	ldrb	r3, [r7, #7]
  404352:	4a11      	ldr	r2, [pc, #68]	; (404398 <udi_cdc_multi_get_free_tx_buffer+0xa0>)
  404354:	2101      	movs	r1, #1
  404356:	54d1      	strb	r1, [r2, r3]
			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
  404358:	79fb      	ldrb	r3, [r7, #7]
  40435a:	7bfa      	ldrb	r2, [r7, #15]
  40435c:	2a00      	cmp	r2, #0
  40435e:	bf0c      	ite	eq
  404360:	2201      	moveq	r2, #1
  404362:	2200      	movne	r2, #0
  404364:	b2d2      	uxtb	r2, r2
  404366:	4611      	mov	r1, r2
  404368:	4a08      	ldr	r2, [pc, #32]	; (40438c <udi_cdc_multi_get_free_tx_buffer+0x94>)
  40436a:	54d1      	strb	r1, [r2, r3]
			buf_sel_nb = 0;
  40436c:	2300      	movs	r3, #0
  40436e:	617b      	str	r3, [r7, #20]
		}
	}
	retval = UDI_CDC_TX_BUFFERS - buf_sel_nb;  
  404370:	697b      	ldr	r3, [r7, #20]
  404372:	f5c3 5382 	rsb	r3, r3, #4160	; 0x1040
  404376:	60bb      	str	r3, [r7, #8]
	cpu_irq_restore(flags);
  404378:	6938      	ldr	r0, [r7, #16]
  40437a:	4b08      	ldr	r3, [pc, #32]	; (40439c <udi_cdc_multi_get_free_tx_buffer+0xa4>)
  40437c:	4798      	blx	r3
	return retval;
  40437e:	68bb      	ldr	r3, [r7, #8]
}
  404380:	4618      	mov	r0, r3
  404382:	3718      	adds	r7, #24
  404384:	46bd      	mov	sp, r7
  404386:	bd80      	pop	{r7, pc}
  404388:	004037a5 	.word	0x004037a5
  40438c:	20008794 	.word	0x20008794
  404390:	20008790 	.word	0x20008790
  404394:	2000879c 	.word	0x2000879c
  404398:	200087a0 	.word	0x200087a0
  40439c:	004037fd 	.word	0x004037fd

004043a0 <udi_cdc_multi_is_tx_ready>:
{
	return udi_cdc_multi_get_free_tx_buffer(0);
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
  4043a0:	b580      	push	{r7, lr}
  4043a2:	b082      	sub	sp, #8
  4043a4:	af00      	add	r7, sp, #0
  4043a6:	4603      	mov	r3, r0
  4043a8:	71fb      	strb	r3, [r7, #7]
	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
  4043aa:	79fb      	ldrb	r3, [r7, #7]
  4043ac:	4618      	mov	r0, r3
  4043ae:	4b06      	ldr	r3, [pc, #24]	; (4043c8 <udi_cdc_multi_is_tx_ready+0x28>)
  4043b0:	4798      	blx	r3
  4043b2:	4603      	mov	r3, r0
  4043b4:	2b00      	cmp	r3, #0
  4043b6:	bf14      	ite	ne
  4043b8:	2301      	movne	r3, #1
  4043ba:	2300      	moveq	r3, #0
  4043bc:	b2db      	uxtb	r3, r3
}
  4043be:	4618      	mov	r0, r3
  4043c0:	3708      	adds	r7, #8
  4043c2:	46bd      	mov	sp, r7
  4043c4:	bd80      	pop	{r7, pc}
  4043c6:	bf00      	nop
  4043c8:	004042f9 	.word	0x004042f9

004043cc <udi_cdc_multi_write_buf>:
{
	return udi_cdc_multi_putc(0, value);
}

iram_size_t udi_cdc_multi_write_buf(uint8_t port, const void* buf, iram_size_t size)
{
  4043cc:	b580      	push	{r7, lr}
  4043ce:	b088      	sub	sp, #32
  4043d0:	af00      	add	r7, sp, #0
  4043d2:	4603      	mov	r3, r0
  4043d4:	60b9      	str	r1, [r7, #8]
  4043d6:	607a      	str	r2, [r7, #4]
  4043d8:	73fb      	strb	r3, [r7, #15]
	irqflags_t flags;
	uint8_t buf_sel;
	uint16_t buf_nb;
	iram_size_t copy_nb;
	uint8_t *ptr_buf = (uint8_t *)buf;
  4043da:	68bb      	ldr	r3, [r7, #8]
  4043dc:	61bb      	str	r3, [r7, #24]

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
  4043de:	2300      	movs	r3, #0
  4043e0:	73fb      	strb	r3, [r7, #15]
#endif

	if (9 == udi_cdc_line_coding[port].bDataBits) {
  4043e2:	7bfa      	ldrb	r2, [r7, #15]
  4043e4:	4937      	ldr	r1, [pc, #220]	; (4044c4 <udi_cdc_multi_write_buf+0xf8>)
  4043e6:	4613      	mov	r3, r2
  4043e8:	00db      	lsls	r3, r3, #3
  4043ea:	1a9b      	subs	r3, r3, r2
  4043ec:	440b      	add	r3, r1
  4043ee:	3306      	adds	r3, #6
  4043f0:	781b      	ldrb	r3, [r3, #0]
  4043f2:	2b09      	cmp	r3, #9
  4043f4:	d102      	bne.n	4043fc <udi_cdc_multi_write_buf+0x30>
		size *=2;
  4043f6:	687b      	ldr	r3, [r7, #4]
  4043f8:	005b      	lsls	r3, r3, #1
  4043fa:	607b      	str	r3, [r7, #4]
	}

udi_cdc_write_buf_loop_wait:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
  4043fc:	7bfb      	ldrb	r3, [r7, #15]
  4043fe:	4618      	mov	r0, r3
  404400:	4b31      	ldr	r3, [pc, #196]	; (4044c8 <udi_cdc_multi_write_buf+0xfc>)
  404402:	4798      	blx	r3
  404404:	4603      	mov	r3, r0
  404406:	f083 0301 	eor.w	r3, r3, #1
  40440a:	b2db      	uxtb	r3, r3
  40440c:	2b00      	cmp	r3, #0
  40440e:	d009      	beq.n	404424 <udi_cdc_multi_write_buf+0x58>
		if (!udi_cdc_data_running) {
  404410:	4b2e      	ldr	r3, [pc, #184]	; (4044cc <udi_cdc_multi_write_buf+0x100>)
  404412:	781b      	ldrb	r3, [r3, #0]
  404414:	b2db      	uxtb	r3, r3
  404416:	f083 0301 	eor.w	r3, r3, #1
  40441a:	b2db      	uxtb	r3, r3
  40441c:	2b00      	cmp	r3, #0
  40441e:	d0ed      	beq.n	4043fc <udi_cdc_multi_write_buf+0x30>
			return size;
  404420:	687b      	ldr	r3, [r7, #4]
  404422:	e04a      	b.n	4044ba <udi_cdc_multi_write_buf+0xee>
		}
		goto udi_cdc_write_buf_loop_wait;
	}

	// Write values
	flags = cpu_irq_save();
  404424:	4b2a      	ldr	r3, [pc, #168]	; (4044d0 <udi_cdc_multi_write_buf+0x104>)
  404426:	4798      	blx	r3
  404428:	6178      	str	r0, [r7, #20]
	buf_sel = udi_cdc_tx_buf_sel[port];
  40442a:	7bfb      	ldrb	r3, [r7, #15]
  40442c:	4a29      	ldr	r2, [pc, #164]	; (4044d4 <udi_cdc_multi_write_buf+0x108>)
  40442e:	5cd3      	ldrb	r3, [r2, r3]
  404430:	74fb      	strb	r3, [r7, #19]
	buf_nb = udi_cdc_tx_buf_nb[port][buf_sel];
  404432:	7bfa      	ldrb	r2, [r7, #15]
  404434:	7cfb      	ldrb	r3, [r7, #19]
  404436:	4928      	ldr	r1, [pc, #160]	; (4044d8 <udi_cdc_multi_write_buf+0x10c>)
  404438:	0052      	lsls	r2, r2, #1
  40443a:	4413      	add	r3, r2
  40443c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  404440:	823b      	strh	r3, [r7, #16]
	copy_nb = UDI_CDC_TX_BUFFERS - buf_nb;
  404442:	8a3b      	ldrh	r3, [r7, #16]
  404444:	f5c3 5382 	rsb	r3, r3, #4160	; 0x1040
  404448:	61fb      	str	r3, [r7, #28]
	if (copy_nb > size) {
  40444a:	69fa      	ldr	r2, [r7, #28]
  40444c:	687b      	ldr	r3, [r7, #4]
  40444e:	429a      	cmp	r2, r3
  404450:	d901      	bls.n	404456 <udi_cdc_multi_write_buf+0x8a>
		copy_nb = size;
  404452:	687b      	ldr	r3, [r7, #4]
  404454:	61fb      	str	r3, [r7, #28]
	}
	memcpy(&udi_cdc_tx_buf[port][buf_sel][buf_nb], ptr_buf, copy_nb);
  404456:	7bf9      	ldrb	r1, [r7, #15]
  404458:	7cfb      	ldrb	r3, [r7, #19]
  40445a:	8a38      	ldrh	r0, [r7, #16]
  40445c:	461a      	mov	r2, r3
  40445e:	0192      	lsls	r2, r2, #6
  404460:	441a      	add	r2, r3
  404462:	0193      	lsls	r3, r2, #6
  404464:	461a      	mov	r2, r3
  404466:	460b      	mov	r3, r1
  404468:	019b      	lsls	r3, r3, #6
  40446a:	440b      	add	r3, r1
  40446c:	01db      	lsls	r3, r3, #7
  40446e:	4413      	add	r3, r2
  404470:	4403      	add	r3, r0
  404472:	4a1a      	ldr	r2, [pc, #104]	; (4044dc <udi_cdc_multi_write_buf+0x110>)
  404474:	4413      	add	r3, r2
  404476:	69fa      	ldr	r2, [r7, #28]
  404478:	69b9      	ldr	r1, [r7, #24]
  40447a:	4618      	mov	r0, r3
  40447c:	4b18      	ldr	r3, [pc, #96]	; (4044e0 <udi_cdc_multi_write_buf+0x114>)
  40447e:	4798      	blx	r3
	udi_cdc_tx_buf_nb[port][buf_sel] = buf_nb + copy_nb;
  404480:	7bfa      	ldrb	r2, [r7, #15]
  404482:	7cfb      	ldrb	r3, [r7, #19]
  404484:	69f9      	ldr	r1, [r7, #28]
  404486:	b288      	uxth	r0, r1
  404488:	8a39      	ldrh	r1, [r7, #16]
  40448a:	4401      	add	r1, r0
  40448c:	b288      	uxth	r0, r1
  40448e:	4912      	ldr	r1, [pc, #72]	; (4044d8 <udi_cdc_multi_write_buf+0x10c>)
  404490:	0052      	lsls	r2, r2, #1
  404492:	4413      	add	r3, r2
  404494:	4602      	mov	r2, r0
  404496:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	cpu_irq_restore(flags);
  40449a:	6978      	ldr	r0, [r7, #20]
  40449c:	4b11      	ldr	r3, [pc, #68]	; (4044e4 <udi_cdc_multi_write_buf+0x118>)
  40449e:	4798      	blx	r3

	// Update buffer pointer
	ptr_buf = ptr_buf + copy_nb;
  4044a0:	69ba      	ldr	r2, [r7, #24]
  4044a2:	69fb      	ldr	r3, [r7, #28]
  4044a4:	4413      	add	r3, r2
  4044a6:	61bb      	str	r3, [r7, #24]
	size -= copy_nb;
  4044a8:	687a      	ldr	r2, [r7, #4]
  4044aa:	69fb      	ldr	r3, [r7, #28]
  4044ac:	1ad3      	subs	r3, r2, r3
  4044ae:	607b      	str	r3, [r7, #4]

	if (size) {
  4044b0:	687b      	ldr	r3, [r7, #4]
  4044b2:	2b00      	cmp	r3, #0
  4044b4:	d000      	beq.n	4044b8 <udi_cdc_multi_write_buf+0xec>
		goto udi_cdc_write_buf_loop_wait;
  4044b6:	e7a1      	b.n	4043fc <udi_cdc_multi_write_buf+0x30>
	}

	return 0;
  4044b8:	2300      	movs	r3, #0
}
  4044ba:	4618      	mov	r0, r3
  4044bc:	3720      	adds	r7, #32
  4044be:	46bd      	mov	sp, r7
  4044c0:	bd80      	pop	{r7, pc}
  4044c2:	bf00      	nop
  4044c4:	20004664 	.word	0x20004664
  4044c8:	004043a1 	.word	0x004043a1
  4044cc:	2000467c 	.word	0x2000467c
  4044d0:	004037a5 	.word	0x004037a5
  4044d4:	20008794 	.word	0x20008794
  4044d8:	20008790 	.word	0x20008790
  4044dc:	20006710 	.word	0x20006710
  4044e0:	0040a635 	.word	0x0040a635
  4044e4:	004037fd 	.word	0x004037fd

004044e8 <udi_cdc_write_buf>:

iram_size_t udi_cdc_write_buf(const void* buf, iram_size_t size)
{
  4044e8:	b580      	push	{r7, lr}
  4044ea:	b082      	sub	sp, #8
  4044ec:	af00      	add	r7, sp, #0
  4044ee:	6078      	str	r0, [r7, #4]
  4044f0:	6039      	str	r1, [r7, #0]
	return udi_cdc_multi_write_buf(0, buf, size);
  4044f2:	683a      	ldr	r2, [r7, #0]
  4044f4:	6879      	ldr	r1, [r7, #4]
  4044f6:	2000      	movs	r0, #0
  4044f8:	4b03      	ldr	r3, [pc, #12]	; (404508 <udi_cdc_write_buf+0x20>)
  4044fa:	4798      	blx	r3
  4044fc:	4603      	mov	r3, r0
}
  4044fe:	4618      	mov	r0, r3
  404500:	3708      	adds	r7, #8
  404502:	46bd      	mov	sp, r7
  404504:	bd80      	pop	{r7, pc}
  404506:	bf00      	nop
  404508:	004043cd 	.word	0x004043cd

0040450c <udi_cdc_flush_rx_buffer>:

void udi_cdc_flush_rx_buffer() 
{
  40450c:	b580      	push	{r7, lr}
  40450e:	af00      	add	r7, sp, #0
  udi_cdc_rx_buf_nb[0][0] = 0;
  404510:	4b0b      	ldr	r3, [pc, #44]	; (404540 <udi_cdc_flush_rx_buffer+0x34>)
  404512:	2200      	movs	r2, #0
  404514:	801a      	strh	r2, [r3, #0]
  udi_cdc_rx_buf_nb[0][1] = 0;
  404516:	4b0a      	ldr	r3, [pc, #40]	; (404540 <udi_cdc_flush_rx_buffer+0x34>)
  404518:	2200      	movs	r2, #0
  40451a:	805a      	strh	r2, [r3, #2]
  udi_cdc_rx_pos[0] = 0;
  40451c:	4b09      	ldr	r3, [pc, #36]	; (404544 <udi_cdc_flush_rx_buffer+0x38>)
  40451e:	2200      	movs	r2, #0
  404520:	801a      	strh	r2, [r3, #0]
  memset(udi_cdc_rx_buf[0][0],0x00, UDI_CDC_RX_BUFFERS);
  404522:	f44f 5282 	mov.w	r2, #4160	; 0x1040
  404526:	2100      	movs	r1, #0
  404528:	4807      	ldr	r0, [pc, #28]	; (404548 <udi_cdc_flush_rx_buffer+0x3c>)
  40452a:	4b08      	ldr	r3, [pc, #32]	; (40454c <udi_cdc_flush_rx_buffer+0x40>)
  40452c:	4798      	blx	r3
  memset(udi_cdc_rx_buf[0][1],0x00, UDI_CDC_RX_BUFFERS);
  40452e:	f44f 5282 	mov.w	r2, #4160	; 0x1040
  404532:	2100      	movs	r1, #0
  404534:	4806      	ldr	r0, [pc, #24]	; (404550 <udi_cdc_flush_rx_buffer+0x44>)
  404536:	4b05      	ldr	r3, [pc, #20]	; (40454c <udi_cdc_flush_rx_buffer+0x40>)
  404538:	4798      	blx	r3
}
  40453a:	bf00      	nop
  40453c:	bd80      	pop	{r7, pc}
  40453e:	bf00      	nop
  404540:	20006700 	.word	0x20006700
  404544:	20006708 	.word	0x20006708
  404548:	20004680 	.word	0x20004680
  40454c:	0040a769 	.word	0x0040a769
  404550:	200056c0 	.word	0x200056c0

00404554 <udi_cdc_get_available_rx_bytes>:
 
int udi_cdc_get_available_rx_bytes()
{
  404554:	b480      	push	{r7}
  404556:	af00      	add	r7, sp, #0
  return udi_cdc_rx_buf_nb[0][udi_cdc_rx_buf_sel[0]];
  404558:	4b06      	ldr	r3, [pc, #24]	; (404574 <udi_cdc_get_available_rx_bytes+0x20>)
  40455a:	781b      	ldrb	r3, [r3, #0]
  40455c:	b2db      	uxtb	r3, r3
  40455e:	461a      	mov	r2, r3
  404560:	4b05      	ldr	r3, [pc, #20]	; (404578 <udi_cdc_get_available_rx_bytes+0x24>)
  404562:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  404566:	b29b      	uxth	r3, r3
}
  404568:	4618      	mov	r0, r3
  40456a:	46bd      	mov	sp, r7
  40456c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404570:	4770      	bx	lr
  404572:	bf00      	nop
  404574:	20006704 	.word	0x20006704
  404578:	20006700 	.word	0x20006700

0040457c <udc_get_eof_conf>:
 * \brief Returns a value to check the end of USB Configuration descriptor
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
  40457c:	b480      	push	{r7}
  40457e:	af00      	add	r7, sp, #0
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
  404580:	4b06      	ldr	r3, [pc, #24]	; (40459c <udc_get_eof_conf+0x20>)
  404582:	681b      	ldr	r3, [r3, #0]
  404584:	681b      	ldr	r3, [r3, #0]
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
  404586:	4a05      	ldr	r2, [pc, #20]	; (40459c <udc_get_eof_conf+0x20>)
  404588:	6812      	ldr	r2, [r2, #0]
  40458a:	6812      	ldr	r2, [r2, #0]
  40458c:	8852      	ldrh	r2, [r2, #2]
  40458e:	b292      	uxth	r2, r2
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
  404590:	4413      	add	r3, r2
}
  404592:	4618      	mov	r0, r3
  404594:	46bd      	mov	sp, r7
  404596:	f85d 7b04 	ldr.w	r7, [sp], #4
  40459a:	4770      	bx	lr
  40459c:	200087b0 	.word	0x200087b0

004045a0 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
  4045a0:	b580      	push	{r7, lr}
  4045a2:	b084      	sub	sp, #16
  4045a4:	af00      	add	r7, sp, #0
  4045a6:	6078      	str	r0, [r7, #4]
  4045a8:	460b      	mov	r3, r1
  4045aa:	70fb      	strb	r3, [r7, #3]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
  4045ac:	4b12      	ldr	r3, [pc, #72]	; (4045f8 <udc_next_desc_in_iface+0x58>)
  4045ae:	4798      	blx	r3
  4045b0:	60f8      	str	r0, [r7, #12]
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
  4045b2:	687b      	ldr	r3, [r7, #4]
  4045b4:	781b      	ldrb	r3, [r3, #0]
  4045b6:	461a      	mov	r2, r3
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
  4045b8:	687b      	ldr	r3, [r7, #4]
  4045ba:	4413      	add	r3, r2
  4045bc:	607b      	str	r3, [r7, #4]
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
  4045be:	e010      	b.n	4045e2 <udc_next_desc_in_iface+0x42>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
  4045c0:	687b      	ldr	r3, [r7, #4]
  4045c2:	785b      	ldrb	r3, [r3, #1]
  4045c4:	2b04      	cmp	r3, #4
  4045c6:	d011      	beq.n	4045ec <udc_next_desc_in_iface+0x4c>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
  4045c8:	687b      	ldr	r3, [r7, #4]
  4045ca:	785b      	ldrb	r3, [r3, #1]
  4045cc:	78fa      	ldrb	r2, [r7, #3]
  4045ce:	429a      	cmp	r2, r3
  4045d0:	d101      	bne.n	4045d6 <udc_next_desc_in_iface+0x36>
			return desc; // Specific descriptor found
  4045d2:	687b      	ldr	r3, [r7, #4]
  4045d4:	e00c      	b.n	4045f0 <udc_next_desc_in_iface+0x50>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
  4045d6:	687b      	ldr	r3, [r7, #4]
  4045d8:	781b      	ldrb	r3, [r3, #0]
  4045da:	461a      	mov	r2, r3
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
  4045dc:	687b      	ldr	r3, [r7, #4]
  4045de:	4413      	add	r3, r2
  4045e0:	607b      	str	r3, [r7, #4]
	while (ptr_eof_desc > desc) {
  4045e2:	68fa      	ldr	r2, [r7, #12]
  4045e4:	687b      	ldr	r3, [r7, #4]
  4045e6:	429a      	cmp	r2, r3
  4045e8:	d8ea      	bhi.n	4045c0 <udc_next_desc_in_iface+0x20>
  4045ea:	e000      	b.n	4045ee <udc_next_desc_in_iface+0x4e>
			break; // End of global interface descriptor
  4045ec:	bf00      	nop
	}
	return NULL; // No specific descriptor found
  4045ee:	2300      	movs	r3, #0
}
  4045f0:	4618      	mov	r0, r3
  4045f2:	3710      	adds	r7, #16
  4045f4:	46bd      	mov	sp, r7
  4045f6:	bd80      	pop	{r7, pc}
  4045f8:	0040457d 	.word	0x0040457d

004045fc <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
  4045fc:	b580      	push	{r7, lr}
  4045fe:	b084      	sub	sp, #16
  404600:	af00      	add	r7, sp, #0
  404602:	4603      	mov	r3, r0
  404604:	460a      	mov	r2, r1
  404606:	71fb      	strb	r3, [r7, #7]
  404608:	4613      	mov	r3, r2
  40460a:	71bb      	strb	r3, [r7, #6]
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
  40460c:	4b1e      	ldr	r3, [pc, #120]	; (404688 <udc_update_iface_desc+0x8c>)
  40460e:	781b      	ldrb	r3, [r3, #0]
  404610:	2b00      	cmp	r3, #0
  404612:	d101      	bne.n	404618 <udc_update_iface_desc+0x1c>
		return false;
  404614:	2300      	movs	r3, #0
  404616:	e032      	b.n	40467e <udc_update_iface_desc+0x82>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  404618:	4b1c      	ldr	r3, [pc, #112]	; (40468c <udc_update_iface_desc+0x90>)
  40461a:	681b      	ldr	r3, [r3, #0]
  40461c:	681b      	ldr	r3, [r3, #0]
  40461e:	791b      	ldrb	r3, [r3, #4]
  404620:	79fa      	ldrb	r2, [r7, #7]
  404622:	429a      	cmp	r2, r3
  404624:	d301      	bcc.n	40462a <udc_update_iface_desc+0x2e>
		return false;
  404626:	2300      	movs	r3, #0
  404628:	e029      	b.n	40467e <udc_update_iface_desc+0x82>
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;
  40462a:	4b18      	ldr	r3, [pc, #96]	; (40468c <udc_update_iface_desc+0x90>)
  40462c:	681b      	ldr	r3, [r3, #0]
  40462e:	681b      	ldr	r3, [r3, #0]
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
  404630:	4a17      	ldr	r2, [pc, #92]	; (404690 <udc_update_iface_desc+0x94>)
  404632:	6013      	str	r3, [r2, #0]

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
  404634:	4b17      	ldr	r3, [pc, #92]	; (404694 <udc_update_iface_desc+0x98>)
  404636:	4798      	blx	r3
  404638:	60f8      	str	r0, [r7, #12]
	while (ptr_end_desc >
  40463a:	e01a      	b.n	404672 <udc_update_iface_desc+0x76>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
  40463c:	4b14      	ldr	r3, [pc, #80]	; (404690 <udc_update_iface_desc+0x94>)
  40463e:	681b      	ldr	r3, [r3, #0]
  404640:	785b      	ldrb	r3, [r3, #1]
  404642:	2b04      	cmp	r3, #4
  404644:	d10d      	bne.n	404662 <udc_update_iface_desc+0x66>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
  404646:	4b12      	ldr	r3, [pc, #72]	; (404690 <udc_update_iface_desc+0x94>)
  404648:	681b      	ldr	r3, [r3, #0]
  40464a:	789b      	ldrb	r3, [r3, #2]
  40464c:	79fa      	ldrb	r2, [r7, #7]
  40464e:	429a      	cmp	r2, r3
  404650:	d107      	bne.n	404662 <udc_update_iface_desc+0x66>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
  404652:	4b0f      	ldr	r3, [pc, #60]	; (404690 <udc_update_iface_desc+0x94>)
  404654:	681b      	ldr	r3, [r3, #0]
  404656:	78db      	ldrb	r3, [r3, #3]
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
  404658:	79ba      	ldrb	r2, [r7, #6]
  40465a:	429a      	cmp	r2, r3
  40465c:	d101      	bne.n	404662 <udc_update_iface_desc+0x66>
				return true; // Interface found
  40465e:	2301      	movs	r3, #1
  404660:	e00d      	b.n	40467e <udc_update_iface_desc+0x82>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
  404662:	4b0b      	ldr	r3, [pc, #44]	; (404690 <udc_update_iface_desc+0x94>)
  404664:	681b      	ldr	r3, [r3, #0]
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
  404666:	4a0a      	ldr	r2, [pc, #40]	; (404690 <udc_update_iface_desc+0x94>)
  404668:	6812      	ldr	r2, [r2, #0]
  40466a:	7812      	ldrb	r2, [r2, #0]
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
  40466c:	4413      	add	r3, r2
  40466e:	4a08      	ldr	r2, [pc, #32]	; (404690 <udc_update_iface_desc+0x94>)
  404670:	6013      	str	r3, [r2, #0]
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
  404672:	4b07      	ldr	r3, [pc, #28]	; (404690 <udc_update_iface_desc+0x94>)
  404674:	681b      	ldr	r3, [r3, #0]
	while (ptr_end_desc >
  404676:	68fa      	ldr	r2, [r7, #12]
  404678:	429a      	cmp	r2, r3
  40467a:	d8df      	bhi.n	40463c <udc_update_iface_desc+0x40>
	}
	return false; // Interface not found
  40467c:	2300      	movs	r3, #0
}
  40467e:	4618      	mov	r0, r3
  404680:	3710      	adds	r7, #16
  404682:	46bd      	mov	sp, r7
  404684:	bd80      	pop	{r7, pc}
  404686:	bf00      	nop
  404688:	200087ac 	.word	0x200087ac
  40468c:	200087b0 	.word	0x200087b0
  404690:	200087b4 	.word	0x200087b4
  404694:	0040457d 	.word	0x0040457d

00404698 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
  404698:	b580      	push	{r7, lr}
  40469a:	b084      	sub	sp, #16
  40469c:	af00      	add	r7, sp, #0
  40469e:	4603      	mov	r3, r0
  4046a0:	71fb      	strb	r3, [r7, #7]
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  4046a2:	79fb      	ldrb	r3, [r7, #7]
  4046a4:	2100      	movs	r1, #0
  4046a6:	4618      	mov	r0, r3
  4046a8:	4b1e      	ldr	r3, [pc, #120]	; (404724 <udc_iface_disable+0x8c>)
  4046aa:	4798      	blx	r3
  4046ac:	4603      	mov	r3, r0
  4046ae:	f083 0301 	eor.w	r3, r3, #1
  4046b2:	b2db      	uxtb	r3, r3
  4046b4:	2b00      	cmp	r3, #0
  4046b6:	d001      	beq.n	4046bc <udc_iface_disable+0x24>
		return false;
  4046b8:	2300      	movs	r3, #0
  4046ba:	e02f      	b.n	40471c <udc_iface_disable+0x84>
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  4046bc:	4b1a      	ldr	r3, [pc, #104]	; (404728 <udc_iface_disable+0x90>)
  4046be:	681b      	ldr	r3, [r3, #0]
  4046c0:	685a      	ldr	r2, [r3, #4]
  4046c2:	79fb      	ldrb	r3, [r7, #7]
  4046c4:	009b      	lsls	r3, r3, #2
  4046c6:	4413      	add	r3, r2
  4046c8:	681b      	ldr	r3, [r3, #0]
  4046ca:	60bb      	str	r3, [r7, #8]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  4046cc:	68bb      	ldr	r3, [r7, #8]
  4046ce:	68db      	ldr	r3, [r3, #12]
  4046d0:	4798      	blx	r3
  4046d2:	4603      	mov	r3, r0
  4046d4:	461a      	mov	r2, r3
  4046d6:	79fb      	ldrb	r3, [r7, #7]
  4046d8:	4611      	mov	r1, r2
  4046da:	4618      	mov	r0, r3
  4046dc:	4b11      	ldr	r3, [pc, #68]	; (404724 <udc_iface_disable+0x8c>)
  4046de:	4798      	blx	r3
  4046e0:	4603      	mov	r3, r0
  4046e2:	f083 0301 	eor.w	r3, r3, #1
  4046e6:	b2db      	uxtb	r3, r3
  4046e8:	2b00      	cmp	r3, #0
  4046ea:	d001      	beq.n	4046f0 <udc_iface_disable+0x58>
		return false;
  4046ec:	2300      	movs	r3, #0
  4046ee:	e015      	b.n	40471c <udc_iface_disable+0x84>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
  4046f0:	4b0e      	ldr	r3, [pc, #56]	; (40472c <udc_iface_disable+0x94>)
  4046f2:	681b      	ldr	r3, [r3, #0]
  4046f4:	60fb      	str	r3, [r7, #12]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  4046f6:	2105      	movs	r1, #5
  4046f8:	68f8      	ldr	r0, [r7, #12]
  4046fa:	4b0d      	ldr	r3, [pc, #52]	; (404730 <udc_iface_disable+0x98>)
  4046fc:	4798      	blx	r3
  4046fe:	60f8      	str	r0, [r7, #12]
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
  404700:	68fb      	ldr	r3, [r7, #12]
  404702:	2b00      	cmp	r3, #0
  404704:	d005      	beq.n	404712 <udc_iface_disable+0x7a>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
  404706:	68fb      	ldr	r3, [r7, #12]
  404708:	789b      	ldrb	r3, [r3, #2]
  40470a:	4618      	mov	r0, r3
  40470c:	4b09      	ldr	r3, [pc, #36]	; (404734 <udc_iface_disable+0x9c>)
  40470e:	4798      	blx	r3
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  404710:	e7f1      	b.n	4046f6 <udc_iface_disable+0x5e>
				break;
  404712:	bf00      	nop
		}
	}
#endif

	// Disable interface
	udi_api->disable();
  404714:	68bb      	ldr	r3, [r7, #8]
  404716:	685b      	ldr	r3, [r3, #4]
  404718:	4798      	blx	r3
	return true;
  40471a:	2301      	movs	r3, #1
}
  40471c:	4618      	mov	r0, r3
  40471e:	3710      	adds	r7, #16
  404720:	46bd      	mov	sp, r7
  404722:	bd80      	pop	{r7, pc}
  404724:	004045fd 	.word	0x004045fd
  404728:	200087b0 	.word	0x200087b0
  40472c:	200087b4 	.word	0x200087b4
  404730:	004045a1 	.word	0x004045a1
  404734:	00405a6d 	.word	0x00405a6d

00404738 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
  404738:	b580      	push	{r7, lr}
  40473a:	b084      	sub	sp, #16
  40473c:	af00      	add	r7, sp, #0
  40473e:	4603      	mov	r3, r0
  404740:	460a      	mov	r2, r1
  404742:	71fb      	strb	r3, [r7, #7]
  404744:	4613      	mov	r3, r2
  404746:	71bb      	strb	r3, [r7, #6]
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
  404748:	79ba      	ldrb	r2, [r7, #6]
  40474a:	79fb      	ldrb	r3, [r7, #7]
  40474c:	4611      	mov	r1, r2
  40474e:	4618      	mov	r0, r3
  404750:	4b1a      	ldr	r3, [pc, #104]	; (4047bc <udc_iface_enable+0x84>)
  404752:	4798      	blx	r3
  404754:	4603      	mov	r3, r0
  404756:	f083 0301 	eor.w	r3, r3, #1
  40475a:	b2db      	uxtb	r3, r3
  40475c:	2b00      	cmp	r3, #0
  40475e:	d001      	beq.n	404764 <udc_iface_enable+0x2c>
		return false;
  404760:	2300      	movs	r3, #0
  404762:	e027      	b.n	4047b4 <udc_iface_enable+0x7c>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
  404764:	4b16      	ldr	r3, [pc, #88]	; (4047c0 <udc_iface_enable+0x88>)
  404766:	681b      	ldr	r3, [r3, #0]
  404768:	60fb      	str	r3, [r7, #12]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
  40476a:	2105      	movs	r1, #5
  40476c:	68f8      	ldr	r0, [r7, #12]
  40476e:	4b15      	ldr	r3, [pc, #84]	; (4047c4 <udc_iface_enable+0x8c>)
  404770:	4798      	blx	r3
  404772:	60f8      	str	r0, [r7, #12]
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
  404774:	68fb      	ldr	r3, [r7, #12]
  404776:	2b00      	cmp	r3, #0
  404778:	d011      	beq.n	40479e <udc_iface_enable+0x66>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
  40477a:	68fb      	ldr	r3, [r7, #12]
  40477c:	7898      	ldrb	r0, [r3, #2]
  40477e:	68fb      	ldr	r3, [r7, #12]
  404780:	78d9      	ldrb	r1, [r3, #3]
  404782:	68fb      	ldr	r3, [r7, #12]
  404784:	889b      	ldrh	r3, [r3, #4]
  404786:	b29b      	uxth	r3, r3
  404788:	461a      	mov	r2, r3
  40478a:	4b0f      	ldr	r3, [pc, #60]	; (4047c8 <udc_iface_enable+0x90>)
  40478c:	4798      	blx	r3
  40478e:	4603      	mov	r3, r0
  404790:	f083 0301 	eor.w	r3, r3, #1
  404794:	b2db      	uxtb	r3, r3
  404796:	2b00      	cmp	r3, #0
  404798:	d0e7      	beq.n	40476a <udc_iface_enable+0x32>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
  40479a:	2300      	movs	r3, #0
  40479c:	e00a      	b.n	4047b4 <udc_iface_enable+0x7c>
			break;
  40479e:	bf00      	nop
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
  4047a0:	4b0a      	ldr	r3, [pc, #40]	; (4047cc <udc_iface_enable+0x94>)
  4047a2:	681b      	ldr	r3, [r3, #0]
  4047a4:	685a      	ldr	r2, [r3, #4]
  4047a6:	79fb      	ldrb	r3, [r7, #7]
  4047a8:	009b      	lsls	r3, r3, #2
  4047aa:	4413      	add	r3, r2
  4047ac:	681b      	ldr	r3, [r3, #0]
  4047ae:	681b      	ldr	r3, [r3, #0]
  4047b0:	4798      	blx	r3
  4047b2:	4603      	mov	r3, r0
}
  4047b4:	4618      	mov	r0, r3
  4047b6:	3710      	adds	r7, #16
  4047b8:	46bd      	mov	sp, r7
  4047ba:	bd80      	pop	{r7, pc}
  4047bc:	004045fd 	.word	0x004045fd
  4047c0:	200087b4 	.word	0x200087b4
  4047c4:	004045a1 	.word	0x004045a1
  4047c8:	00405899 	.word	0x00405899
  4047cc:	200087b0 	.word	0x200087b0

004047d0 <udc_start>:

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
  4047d0:	b580      	push	{r7, lr}
  4047d2:	af00      	add	r7, sp, #0
	udd_enable();
  4047d4:	4b01      	ldr	r3, [pc, #4]	; (4047dc <udc_start+0xc>)
  4047d6:	4798      	blx	r3
}
  4047d8:	bf00      	nop
  4047da:	bd80      	pop	{r7, pc}
  4047dc:	004056a5 	.word	0x004056a5

004047e0 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
  4047e0:	b580      	push	{r7, lr}
  4047e2:	b082      	sub	sp, #8
  4047e4:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
  4047e6:	4b0f      	ldr	r3, [pc, #60]	; (404824 <udc_reset+0x44>)
  4047e8:	781b      	ldrb	r3, [r3, #0]
  4047ea:	2b00      	cmp	r3, #0
  4047ec:	d010      	beq.n	404810 <udc_reset+0x30>
		for (iface_num = 0;
  4047ee:	2300      	movs	r3, #0
  4047f0:	71fb      	strb	r3, [r7, #7]
  4047f2:	e006      	b.n	404802 <udc_reset+0x22>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
  4047f4:	79fb      	ldrb	r3, [r7, #7]
  4047f6:	4618      	mov	r0, r3
  4047f8:	4b0b      	ldr	r3, [pc, #44]	; (404828 <udc_reset+0x48>)
  4047fa:	4798      	blx	r3
				iface_num++) {
  4047fc:	79fb      	ldrb	r3, [r7, #7]
  4047fe:	3301      	adds	r3, #1
  404800:	71fb      	strb	r3, [r7, #7]
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
  404802:	4b0a      	ldr	r3, [pc, #40]	; (40482c <udc_reset+0x4c>)
  404804:	681b      	ldr	r3, [r3, #0]
  404806:	681b      	ldr	r3, [r3, #0]
  404808:	791b      	ldrb	r3, [r3, #4]
		for (iface_num = 0;
  40480a:	79fa      	ldrb	r2, [r7, #7]
  40480c:	429a      	cmp	r2, r3
  40480e:	d3f1      	bcc.n	4047f4 <udc_reset+0x14>
		}
	}
	udc_num_configuration = 0;
  404810:	4b04      	ldr	r3, [pc, #16]	; (404824 <udc_reset+0x44>)
  404812:	2200      	movs	r2, #0
  404814:	701a      	strb	r2, [r3, #0]
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
  404816:	4b06      	ldr	r3, [pc, #24]	; (404830 <udc_reset+0x50>)
  404818:	2201      	movs	r2, #1
  40481a:	801a      	strh	r2, [r3, #0]
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
  40481c:	bf00      	nop
  40481e:	3708      	adds	r7, #8
  404820:	46bd      	mov	sp, r7
  404822:	bd80      	pop	{r7, pc}
  404824:	200087ac 	.word	0x200087ac
  404828:	00404699 	.word	0x00404699
  40482c:	200087b0 	.word	0x200087b0
  404830:	200087a4 	.word	0x200087a4

00404834 <udc_sof_notify>:

void udc_sof_notify(void)
{
  404834:	b580      	push	{r7, lr}
  404836:	b082      	sub	sp, #8
  404838:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	if (udc_num_configuration) {
  40483a:	4b14      	ldr	r3, [pc, #80]	; (40488c <udc_sof_notify+0x58>)
  40483c:	781b      	ldrb	r3, [r3, #0]
  40483e:	2b00      	cmp	r3, #0
  404840:	d01f      	beq.n	404882 <udc_sof_notify+0x4e>
		for (iface_num = 0;
  404842:	2300      	movs	r3, #0
  404844:	71fb      	strb	r3, [r7, #7]
  404846:	e015      	b.n	404874 <udc_sof_notify+0x40>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
  404848:	4b11      	ldr	r3, [pc, #68]	; (404890 <udc_sof_notify+0x5c>)
  40484a:	681b      	ldr	r3, [r3, #0]
  40484c:	685a      	ldr	r2, [r3, #4]
  40484e:	79fb      	ldrb	r3, [r7, #7]
  404850:	009b      	lsls	r3, r3, #2
  404852:	4413      	add	r3, r2
  404854:	681b      	ldr	r3, [r3, #0]
  404856:	691b      	ldr	r3, [r3, #16]
  404858:	2b00      	cmp	r3, #0
  40485a:	d008      	beq.n	40486e <udc_sof_notify+0x3a>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
  40485c:	4b0c      	ldr	r3, [pc, #48]	; (404890 <udc_sof_notify+0x5c>)
  40485e:	681b      	ldr	r3, [r3, #0]
  404860:	685a      	ldr	r2, [r3, #4]
  404862:	79fb      	ldrb	r3, [r7, #7]
  404864:	009b      	lsls	r3, r3, #2
  404866:	4413      	add	r3, r2
  404868:	681b      	ldr	r3, [r3, #0]
  40486a:	691b      	ldr	r3, [r3, #16]
  40486c:	4798      	blx	r3
				iface_num++) {
  40486e:	79fb      	ldrb	r3, [r7, #7]
  404870:	3301      	adds	r3, #1
  404872:	71fb      	strb	r3, [r7, #7]
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
  404874:	4b06      	ldr	r3, [pc, #24]	; (404890 <udc_sof_notify+0x5c>)
  404876:	681b      	ldr	r3, [r3, #0]
  404878:	681b      	ldr	r3, [r3, #0]
  40487a:	791b      	ldrb	r3, [r3, #4]
		for (iface_num = 0;
  40487c:	79fa      	ldrb	r2, [r7, #7]
  40487e:	429a      	cmp	r2, r3
  404880:	d3e2      	bcc.n	404848 <udc_sof_notify+0x14>
			}
		}
	}
}
  404882:	bf00      	nop
  404884:	3708      	adds	r7, #8
  404886:	46bd      	mov	sp, r7
  404888:	bd80      	pop	{r7, pc}
  40488a:	bf00      	nop
  40488c:	200087ac 	.word	0x200087ac
  404890:	200087b0 	.word	0x200087b0

00404894 <udc_req_std_dev_get_status>:
 * \brief Standard device request to get device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
  404894:	b580      	push	{r7, lr}
  404896:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
  404898:	4b06      	ldr	r3, [pc, #24]	; (4048b4 <udc_req_std_dev_get_status+0x20>)
  40489a:	88db      	ldrh	r3, [r3, #6]
  40489c:	2b02      	cmp	r3, #2
  40489e:	d001      	beq.n	4048a4 <udc_req_std_dev_get_status+0x10>
		return false;
  4048a0:	2300      	movs	r3, #0
  4048a2:	e004      	b.n	4048ae <udc_req_std_dev_get_status+0x1a>
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
  4048a4:	2102      	movs	r1, #2
  4048a6:	4804      	ldr	r0, [pc, #16]	; (4048b8 <udc_req_std_dev_get_status+0x24>)
  4048a8:	4b04      	ldr	r3, [pc, #16]	; (4048bc <udc_req_std_dev_get_status+0x28>)
  4048aa:	4798      	blx	r3
			sizeof(udc_device_status));
	return true;
  4048ac:	2301      	movs	r3, #1
}
  4048ae:	4618      	mov	r0, r3
  4048b0:	bd80      	pop	{r7, pc}
  4048b2:	bf00      	nop
  4048b4:	2000896c 	.word	0x2000896c
  4048b8:	200087a4 	.word	0x200087a4
  4048bc:	00405871 	.word	0x00405871

004048c0 <udc_req_std_ep_get_status>:
 * \brief Standard endpoint request to get endpoint status
 *
 * \return true if success
 */
static bool udc_req_std_ep_get_status(void)
{
  4048c0:	b580      	push	{r7, lr}
  4048c2:	af00      	add	r7, sp, #0
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
  4048c4:	4b0b      	ldr	r3, [pc, #44]	; (4048f4 <udc_req_std_ep_get_status+0x34>)
  4048c6:	88db      	ldrh	r3, [r3, #6]
  4048c8:	2b02      	cmp	r3, #2
  4048ca:	d001      	beq.n	4048d0 <udc_req_std_ep_get_status+0x10>
		return false;
  4048cc:	2300      	movs	r3, #0
  4048ce:	e00e      	b.n	4048ee <udc_req_std_ep_get_status+0x2e>
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
  4048d0:	4b08      	ldr	r3, [pc, #32]	; (4048f4 <udc_req_std_ep_get_status+0x34>)
  4048d2:	889b      	ldrh	r3, [r3, #4]
  4048d4:	b2db      	uxtb	r3, r3
  4048d6:	4618      	mov	r0, r3
  4048d8:	4b07      	ldr	r3, [pc, #28]	; (4048f8 <udc_req_std_ep_get_status+0x38>)
  4048da:	4798      	blx	r3
  4048dc:	4603      	mov	r3, r0
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;
  4048de:	b29a      	uxth	r2, r3
	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
  4048e0:	4b06      	ldr	r3, [pc, #24]	; (4048fc <udc_req_std_ep_get_status+0x3c>)
  4048e2:	801a      	strh	r2, [r3, #0]

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
  4048e4:	2102      	movs	r1, #2
  4048e6:	4805      	ldr	r0, [pc, #20]	; (4048fc <udc_req_std_ep_get_status+0x3c>)
  4048e8:	4b05      	ldr	r3, [pc, #20]	; (404900 <udc_req_std_ep_get_status+0x40>)
  4048ea:	4798      	blx	r3
			sizeof(udc_ep_status));
	return true;
  4048ec:	2301      	movs	r3, #1
}
  4048ee:	4618      	mov	r0, r3
  4048f0:	bd80      	pop	{r7, pc}
  4048f2:	bf00      	nop
  4048f4:	2000896c 	.word	0x2000896c
  4048f8:	00405add 	.word	0x00405add
  4048fc:	200087b8 	.word	0x200087b8
  404900:	00405871 	.word	0x00405871

00404904 <udc_req_std_dev_clear_feature>:
 * \brief Standard device request to change device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
  404904:	b480      	push	{r7}
  404906:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  404908:	4b0c      	ldr	r3, [pc, #48]	; (40493c <udc_req_std_dev_clear_feature+0x38>)
  40490a:	88db      	ldrh	r3, [r3, #6]
  40490c:	2b00      	cmp	r3, #0
  40490e:	d001      	beq.n	404914 <udc_req_std_dev_clear_feature+0x10>
		return false;
  404910:	2300      	movs	r3, #0
  404912:	e00d      	b.n	404930 <udc_req_std_dev_clear_feature+0x2c>
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
  404914:	4b09      	ldr	r3, [pc, #36]	; (40493c <udc_req_std_dev_clear_feature+0x38>)
  404916:	885b      	ldrh	r3, [r3, #2]
  404918:	2b01      	cmp	r3, #1
  40491a:	d108      	bne.n	40492e <udc_req_std_dev_clear_feature+0x2a>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
  40491c:	4b08      	ldr	r3, [pc, #32]	; (404940 <udc_req_std_dev_clear_feature+0x3c>)
  40491e:	881b      	ldrh	r3, [r3, #0]
  404920:	f023 0302 	bic.w	r3, r3, #2
  404924:	b29a      	uxth	r2, r3
  404926:	4b06      	ldr	r3, [pc, #24]	; (404940 <udc_req_std_dev_clear_feature+0x3c>)
  404928:	801a      	strh	r2, [r3, #0]
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
  40492a:	2301      	movs	r3, #1
  40492c:	e000      	b.n	404930 <udc_req_std_dev_clear_feature+0x2c>
	}
	return false;
  40492e:	2300      	movs	r3, #0
}
  404930:	4618      	mov	r0, r3
  404932:	46bd      	mov	sp, r7
  404934:	f85d 7b04 	ldr.w	r7, [sp], #4
  404938:	4770      	bx	lr
  40493a:	bf00      	nop
  40493c:	2000896c 	.word	0x2000896c
  404940:	200087a4 	.word	0x200087a4

00404944 <udc_req_std_ep_clear_feature>:
 * \brief Standard endpoint request to clear endpoint feature
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
  404944:	b580      	push	{r7, lr}
  404946:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  404948:	4b0a      	ldr	r3, [pc, #40]	; (404974 <udc_req_std_ep_clear_feature+0x30>)
  40494a:	88db      	ldrh	r3, [r3, #6]
  40494c:	2b00      	cmp	r3, #0
  40494e:	d001      	beq.n	404954 <udc_req_std_ep_clear_feature+0x10>
		return false;
  404950:	2300      	movs	r3, #0
  404952:	e00c      	b.n	40496e <udc_req_std_ep_clear_feature+0x2a>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
  404954:	4b07      	ldr	r3, [pc, #28]	; (404974 <udc_req_std_ep_clear_feature+0x30>)
  404956:	885b      	ldrh	r3, [r3, #2]
  404958:	2b00      	cmp	r3, #0
  40495a:	d107      	bne.n	40496c <udc_req_std_ep_clear_feature+0x28>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
  40495c:	4b05      	ldr	r3, [pc, #20]	; (404974 <udc_req_std_ep_clear_feature+0x30>)
  40495e:	889b      	ldrh	r3, [r3, #4]
  404960:	b2db      	uxtb	r3, r3
  404962:	4618      	mov	r0, r3
  404964:	4b04      	ldr	r3, [pc, #16]	; (404978 <udc_req_std_ep_clear_feature+0x34>)
  404966:	4798      	blx	r3
  404968:	4603      	mov	r3, r0
  40496a:	e000      	b.n	40496e <udc_req_std_ep_clear_feature+0x2a>
	}
	return false;
  40496c:	2300      	movs	r3, #0
}
  40496e:	4618      	mov	r0, r3
  404970:	bd80      	pop	{r7, pc}
  404972:	bf00      	nop
  404974:	2000896c 	.word	0x2000896c
  404978:	00405c45 	.word	0x00405c45

0040497c <udc_req_std_dev_set_feature>:
 * \brief Standard device request to set a feature
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
  40497c:	b480      	push	{r7}
  40497e:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  404980:	4b09      	ldr	r3, [pc, #36]	; (4049a8 <udc_req_std_dev_set_feature+0x2c>)
  404982:	88db      	ldrh	r3, [r3, #6]
  404984:	2b00      	cmp	r3, #0
  404986:	d001      	beq.n	40498c <udc_req_std_dev_set_feature+0x10>
		return false;
  404988:	2300      	movs	r3, #0
  40498a:	e007      	b.n	40499c <udc_req_std_dev_set_feature+0x20>
	}

	switch (udd_g_ctrlreq.req.wValue) {
  40498c:	4b06      	ldr	r3, [pc, #24]	; (4049a8 <udc_req_std_dev_set_feature+0x2c>)
  40498e:	885b      	ldrh	r3, [r3, #2]
  404990:	2b01      	cmp	r3, #1
  404992:	d002      	beq.n	40499a <udc_req_std_dev_set_feature+0x1e>
			break;
		}
		break;
#endif
	default:
		break;
  404994:	bf00      	nop
	}
	return false;
  404996:	2300      	movs	r3, #0
  404998:	e000      	b.n	40499c <udc_req_std_dev_set_feature+0x20>
		return false;
  40499a:	2300      	movs	r3, #0
}
  40499c:	4618      	mov	r0, r3
  40499e:	46bd      	mov	sp, r7
  4049a0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4049a4:	4770      	bx	lr
  4049a6:	bf00      	nop
  4049a8:	2000896c 	.word	0x2000896c

004049ac <udc_req_std_ep_set_feature>:
 *
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
  4049ac:	b580      	push	{r7, lr}
  4049ae:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  4049b0:	4b0d      	ldr	r3, [pc, #52]	; (4049e8 <udc_req_std_ep_set_feature+0x3c>)
  4049b2:	88db      	ldrh	r3, [r3, #6]
  4049b4:	2b00      	cmp	r3, #0
  4049b6:	d001      	beq.n	4049bc <udc_req_std_ep_set_feature+0x10>
		return false;
  4049b8:	2300      	movs	r3, #0
  4049ba:	e012      	b.n	4049e2 <udc_req_std_ep_set_feature+0x36>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
  4049bc:	4b0a      	ldr	r3, [pc, #40]	; (4049e8 <udc_req_std_ep_set_feature+0x3c>)
  4049be:	885b      	ldrh	r3, [r3, #2]
  4049c0:	2b00      	cmp	r3, #0
  4049c2:	d10d      	bne.n	4049e0 <udc_req_std_ep_set_feature+0x34>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
  4049c4:	4b08      	ldr	r3, [pc, #32]	; (4049e8 <udc_req_std_ep_set_feature+0x3c>)
  4049c6:	889b      	ldrh	r3, [r3, #4]
  4049c8:	b2db      	uxtb	r3, r3
  4049ca:	4618      	mov	r0, r3
  4049cc:	4b07      	ldr	r3, [pc, #28]	; (4049ec <udc_req_std_ep_set_feature+0x40>)
  4049ce:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
  4049d0:	4b05      	ldr	r3, [pc, #20]	; (4049e8 <udc_req_std_ep_set_feature+0x3c>)
  4049d2:	889b      	ldrh	r3, [r3, #4]
  4049d4:	b2db      	uxtb	r3, r3
  4049d6:	4618      	mov	r0, r3
  4049d8:	4b05      	ldr	r3, [pc, #20]	; (4049f0 <udc_req_std_ep_set_feature+0x44>)
  4049da:	4798      	blx	r3
  4049dc:	4603      	mov	r3, r0
  4049de:	e000      	b.n	4049e2 <udc_req_std_ep_set_feature+0x36>
	}
	return false;
  4049e0:	2300      	movs	r3, #0
}
  4049e2:	4618      	mov	r0, r3
  4049e4:	bd80      	pop	{r7, pc}
  4049e6:	bf00      	nop
  4049e8:	2000896c 	.word	0x2000896c
  4049ec:	00405eb5 	.word	0x00405eb5
  4049f0:	00405b51 	.word	0x00405b51

004049f4 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
  4049f4:	b580      	push	{r7, lr}
  4049f6:	af00      	add	r7, sp, #0
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
  4049f8:	4b05      	ldr	r3, [pc, #20]	; (404a10 <udc_valid_address+0x1c>)
  4049fa:	885b      	ldrh	r3, [r3, #2]
  4049fc:	b2db      	uxtb	r3, r3
  4049fe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  404a02:	b2db      	uxtb	r3, r3
  404a04:	4618      	mov	r0, r3
  404a06:	4b03      	ldr	r3, [pc, #12]	; (404a14 <udc_valid_address+0x20>)
  404a08:	4798      	blx	r3
}
  404a0a:	bf00      	nop
  404a0c:	bd80      	pop	{r7, pc}
  404a0e:	bf00      	nop
  404a10:	2000896c 	.word	0x2000896c
  404a14:	004057ad 	.word	0x004057ad

00404a18 <udc_req_std_dev_set_address>:
 * \brief Standard device request to set device address
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
  404a18:	b480      	push	{r7}
  404a1a:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength) {
  404a1c:	4b07      	ldr	r3, [pc, #28]	; (404a3c <udc_req_std_dev_set_address+0x24>)
  404a1e:	88db      	ldrh	r3, [r3, #6]
  404a20:	2b00      	cmp	r3, #0
  404a22:	d001      	beq.n	404a28 <udc_req_std_dev_set_address+0x10>
		return false;
  404a24:	2300      	movs	r3, #0
  404a26:	e003      	b.n	404a30 <udc_req_std_dev_set_address+0x18>
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
  404a28:	4b04      	ldr	r3, [pc, #16]	; (404a3c <udc_req_std_dev_set_address+0x24>)
  404a2a:	4a05      	ldr	r2, [pc, #20]	; (404a40 <udc_req_std_dev_set_address+0x28>)
  404a2c:	611a      	str	r2, [r3, #16]
	return true;
  404a2e:	2301      	movs	r3, #1
}
  404a30:	4618      	mov	r0, r3
  404a32:	46bd      	mov	sp, r7
  404a34:	f85d 7b04 	ldr.w	r7, [sp], #4
  404a38:	4770      	bx	lr
  404a3a:	bf00      	nop
  404a3c:	2000896c 	.word	0x2000896c
  404a40:	004049f5 	.word	0x004049f5

00404a44 <udc_req_std_dev_get_str_desc>:
 * \brief Standard device request to get device string descriptor
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_str_desc(void)
{
  404a44:	b580      	push	{r7, lr}
  404a46:	b082      	sub	sp, #8
  404a48:	af00      	add	r7, sp, #0
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;
  404a4a:	2300      	movs	r3, #0
  404a4c:	71bb      	strb	r3, [r7, #6]

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
  404a4e:	4b1c      	ldr	r3, [pc, #112]	; (404ac0 <udc_req_std_dev_get_str_desc+0x7c>)
  404a50:	885b      	ldrh	r3, [r3, #2]
  404a52:	b2db      	uxtb	r3, r3
  404a54:	2b00      	cmp	r3, #0
  404a56:	d108      	bne.n	404a6a <udc_req_std_dev_get_str_desc+0x26>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
  404a58:	2104      	movs	r1, #4
  404a5a:	481a      	ldr	r0, [pc, #104]	; (404ac4 <udc_req_std_dev_get_str_desc+0x80>)
  404a5c:	4b1a      	ldr	r3, [pc, #104]	; (404ac8 <udc_req_std_dev_get_str_desc+0x84>)
  404a5e:	4798      	blx	r3
				sizeof(udc_string_desc_languageid));
		break;
  404a60:	bf00      	nop
		}
#endif
		return false;
	}

	if (str_length) {
  404a62:	79bb      	ldrb	r3, [r7, #6]
  404a64:	2b00      	cmp	r3, #0
  404a66:	d025      	beq.n	404ab4 <udc_req_std_dev_get_str_desc+0x70>
  404a68:	e001      	b.n	404a6e <udc_req_std_dev_get_str_desc+0x2a>
		return false;
  404a6a:	2300      	movs	r3, #0
  404a6c:	e023      	b.n	404ab6 <udc_req_std_dev_get_str_desc+0x72>
		for(i = 0; i < str_length; i++) {
  404a6e:	2300      	movs	r3, #0
  404a70:	71fb      	strb	r3, [r7, #7]
  404a72:	e00d      	b.n	404a90 <udc_req_std_dev_get_str_desc+0x4c>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
  404a74:	79fb      	ldrb	r3, [r7, #7]
  404a76:	79fa      	ldrb	r2, [r7, #7]
  404a78:	6839      	ldr	r1, [r7, #0]
  404a7a:	440a      	add	r2, r1
  404a7c:	7812      	ldrb	r2, [r2, #0]
  404a7e:	b291      	uxth	r1, r2
  404a80:	4a12      	ldr	r2, [pc, #72]	; (404acc <udc_req_std_dev_get_str_desc+0x88>)
  404a82:	005b      	lsls	r3, r3, #1
  404a84:	4413      	add	r3, r2
  404a86:	460a      	mov	r2, r1
  404a88:	805a      	strh	r2, [r3, #2]
		for(i = 0; i < str_length; i++) {
  404a8a:	79fb      	ldrb	r3, [r7, #7]
  404a8c:	3301      	adds	r3, #1
  404a8e:	71fb      	strb	r3, [r7, #7]
  404a90:	79fa      	ldrb	r2, [r7, #7]
  404a92:	79bb      	ldrb	r3, [r7, #6]
  404a94:	429a      	cmp	r2, r3
  404a96:	d3ed      	bcc.n	404a74 <udc_req_std_dev_get_str_desc+0x30>
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
  404a98:	79bb      	ldrb	r3, [r7, #6]
  404a9a:	3301      	adds	r3, #1
  404a9c:	b2db      	uxtb	r3, r3
  404a9e:	005b      	lsls	r3, r3, #1
  404aa0:	b2da      	uxtb	r2, r3
  404aa2:	4b0a      	ldr	r3, [pc, #40]	; (404acc <udc_req_std_dev_get_str_desc+0x88>)
  404aa4:	701a      	strb	r2, [r3, #0]
		udd_set_setup_payload(
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
  404aa6:	4b09      	ldr	r3, [pc, #36]	; (404acc <udc_req_std_dev_get_str_desc+0x88>)
  404aa8:	781b      	ldrb	r3, [r3, #0]
		udd_set_setup_payload(
  404aaa:	b29b      	uxth	r3, r3
  404aac:	4619      	mov	r1, r3
  404aae:	4807      	ldr	r0, [pc, #28]	; (404acc <udc_req_std_dev_get_str_desc+0x88>)
  404ab0:	4b05      	ldr	r3, [pc, #20]	; (404ac8 <udc_req_std_dev_get_str_desc+0x84>)
  404ab2:	4798      	blx	r3
	}

	return true;
  404ab4:	2301      	movs	r3, #1
}
  404ab6:	4618      	mov	r0, r3
  404ab8:	3708      	adds	r7, #8
  404aba:	46bd      	mov	sp, r7
  404abc:	bd80      	pop	{r7, pc}
  404abe:	bf00      	nop
  404ac0:	2000896c 	.word	0x2000896c
  404ac4:	200001a4 	.word	0x200001a4
  404ac8:	00405871 	.word	0x00405871
  404acc:	200001a8 	.word	0x200001a8

00404ad0 <udc_req_std_dev_get_descriptor>:
 * \brief Standard device request to get descriptors about USB device
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_descriptor(void)
{
  404ad0:	b580      	push	{r7, lr}
  404ad2:	b082      	sub	sp, #8
  404ad4:	af00      	add	r7, sp, #0
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
  404ad6:	4b41      	ldr	r3, [pc, #260]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404ad8:	885b      	ldrh	r3, [r3, #2]
  404ada:	71fb      	strb	r3, [r7, #7]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
  404adc:	4b3f      	ldr	r3, [pc, #252]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404ade:	885b      	ldrh	r3, [r3, #2]
  404ae0:	0a1b      	lsrs	r3, r3, #8
  404ae2:	b29b      	uxth	r3, r3
  404ae4:	b2db      	uxtb	r3, r3
  404ae6:	3b01      	subs	r3, #1
  404ae8:	2b0e      	cmp	r3, #14
  404aea:	d865      	bhi.n	404bb8 <udc_req_std_dev_get_descriptor+0xe8>
  404aec:	a201      	add	r2, pc, #4	; (adr r2, 404af4 <udc_req_std_dev_get_descriptor+0x24>)
  404aee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  404af2:	bf00      	nop
  404af4:	00404b31 	.word	0x00404b31
  404af8:	00404b47 	.word	0x00404b47
  404afc:	00404ba5 	.word	0x00404ba5
  404b00:	00404bb9 	.word	0x00404bb9
  404b04:	00404bb9 	.word	0x00404bb9
  404b08:	00404bb9 	.word	0x00404bb9
  404b0c:	00404bb9 	.word	0x00404bb9
  404b10:	00404bb9 	.word	0x00404bb9
  404b14:	00404bb9 	.word	0x00404bb9
  404b18:	00404bb9 	.word	0x00404bb9
  404b1c:	00404bb9 	.word	0x00404bb9
  404b20:	00404bb9 	.word	0x00404bb9
  404b24:	00404bb9 	.word	0x00404bb9
  404b28:	00404bb9 	.word	0x00404bb9
  404b2c:	00404b83 	.word	0x00404b83
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
  404b30:	4b2b      	ldr	r3, [pc, #172]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b32:	681a      	ldr	r2, [r3, #0]
				udc_config.confdev_lsfs->bLength);
  404b34:	4b2a      	ldr	r3, [pc, #168]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b36:	681b      	ldr	r3, [r3, #0]
  404b38:	781b      	ldrb	r3, [r3, #0]
			udd_set_setup_payload(
  404b3a:	b29b      	uxth	r3, r3
  404b3c:	4619      	mov	r1, r3
  404b3e:	4610      	mov	r0, r2
  404b40:	4b28      	ldr	r3, [pc, #160]	; (404be4 <udc_req_std_dev_get_descriptor+0x114>)
  404b42:	4798      	blx	r3
		}
		break;
  404b44:	e03b      	b.n	404bbe <udc_req_std_dev_get_descriptor+0xee>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
  404b46:	4b26      	ldr	r3, [pc, #152]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b48:	681b      	ldr	r3, [r3, #0]
  404b4a:	7c5b      	ldrb	r3, [r3, #17]
  404b4c:	79fa      	ldrb	r2, [r7, #7]
  404b4e:	429a      	cmp	r2, r3
  404b50:	d301      	bcc.n	404b56 <udc_req_std_dev_get_descriptor+0x86>
					bNumConfigurations) {
				return false;
  404b52:	2300      	movs	r3, #0
  404b54:	e03e      	b.n	404bd4 <udc_req_std_dev_get_descriptor+0x104>
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
  404b56:	4b22      	ldr	r3, [pc, #136]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b58:	685a      	ldr	r2, [r3, #4]
  404b5a:	79fb      	ldrb	r3, [r7, #7]
  404b5c:	00db      	lsls	r3, r3, #3
  404b5e:	4413      	add	r3, r2
  404b60:	6818      	ldr	r0, [r3, #0]
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
  404b62:	4b1f      	ldr	r3, [pc, #124]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b64:	685a      	ldr	r2, [r3, #4]
  404b66:	79fb      	ldrb	r3, [r7, #7]
  404b68:	00db      	lsls	r3, r3, #3
  404b6a:	4413      	add	r3, r2
  404b6c:	681b      	ldr	r3, [r3, #0]
			udd_set_setup_payload(
  404b6e:	885b      	ldrh	r3, [r3, #2]
  404b70:	b29b      	uxth	r3, r3
  404b72:	4619      	mov	r1, r3
  404b74:	4b1b      	ldr	r3, [pc, #108]	; (404be4 <udc_req_std_dev_get_descriptor+0x114>)
  404b76:	4798      	blx	r3
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
  404b78:	4b18      	ldr	r3, [pc, #96]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404b7a:	689b      	ldr	r3, [r3, #8]
  404b7c:	2202      	movs	r2, #2
  404b7e:	705a      	strb	r2, [r3, #1]
				USB_DT_CONFIGURATION;
		break;
  404b80:	e01d      	b.n	404bbe <udc_req_std_dev_get_descriptor+0xee>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
  404b82:	4b17      	ldr	r3, [pc, #92]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b84:	689b      	ldr	r3, [r3, #8]
  404b86:	2b00      	cmp	r3, #0
  404b88:	d101      	bne.n	404b8e <udc_req_std_dev_get_descriptor+0xbe>
			return false;
  404b8a:	2300      	movs	r3, #0
  404b8c:	e022      	b.n	404bd4 <udc_req_std_dev_get_descriptor+0x104>
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
  404b8e:	4b14      	ldr	r3, [pc, #80]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b90:	689a      	ldr	r2, [r3, #8]
				udc_config.conf_bos->wTotalLength);
  404b92:	4b13      	ldr	r3, [pc, #76]	; (404be0 <udc_req_std_dev_get_descriptor+0x110>)
  404b94:	689b      	ldr	r3, [r3, #8]
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
  404b96:	885b      	ldrh	r3, [r3, #2]
  404b98:	b29b      	uxth	r3, r3
  404b9a:	4619      	mov	r1, r3
  404b9c:	4610      	mov	r0, r2
  404b9e:	4b11      	ldr	r3, [pc, #68]	; (404be4 <udc_req_std_dev_get_descriptor+0x114>)
  404ba0:	4798      	blx	r3
		break;
  404ba2:	e00c      	b.n	404bbe <udc_req_std_dev_get_descriptor+0xee>

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
  404ba4:	4b10      	ldr	r3, [pc, #64]	; (404be8 <udc_req_std_dev_get_descriptor+0x118>)
  404ba6:	4798      	blx	r3
  404ba8:	4603      	mov	r3, r0
  404baa:	f083 0301 	eor.w	r3, r3, #1
  404bae:	b2db      	uxtb	r3, r3
  404bb0:	2b00      	cmp	r3, #0
  404bb2:	d003      	beq.n	404bbc <udc_req_std_dev_get_descriptor+0xec>
			return false;
  404bb4:	2300      	movs	r3, #0
  404bb6:	e00d      	b.n	404bd4 <udc_req_std_dev_get_descriptor+0x104>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
  404bb8:	2300      	movs	r3, #0
  404bba:	e00b      	b.n	404bd4 <udc_req_std_dev_get_descriptor+0x104>
		break;
  404bbc:	bf00      	nop
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
  404bbe:	4b07      	ldr	r3, [pc, #28]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404bc0:	88da      	ldrh	r2, [r3, #6]
  404bc2:	4b06      	ldr	r3, [pc, #24]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404bc4:	899b      	ldrh	r3, [r3, #12]
  404bc6:	429a      	cmp	r2, r3
  404bc8:	d203      	bcs.n	404bd2 <udc_req_std_dev_get_descriptor+0x102>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
  404bca:	4b04      	ldr	r3, [pc, #16]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404bcc:	88da      	ldrh	r2, [r3, #6]
  404bce:	4b03      	ldr	r3, [pc, #12]	; (404bdc <udc_req_std_dev_get_descriptor+0x10c>)
  404bd0:	819a      	strh	r2, [r3, #12]
	}
	return true;
  404bd2:	2301      	movs	r3, #1
}
  404bd4:	4618      	mov	r0, r3
  404bd6:	3708      	adds	r7, #8
  404bd8:	46bd      	mov	sp, r7
  404bda:	bd80      	pop	{r7, pc}
  404bdc:	2000896c 	.word	0x2000896c
  404be0:	20000164 	.word	0x20000164
  404be4:	00405871 	.word	0x00405871
  404be8:	00404a45 	.word	0x00404a45

00404bec <udc_req_std_dev_get_configuration>:
 * \brief Standard device request to get configuration number
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
  404bec:	b580      	push	{r7, lr}
  404bee:	af00      	add	r7, sp, #0
	if (udd_g_ctrlreq.req.wLength != 1) {
  404bf0:	4b06      	ldr	r3, [pc, #24]	; (404c0c <udc_req_std_dev_get_configuration+0x20>)
  404bf2:	88db      	ldrh	r3, [r3, #6]
  404bf4:	2b01      	cmp	r3, #1
  404bf6:	d001      	beq.n	404bfc <udc_req_std_dev_get_configuration+0x10>
		return false;
  404bf8:	2300      	movs	r3, #0
  404bfa:	e004      	b.n	404c06 <udc_req_std_dev_get_configuration+0x1a>
	}

	udd_set_setup_payload(&udc_num_configuration,1);
  404bfc:	2101      	movs	r1, #1
  404bfe:	4804      	ldr	r0, [pc, #16]	; (404c10 <udc_req_std_dev_get_configuration+0x24>)
  404c00:	4b04      	ldr	r3, [pc, #16]	; (404c14 <udc_req_std_dev_get_configuration+0x28>)
  404c02:	4798      	blx	r3
	return true;
  404c04:	2301      	movs	r3, #1
}
  404c06:	4618      	mov	r0, r3
  404c08:	bd80      	pop	{r7, pc}
  404c0a:	bf00      	nop
  404c0c:	2000896c 	.word	0x2000896c
  404c10:	200087ac 	.word	0x200087ac
  404c14:	00405871 	.word	0x00405871

00404c18 <udc_req_std_dev_set_configuration>:
 * \brief Standard device request to enable a configuration
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_configuration(void)
{
  404c18:	b580      	push	{r7, lr}
  404c1a:	b082      	sub	sp, #8
  404c1c:	af00      	add	r7, sp, #0
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
  404c1e:	4b27      	ldr	r3, [pc, #156]	; (404cbc <udc_req_std_dev_set_configuration+0xa4>)
  404c20:	88db      	ldrh	r3, [r3, #6]
  404c22:	2b00      	cmp	r3, #0
  404c24:	d001      	beq.n	404c2a <udc_req_std_dev_set_configuration+0x12>
		return false;
  404c26:	2300      	movs	r3, #0
  404c28:	e043      	b.n	404cb2 <udc_req_std_dev_set_configuration+0x9a>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
  404c2a:	4b25      	ldr	r3, [pc, #148]	; (404cc0 <udc_req_std_dev_set_configuration+0xa8>)
  404c2c:	4798      	blx	r3
  404c2e:	4603      	mov	r3, r0
  404c30:	2b00      	cmp	r3, #0
  404c32:	d101      	bne.n	404c38 <udc_req_std_dev_set_configuration+0x20>
		return false;
  404c34:	2300      	movs	r3, #0
  404c36:	e03c      	b.n	404cb2 <udc_req_std_dev_set_configuration+0x9a>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
  404c38:	4b20      	ldr	r3, [pc, #128]	; (404cbc <udc_req_std_dev_set_configuration+0xa4>)
  404c3a:	885b      	ldrh	r3, [r3, #2]
  404c3c:	b2db      	uxtb	r3, r3
				udc_config.confdev_lsfs->bNumConfigurations) {
  404c3e:	4a21      	ldr	r2, [pc, #132]	; (404cc4 <udc_req_std_dev_set_configuration+0xac>)
  404c40:	6812      	ldr	r2, [r2, #0]
  404c42:	7c52      	ldrb	r2, [r2, #17]
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
  404c44:	4293      	cmp	r3, r2
  404c46:	dd01      	ble.n	404c4c <udc_req_std_dev_set_configuration+0x34>
			return false;
  404c48:	2300      	movs	r3, #0
  404c4a:	e032      	b.n	404cb2 <udc_req_std_dev_set_configuration+0x9a>
		}
	}

	// Reset current configuration
	udc_reset();
  404c4c:	4b1e      	ldr	r3, [pc, #120]	; (404cc8 <udc_req_std_dev_set_configuration+0xb0>)
  404c4e:	4798      	blx	r3

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
  404c50:	4b1a      	ldr	r3, [pc, #104]	; (404cbc <udc_req_std_dev_set_configuration+0xa4>)
  404c52:	885b      	ldrh	r3, [r3, #2]
  404c54:	b2da      	uxtb	r2, r3
  404c56:	4b1d      	ldr	r3, [pc, #116]	; (404ccc <udc_req_std_dev_set_configuration+0xb4>)
  404c58:	701a      	strb	r2, [r3, #0]
	if (udc_num_configuration == 0) {
  404c5a:	4b1c      	ldr	r3, [pc, #112]	; (404ccc <udc_req_std_dev_set_configuration+0xb4>)
  404c5c:	781b      	ldrb	r3, [r3, #0]
  404c5e:	2b00      	cmp	r3, #0
  404c60:	d101      	bne.n	404c66 <udc_req_std_dev_set_configuration+0x4e>
		return true; // Default empty configuration requested
  404c62:	2301      	movs	r3, #1
  404c64:	e025      	b.n	404cb2 <udc_req_std_dev_set_configuration+0x9a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
  404c66:	4b17      	ldr	r3, [pc, #92]	; (404cc4 <udc_req_std_dev_set_configuration+0xac>)
  404c68:	685a      	ldr	r2, [r3, #4]
  404c6a:	4b18      	ldr	r3, [pc, #96]	; (404ccc <udc_req_std_dev_set_configuration+0xb4>)
  404c6c:	781b      	ldrb	r3, [r3, #0]
  404c6e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  404c72:	3b01      	subs	r3, #1
  404c74:	00db      	lsls	r3, r3, #3
  404c76:	4413      	add	r3, r2
  404c78:	4a15      	ldr	r2, [pc, #84]	; (404cd0 <udc_req_std_dev_set_configuration+0xb8>)
  404c7a:	6013      	str	r3, [r2, #0]
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  404c7c:	2300      	movs	r3, #0
  404c7e:	71fb      	strb	r3, [r7, #7]
  404c80:	e00f      	b.n	404ca2 <udc_req_std_dev_set_configuration+0x8a>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
  404c82:	79fb      	ldrb	r3, [r7, #7]
  404c84:	2100      	movs	r1, #0
  404c86:	4618      	mov	r0, r3
  404c88:	4b12      	ldr	r3, [pc, #72]	; (404cd4 <udc_req_std_dev_set_configuration+0xbc>)
  404c8a:	4798      	blx	r3
  404c8c:	4603      	mov	r3, r0
  404c8e:	f083 0301 	eor.w	r3, r3, #1
  404c92:	b2db      	uxtb	r3, r3
  404c94:	2b00      	cmp	r3, #0
  404c96:	d001      	beq.n	404c9c <udc_req_std_dev_set_configuration+0x84>
			return false;
  404c98:	2300      	movs	r3, #0
  404c9a:	e00a      	b.n	404cb2 <udc_req_std_dev_set_configuration+0x9a>
			iface_num++) {
  404c9c:	79fb      	ldrb	r3, [r7, #7]
  404c9e:	3301      	adds	r3, #1
  404ca0:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  404ca2:	4b0b      	ldr	r3, [pc, #44]	; (404cd0 <udc_req_std_dev_set_configuration+0xb8>)
  404ca4:	681b      	ldr	r3, [r3, #0]
  404ca6:	681b      	ldr	r3, [r3, #0]
  404ca8:	791b      	ldrb	r3, [r3, #4]
  404caa:	79fa      	ldrb	r2, [r7, #7]
  404cac:	429a      	cmp	r2, r3
  404cae:	d3e8      	bcc.n	404c82 <udc_req_std_dev_set_configuration+0x6a>
		}
	}
	return true;
  404cb0:	2301      	movs	r3, #1
}
  404cb2:	4618      	mov	r0, r3
  404cb4:	3708      	adds	r7, #8
  404cb6:	46bd      	mov	sp, r7
  404cb8:	bd80      	pop	{r7, pc}
  404cba:	bf00      	nop
  404cbc:	2000896c 	.word	0x2000896c
  404cc0:	00405811 	.word	0x00405811
  404cc4:	20000164 	.word	0x20000164
  404cc8:	004047e1 	.word	0x004047e1
  404ccc:	200087ac 	.word	0x200087ac
  404cd0:	200087b0 	.word	0x200087b0
  404cd4:	00404739 	.word	0x00404739

00404cd8 <udc_req_std_iface_get_setting>:
 * to get the alternate setting number of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_get_setting(void)
{
  404cd8:	b580      	push	{r7, lr}
  404cda:	b082      	sub	sp, #8
  404cdc:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
  404cde:	4b1e      	ldr	r3, [pc, #120]	; (404d58 <udc_req_std_iface_get_setting+0x80>)
  404ce0:	88db      	ldrh	r3, [r3, #6]
  404ce2:	2b01      	cmp	r3, #1
  404ce4:	d001      	beq.n	404cea <udc_req_std_iface_get_setting+0x12>
		return false; // Error in request
  404ce6:	2300      	movs	r3, #0
  404ce8:	e032      	b.n	404d50 <udc_req_std_iface_get_setting+0x78>
	}
	if (!udc_num_configuration) {
  404cea:	4b1c      	ldr	r3, [pc, #112]	; (404d5c <udc_req_std_iface_get_setting+0x84>)
  404cec:	781b      	ldrb	r3, [r3, #0]
  404cee:	2b00      	cmp	r3, #0
  404cf0:	d101      	bne.n	404cf6 <udc_req_std_iface_get_setting+0x1e>
		return false; // The device is not is configured state yet
  404cf2:	2300      	movs	r3, #0
  404cf4:	e02c      	b.n	404d50 <udc_req_std_iface_get_setting+0x78>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  404cf6:	4b18      	ldr	r3, [pc, #96]	; (404d58 <udc_req_std_iface_get_setting+0x80>)
  404cf8:	889b      	ldrh	r3, [r3, #4]
  404cfa:	71fb      	strb	r3, [r7, #7]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  404cfc:	4b18      	ldr	r3, [pc, #96]	; (404d60 <udc_req_std_iface_get_setting+0x88>)
  404cfe:	681b      	ldr	r3, [r3, #0]
  404d00:	681b      	ldr	r3, [r3, #0]
  404d02:	791b      	ldrb	r3, [r3, #4]
  404d04:	79fa      	ldrb	r2, [r7, #7]
  404d06:	429a      	cmp	r2, r3
  404d08:	d301      	bcc.n	404d0e <udc_req_std_iface_get_setting+0x36>
		return false;
  404d0a:	2300      	movs	r3, #0
  404d0c:	e020      	b.n	404d50 <udc_req_std_iface_get_setting+0x78>
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  404d0e:	79fb      	ldrb	r3, [r7, #7]
  404d10:	2100      	movs	r1, #0
  404d12:	4618      	mov	r0, r3
  404d14:	4b13      	ldr	r3, [pc, #76]	; (404d64 <udc_req_std_iface_get_setting+0x8c>)
  404d16:	4798      	blx	r3
  404d18:	4603      	mov	r3, r0
  404d1a:	f083 0301 	eor.w	r3, r3, #1
  404d1e:	b2db      	uxtb	r3, r3
  404d20:	2b00      	cmp	r3, #0
  404d22:	d001      	beq.n	404d28 <udc_req_std_iface_get_setting+0x50>
		return false;
  404d24:	2300      	movs	r3, #0
  404d26:	e013      	b.n	404d50 <udc_req_std_iface_get_setting+0x78>
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  404d28:	4b0d      	ldr	r3, [pc, #52]	; (404d60 <udc_req_std_iface_get_setting+0x88>)
  404d2a:	681b      	ldr	r3, [r3, #0]
  404d2c:	685a      	ldr	r2, [r3, #4]
  404d2e:	79fb      	ldrb	r3, [r7, #7]
  404d30:	009b      	lsls	r3, r3, #2
  404d32:	4413      	add	r3, r2
  404d34:	681b      	ldr	r3, [r3, #0]
  404d36:	603b      	str	r3, [r7, #0]
	udc_iface_setting = udi_api->getsetting();
  404d38:	683b      	ldr	r3, [r7, #0]
  404d3a:	68db      	ldr	r3, [r3, #12]
  404d3c:	4798      	blx	r3
  404d3e:	4603      	mov	r3, r0
  404d40:	461a      	mov	r2, r3
  404d42:	4b09      	ldr	r3, [pc, #36]	; (404d68 <udc_req_std_iface_get_setting+0x90>)
  404d44:	701a      	strb	r2, [r3, #0]

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
  404d46:	2101      	movs	r1, #1
  404d48:	4807      	ldr	r0, [pc, #28]	; (404d68 <udc_req_std_iface_get_setting+0x90>)
  404d4a:	4b08      	ldr	r3, [pc, #32]	; (404d6c <udc_req_std_iface_get_setting+0x94>)
  404d4c:	4798      	blx	r3
	return true;
  404d4e:	2301      	movs	r3, #1
}
  404d50:	4618      	mov	r0, r3
  404d52:	3708      	adds	r7, #8
  404d54:	46bd      	mov	sp, r7
  404d56:	bd80      	pop	{r7, pc}
  404d58:	2000896c 	.word	0x2000896c
  404d5c:	200087ac 	.word	0x200087ac
  404d60:	200087b0 	.word	0x200087b0
  404d64:	004045fd 	.word	0x004045fd
  404d68:	200087a8 	.word	0x200087a8
  404d6c:	00405871 	.word	0x00405871

00404d70 <udc_req_std_iface_set_setting>:
 * to set an alternate setting of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_set_setting(void)
{
  404d70:	b580      	push	{r7, lr}
  404d72:	b082      	sub	sp, #8
  404d74:	af00      	add	r7, sp, #0
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
  404d76:	4b14      	ldr	r3, [pc, #80]	; (404dc8 <udc_req_std_iface_set_setting+0x58>)
  404d78:	88db      	ldrh	r3, [r3, #6]
  404d7a:	2b00      	cmp	r3, #0
  404d7c:	d001      	beq.n	404d82 <udc_req_std_iface_set_setting+0x12>
		return false; // Error in request
  404d7e:	2300      	movs	r3, #0
  404d80:	e01e      	b.n	404dc0 <udc_req_std_iface_set_setting+0x50>
	}
	if (!udc_num_configuration) {
  404d82:	4b12      	ldr	r3, [pc, #72]	; (404dcc <udc_req_std_iface_set_setting+0x5c>)
  404d84:	781b      	ldrb	r3, [r3, #0]
  404d86:	2b00      	cmp	r3, #0
  404d88:	d101      	bne.n	404d8e <udc_req_std_iface_set_setting+0x1e>
		return false; // The device is not is configured state yet
  404d8a:	2300      	movs	r3, #0
  404d8c:	e018      	b.n	404dc0 <udc_req_std_iface_set_setting+0x50>
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  404d8e:	4b0e      	ldr	r3, [pc, #56]	; (404dc8 <udc_req_std_iface_set_setting+0x58>)
  404d90:	889b      	ldrh	r3, [r3, #4]
  404d92:	71fb      	strb	r3, [r7, #7]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
  404d94:	4b0c      	ldr	r3, [pc, #48]	; (404dc8 <udc_req_std_iface_set_setting+0x58>)
  404d96:	885b      	ldrh	r3, [r3, #2]
  404d98:	71bb      	strb	r3, [r7, #6]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
  404d9a:	79fb      	ldrb	r3, [r7, #7]
  404d9c:	4618      	mov	r0, r3
  404d9e:	4b0c      	ldr	r3, [pc, #48]	; (404dd0 <udc_req_std_iface_set_setting+0x60>)
  404da0:	4798      	blx	r3
  404da2:	4603      	mov	r3, r0
  404da4:	f083 0301 	eor.w	r3, r3, #1
  404da8:	b2db      	uxtb	r3, r3
  404daa:	2b00      	cmp	r3, #0
  404dac:	d001      	beq.n	404db2 <udc_req_std_iface_set_setting+0x42>
		return false;
  404dae:	2300      	movs	r3, #0
  404db0:	e006      	b.n	404dc0 <udc_req_std_iface_set_setting+0x50>
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
  404db2:	79ba      	ldrb	r2, [r7, #6]
  404db4:	79fb      	ldrb	r3, [r7, #7]
  404db6:	4611      	mov	r1, r2
  404db8:	4618      	mov	r0, r3
  404dba:	4b06      	ldr	r3, [pc, #24]	; (404dd4 <udc_req_std_iface_set_setting+0x64>)
  404dbc:	4798      	blx	r3
  404dbe:	4603      	mov	r3, r0
}
  404dc0:	4618      	mov	r0, r3
  404dc2:	3708      	adds	r7, #8
  404dc4:	46bd      	mov	sp, r7
  404dc6:	bd80      	pop	{r7, pc}
  404dc8:	2000896c 	.word	0x2000896c
  404dcc:	200087ac 	.word	0x200087ac
  404dd0:	00404699 	.word	0x00404699
  404dd4:	00404739 	.word	0x00404739

00404dd8 <udc_reqstd>:
 * \brief Main routine to manage the standard USB SETUP request
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
  404dd8:	b580      	push	{r7, lr}
  404dda:	af00      	add	r7, sp, #0
	if (Udd_setup_is_in()) {
  404ddc:	4b4d      	ldr	r3, [pc, #308]	; (404f14 <udc_reqstd+0x13c>)
  404dde:	781b      	ldrb	r3, [r3, #0]
  404de0:	b25b      	sxtb	r3, r3
  404de2:	2b00      	cmp	r3, #0
  404de4:	da3e      	bge.n	404e64 <udc_reqstd+0x8c>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
  404de6:	4b4b      	ldr	r3, [pc, #300]	; (404f14 <udc_reqstd+0x13c>)
  404de8:	88db      	ldrh	r3, [r3, #6]
  404dea:	2b00      	cmp	r3, #0
  404dec:	d101      	bne.n	404df2 <udc_reqstd+0x1a>
			return false; // Error for USB host
  404dee:	2300      	movs	r3, #0
  404df0:	e08e      	b.n	404f10 <udc_reqstd+0x138>
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
  404df2:	4b48      	ldr	r3, [pc, #288]	; (404f14 <udc_reqstd+0x13c>)
  404df4:	781b      	ldrb	r3, [r3, #0]
  404df6:	f003 031f 	and.w	r3, r3, #31
  404dfa:	2b00      	cmp	r3, #0
  404dfc:	d114      	bne.n	404e28 <udc_reqstd+0x50>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
  404dfe:	4b45      	ldr	r3, [pc, #276]	; (404f14 <udc_reqstd+0x13c>)
  404e00:	785b      	ldrb	r3, [r3, #1]
  404e02:	2b06      	cmp	r3, #6
  404e04:	d008      	beq.n	404e18 <udc_reqstd+0x40>
  404e06:	2b08      	cmp	r3, #8
  404e08:	d00a      	beq.n	404e20 <udc_reqstd+0x48>
  404e0a:	2b00      	cmp	r3, #0
  404e0c:	d000      	beq.n	404e10 <udc_reqstd+0x38>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			default:
				break;
  404e0e:	e00b      	b.n	404e28 <udc_reqstd+0x50>
				return udc_req_std_dev_get_status();
  404e10:	4b41      	ldr	r3, [pc, #260]	; (404f18 <udc_reqstd+0x140>)
  404e12:	4798      	blx	r3
  404e14:	4603      	mov	r3, r0
  404e16:	e07b      	b.n	404f10 <udc_reqstd+0x138>
				return udc_req_std_dev_get_descriptor();
  404e18:	4b40      	ldr	r3, [pc, #256]	; (404f1c <udc_reqstd+0x144>)
  404e1a:	4798      	blx	r3
  404e1c:	4603      	mov	r3, r0
  404e1e:	e077      	b.n	404f10 <udc_reqstd+0x138>
				return udc_req_std_dev_get_configuration();
  404e20:	4b3f      	ldr	r3, [pc, #252]	; (404f20 <udc_reqstd+0x148>)
  404e22:	4798      	blx	r3
  404e24:	4603      	mov	r3, r0
  404e26:	e073      	b.n	404f10 <udc_reqstd+0x138>
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
  404e28:	4b3a      	ldr	r3, [pc, #232]	; (404f14 <udc_reqstd+0x13c>)
  404e2a:	781b      	ldrb	r3, [r3, #0]
  404e2c:	f003 031f 	and.w	r3, r3, #31
  404e30:	2b01      	cmp	r3, #1
  404e32:	d108      	bne.n	404e46 <udc_reqstd+0x6e>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
  404e34:	4b37      	ldr	r3, [pc, #220]	; (404f14 <udc_reqstd+0x13c>)
  404e36:	785b      	ldrb	r3, [r3, #1]
  404e38:	2b0a      	cmp	r3, #10
  404e3a:	d000      	beq.n	404e3e <udc_reqstd+0x66>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			default:
				break;
  404e3c:	e003      	b.n	404e46 <udc_reqstd+0x6e>
				return udc_req_std_iface_get_setting();
  404e3e:	4b39      	ldr	r3, [pc, #228]	; (404f24 <udc_reqstd+0x14c>)
  404e40:	4798      	blx	r3
  404e42:	4603      	mov	r3, r0
  404e44:	e064      	b.n	404f10 <udc_reqstd+0x138>
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
  404e46:	4b33      	ldr	r3, [pc, #204]	; (404f14 <udc_reqstd+0x13c>)
  404e48:	781b      	ldrb	r3, [r3, #0]
  404e4a:	f003 031f 	and.w	r3, r3, #31
  404e4e:	2b02      	cmp	r3, #2
  404e50:	d15d      	bne.n	404f0e <udc_reqstd+0x136>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
  404e52:	4b30      	ldr	r3, [pc, #192]	; (404f14 <udc_reqstd+0x13c>)
  404e54:	785b      	ldrb	r3, [r3, #1]
  404e56:	2b00      	cmp	r3, #0
  404e58:	d000      	beq.n	404e5c <udc_reqstd+0x84>
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
			default:
				break;
  404e5a:	e058      	b.n	404f0e <udc_reqstd+0x136>
				return udc_req_std_ep_get_status();
  404e5c:	4b32      	ldr	r3, [pc, #200]	; (404f28 <udc_reqstd+0x150>)
  404e5e:	4798      	blx	r3
  404e60:	4603      	mov	r3, r0
  404e62:	e055      	b.n	404f10 <udc_reqstd+0x138>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
  404e64:	4b2b      	ldr	r3, [pc, #172]	; (404f14 <udc_reqstd+0x13c>)
  404e66:	781b      	ldrb	r3, [r3, #0]
  404e68:	f003 031f 	and.w	r3, r3, #31
  404e6c:	2b00      	cmp	r3, #0
  404e6e:	d12a      	bne.n	404ec6 <udc_reqstd+0xee>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
  404e70:	4b28      	ldr	r3, [pc, #160]	; (404f14 <udc_reqstd+0x13c>)
  404e72:	785b      	ldrb	r3, [r3, #1]
  404e74:	3b01      	subs	r3, #1
  404e76:	2b08      	cmp	r3, #8
  404e78:	d824      	bhi.n	404ec4 <udc_reqstd+0xec>
  404e7a:	a201      	add	r2, pc, #4	; (adr r2, 404e80 <udc_reqstd+0xa8>)
  404e7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  404e80:	00404ead 	.word	0x00404ead
  404e84:	00404ec5 	.word	0x00404ec5
  404e88:	00404eb5 	.word	0x00404eb5
  404e8c:	00404ec5 	.word	0x00404ec5
  404e90:	00404ea5 	.word	0x00404ea5
  404e94:	00404ec5 	.word	0x00404ec5
  404e98:	00404ec5 	.word	0x00404ec5
  404e9c:	00404ec5 	.word	0x00404ec5
  404ea0:	00404ebd 	.word	0x00404ebd
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
  404ea4:	4b21      	ldr	r3, [pc, #132]	; (404f2c <udc_reqstd+0x154>)
  404ea6:	4798      	blx	r3
  404ea8:	4603      	mov	r3, r0
  404eaa:	e031      	b.n	404f10 <udc_reqstd+0x138>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
  404eac:	4b20      	ldr	r3, [pc, #128]	; (404f30 <udc_reqstd+0x158>)
  404eae:	4798      	blx	r3
  404eb0:	4603      	mov	r3, r0
  404eb2:	e02d      	b.n	404f10 <udc_reqstd+0x138>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
  404eb4:	4b1f      	ldr	r3, [pc, #124]	; (404f34 <udc_reqstd+0x15c>)
  404eb6:	4798      	blx	r3
  404eb8:	4603      	mov	r3, r0
  404eba:	e029      	b.n	404f10 <udc_reqstd+0x138>
			case USB_REQ_SET_CONFIGURATION:
				return udc_req_std_dev_set_configuration();
  404ebc:	4b1e      	ldr	r3, [pc, #120]	; (404f38 <udc_reqstd+0x160>)
  404ebe:	4798      	blx	r3
  404ec0:	4603      	mov	r3, r0
  404ec2:	e025      	b.n	404f10 <udc_reqstd+0x138>
			case USB_REQ_SET_DESCRIPTOR:
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			default:
				break;
  404ec4:	bf00      	nop
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
  404ec6:	4b13      	ldr	r3, [pc, #76]	; (404f14 <udc_reqstd+0x13c>)
  404ec8:	781b      	ldrb	r3, [r3, #0]
  404eca:	f003 031f 	and.w	r3, r3, #31
  404ece:	2b01      	cmp	r3, #1
  404ed0:	d108      	bne.n	404ee4 <udc_reqstd+0x10c>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
  404ed2:	4b10      	ldr	r3, [pc, #64]	; (404f14 <udc_reqstd+0x13c>)
  404ed4:	785b      	ldrb	r3, [r3, #1]
  404ed6:	2b0b      	cmp	r3, #11
  404ed8:	d000      	beq.n	404edc <udc_reqstd+0x104>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			default:
				break;
  404eda:	e003      	b.n	404ee4 <udc_reqstd+0x10c>
				return udc_req_std_iface_set_setting();
  404edc:	4b17      	ldr	r3, [pc, #92]	; (404f3c <udc_reqstd+0x164>)
  404ede:	4798      	blx	r3
  404ee0:	4603      	mov	r3, r0
  404ee2:	e015      	b.n	404f10 <udc_reqstd+0x138>
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
  404ee4:	4b0b      	ldr	r3, [pc, #44]	; (404f14 <udc_reqstd+0x13c>)
  404ee6:	781b      	ldrb	r3, [r3, #0]
  404ee8:	f003 031f 	and.w	r3, r3, #31
  404eec:	2b02      	cmp	r3, #2
  404eee:	d10e      	bne.n	404f0e <udc_reqstd+0x136>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
  404ef0:	4b08      	ldr	r3, [pc, #32]	; (404f14 <udc_reqstd+0x13c>)
  404ef2:	785b      	ldrb	r3, [r3, #1]
  404ef4:	2b01      	cmp	r3, #1
  404ef6:	d002      	beq.n	404efe <udc_reqstd+0x126>
  404ef8:	2b03      	cmp	r3, #3
  404efa:	d004      	beq.n	404f06 <udc_reqstd+0x12e>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
			default:
				break;
  404efc:	e007      	b.n	404f0e <udc_reqstd+0x136>
				return udc_req_std_ep_clear_feature();
  404efe:	4b10      	ldr	r3, [pc, #64]	; (404f40 <udc_reqstd+0x168>)
  404f00:	4798      	blx	r3
  404f02:	4603      	mov	r3, r0
  404f04:	e004      	b.n	404f10 <udc_reqstd+0x138>
				return udc_req_std_ep_set_feature();
  404f06:	4b0f      	ldr	r3, [pc, #60]	; (404f44 <udc_reqstd+0x16c>)
  404f08:	4798      	blx	r3
  404f0a:	4603      	mov	r3, r0
  404f0c:	e000      	b.n	404f10 <udc_reqstd+0x138>
			}
		}
#endif
	}
	return false;
  404f0e:	2300      	movs	r3, #0
}
  404f10:	4618      	mov	r0, r3
  404f12:	bd80      	pop	{r7, pc}
  404f14:	2000896c 	.word	0x2000896c
  404f18:	00404895 	.word	0x00404895
  404f1c:	00404ad1 	.word	0x00404ad1
  404f20:	00404bed 	.word	0x00404bed
  404f24:	00404cd9 	.word	0x00404cd9
  404f28:	004048c1 	.word	0x004048c1
  404f2c:	00404a19 	.word	0x00404a19
  404f30:	00404905 	.word	0x00404905
  404f34:	0040497d 	.word	0x0040497d
  404f38:	00404c19 	.word	0x00404c19
  404f3c:	00404d71 	.word	0x00404d71
  404f40:	00404945 	.word	0x00404945
  404f44:	004049ad 	.word	0x004049ad

00404f48 <udc_req_iface>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_iface(void)
{
  404f48:	b580      	push	{r7, lr}
  404f4a:	b082      	sub	sp, #8
  404f4c:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
  404f4e:	4b20      	ldr	r3, [pc, #128]	; (404fd0 <udc_req_iface+0x88>)
  404f50:	781b      	ldrb	r3, [r3, #0]
  404f52:	2b00      	cmp	r3, #0
  404f54:	d101      	bne.n	404f5a <udc_req_iface+0x12>
		return false; // The device is not is configured state yet
  404f56:	2300      	movs	r3, #0
  404f58:	e036      	b.n	404fc8 <udc_req_iface+0x80>
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  404f5a:	4b1e      	ldr	r3, [pc, #120]	; (404fd4 <udc_req_iface+0x8c>)
  404f5c:	889b      	ldrh	r3, [r3, #4]
  404f5e:	71fb      	strb	r3, [r7, #7]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
  404f60:	4b1d      	ldr	r3, [pc, #116]	; (404fd8 <udc_req_iface+0x90>)
  404f62:	681b      	ldr	r3, [r3, #0]
  404f64:	681b      	ldr	r3, [r3, #0]
  404f66:	791b      	ldrb	r3, [r3, #4]
  404f68:	79fa      	ldrb	r2, [r7, #7]
  404f6a:	429a      	cmp	r2, r3
  404f6c:	d301      	bcc.n	404f72 <udc_req_iface+0x2a>
		return false;
  404f6e:	2300      	movs	r3, #0
  404f70:	e02a      	b.n	404fc8 <udc_req_iface+0x80>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
  404f72:	79fb      	ldrb	r3, [r7, #7]
  404f74:	2100      	movs	r1, #0
  404f76:	4618      	mov	r0, r3
  404f78:	4b18      	ldr	r3, [pc, #96]	; (404fdc <udc_req_iface+0x94>)
  404f7a:	4798      	blx	r3
  404f7c:	4603      	mov	r3, r0
  404f7e:	f083 0301 	eor.w	r3, r3, #1
  404f82:	b2db      	uxtb	r3, r3
  404f84:	2b00      	cmp	r3, #0
  404f86:	d001      	beq.n	404f8c <udc_req_iface+0x44>
		return false;
  404f88:	2300      	movs	r3, #0
  404f8a:	e01d      	b.n	404fc8 <udc_req_iface+0x80>
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
  404f8c:	4b12      	ldr	r3, [pc, #72]	; (404fd8 <udc_req_iface+0x90>)
  404f8e:	681b      	ldr	r3, [r3, #0]
  404f90:	685a      	ldr	r2, [r3, #4]
  404f92:	79fb      	ldrb	r3, [r7, #7]
  404f94:	009b      	lsls	r3, r3, #2
  404f96:	4413      	add	r3, r2
  404f98:	681b      	ldr	r3, [r3, #0]
  404f9a:	603b      	str	r3, [r7, #0]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  404f9c:	683b      	ldr	r3, [r7, #0]
  404f9e:	68db      	ldr	r3, [r3, #12]
  404fa0:	4798      	blx	r3
  404fa2:	4603      	mov	r3, r0
  404fa4:	461a      	mov	r2, r3
  404fa6:	79fb      	ldrb	r3, [r7, #7]
  404fa8:	4611      	mov	r1, r2
  404faa:	4618      	mov	r0, r3
  404fac:	4b0b      	ldr	r3, [pc, #44]	; (404fdc <udc_req_iface+0x94>)
  404fae:	4798      	blx	r3
  404fb0:	4603      	mov	r3, r0
  404fb2:	f083 0301 	eor.w	r3, r3, #1
  404fb6:	b2db      	uxtb	r3, r3
  404fb8:	2b00      	cmp	r3, #0
  404fba:	d001      	beq.n	404fc0 <udc_req_iface+0x78>
		return false;
  404fbc:	2300      	movs	r3, #0
  404fbe:	e003      	b.n	404fc8 <udc_req_iface+0x80>
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
  404fc0:	683b      	ldr	r3, [r7, #0]
  404fc2:	689b      	ldr	r3, [r3, #8]
  404fc4:	4798      	blx	r3
  404fc6:	4603      	mov	r3, r0
}
  404fc8:	4618      	mov	r0, r3
  404fca:	3708      	adds	r7, #8
  404fcc:	46bd      	mov	sp, r7
  404fce:	bd80      	pop	{r7, pc}
  404fd0:	200087ac 	.word	0x200087ac
  404fd4:	2000896c 	.word	0x2000896c
  404fd8:	200087b0 	.word	0x200087b0
  404fdc:	004045fd 	.word	0x004045fd

00404fe0 <udc_req_ep>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_ep(void)
{
  404fe0:	b580      	push	{r7, lr}
  404fe2:	b082      	sub	sp, #8
  404fe4:	af00      	add	r7, sp, #0
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
  404fe6:	4b1e      	ldr	r3, [pc, #120]	; (405060 <udc_req_ep+0x80>)
  404fe8:	781b      	ldrb	r3, [r3, #0]
  404fea:	2b00      	cmp	r3, #0
  404fec:	d101      	bne.n	404ff2 <udc_req_ep+0x12>
		return false; // The device is not is configured state yet
  404fee:	2300      	movs	r3, #0
  404ff0:	e032      	b.n	405058 <udc_req_ep+0x78>
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
  404ff2:	4b1c      	ldr	r3, [pc, #112]	; (405064 <udc_req_ep+0x84>)
  404ff4:	889b      	ldrh	r3, [r3, #4]
  404ff6:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  404ff8:	2300      	movs	r3, #0
  404ffa:	71fb      	strb	r3, [r7, #7]
  404ffc:	e024      	b.n	405048 <udc_req_ep+0x68>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
  404ffe:	4b1a      	ldr	r3, [pc, #104]	; (405068 <udc_req_ep+0x88>)
  405000:	681b      	ldr	r3, [r3, #0]
  405002:	685a      	ldr	r2, [r3, #4]
  405004:	79fb      	ldrb	r3, [r7, #7]
  405006:	009b      	lsls	r3, r3, #2
  405008:	4413      	add	r3, r2
  40500a:	681b      	ldr	r3, [r3, #0]
  40500c:	603b      	str	r3, [r7, #0]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
  40500e:	683b      	ldr	r3, [r7, #0]
  405010:	68db      	ldr	r3, [r3, #12]
  405012:	4798      	blx	r3
  405014:	4603      	mov	r3, r0
  405016:	461a      	mov	r2, r3
  405018:	79fb      	ldrb	r3, [r7, #7]
  40501a:	4611      	mov	r1, r2
  40501c:	4618      	mov	r0, r3
  40501e:	4b13      	ldr	r3, [pc, #76]	; (40506c <udc_req_ep+0x8c>)
  405020:	4798      	blx	r3
  405022:	4603      	mov	r3, r0
  405024:	f083 0301 	eor.w	r3, r3, #1
  405028:	b2db      	uxtb	r3, r3
  40502a:	2b00      	cmp	r3, #0
  40502c:	d001      	beq.n	405032 <udc_req_ep+0x52>
			return false;
  40502e:	2300      	movs	r3, #0
  405030:	e012      	b.n	405058 <udc_req_ep+0x78>
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
  405032:	683b      	ldr	r3, [r7, #0]
  405034:	689b      	ldr	r3, [r3, #8]
  405036:	4798      	blx	r3
  405038:	4603      	mov	r3, r0
  40503a:	2b00      	cmp	r3, #0
  40503c:	d001      	beq.n	405042 <udc_req_ep+0x62>
			return true;
  40503e:	2301      	movs	r3, #1
  405040:	e00a      	b.n	405058 <udc_req_ep+0x78>
			iface_num++) {
  405042:	79fb      	ldrb	r3, [r7, #7]
  405044:	3301      	adds	r3, #1
  405046:	71fb      	strb	r3, [r7, #7]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
  405048:	4b07      	ldr	r3, [pc, #28]	; (405068 <udc_req_ep+0x88>)
  40504a:	681b      	ldr	r3, [r3, #0]
  40504c:	681b      	ldr	r3, [r3, #0]
  40504e:	791b      	ldrb	r3, [r3, #4]
  405050:	79fa      	ldrb	r2, [r7, #7]
  405052:	429a      	cmp	r2, r3
  405054:	d3d3      	bcc.n	404ffe <udc_req_ep+0x1e>
		}
	}
	return false;
  405056:	2300      	movs	r3, #0
}
  405058:	4618      	mov	r0, r3
  40505a:	3708      	adds	r7, #8
  40505c:	46bd      	mov	sp, r7
  40505e:	bd80      	pop	{r7, pc}
  405060:	200087ac 	.word	0x200087ac
  405064:	2000896c 	.word	0x2000896c
  405068:	200087b0 	.word	0x200087b0
  40506c:	004045fd 	.word	0x004045fd

00405070 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
  405070:	b580      	push	{r7, lr}
  405072:	af00      	add	r7, sp, #0
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
  405074:	4b1e      	ldr	r3, [pc, #120]	; (4050f0 <udc_process_setup+0x80>)
  405076:	2200      	movs	r2, #0
  405078:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
  40507a:	4b1d      	ldr	r3, [pc, #116]	; (4050f0 <udc_process_setup+0x80>)
  40507c:	2200      	movs	r2, #0
  40507e:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
  405080:	4b1b      	ldr	r3, [pc, #108]	; (4050f0 <udc_process_setup+0x80>)
  405082:	2200      	movs	r2, #0
  405084:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
  405086:	4b1a      	ldr	r3, [pc, #104]	; (4050f0 <udc_process_setup+0x80>)
  405088:	781b      	ldrb	r3, [r3, #0]
  40508a:	b25b      	sxtb	r3, r3
  40508c:	2b00      	cmp	r3, #0
  40508e:	da05      	bge.n	40509c <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0) {
  405090:	4b17      	ldr	r3, [pc, #92]	; (4050f0 <udc_process_setup+0x80>)
  405092:	88db      	ldrh	r3, [r3, #6]
  405094:	2b00      	cmp	r3, #0
  405096:	d101      	bne.n	40509c <udc_process_setup+0x2c>
			return false; // Error from USB host
  405098:	2300      	movs	r3, #0
  40509a:	e027      	b.n	4050ec <udc_process_setup+0x7c>
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
  40509c:	4b14      	ldr	r3, [pc, #80]	; (4050f0 <udc_process_setup+0x80>)
  40509e:	781b      	ldrb	r3, [r3, #0]
  4050a0:	f003 0360 	and.w	r3, r3, #96	; 0x60
  4050a4:	2b00      	cmp	r3, #0
  4050a6:	d106      	bne.n	4050b6 <udc_process_setup+0x46>
		if (udc_reqstd()) {
  4050a8:	4b12      	ldr	r3, [pc, #72]	; (4050f4 <udc_process_setup+0x84>)
  4050aa:	4798      	blx	r3
  4050ac:	4603      	mov	r3, r0
  4050ae:	2b00      	cmp	r3, #0
  4050b0:	d001      	beq.n	4050b6 <udc_process_setup+0x46>
			return true;
  4050b2:	2301      	movs	r3, #1
  4050b4:	e01a      	b.n	4050ec <udc_process_setup+0x7c>
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
  4050b6:	4b0e      	ldr	r3, [pc, #56]	; (4050f0 <udc_process_setup+0x80>)
  4050b8:	781b      	ldrb	r3, [r3, #0]
  4050ba:	f003 031f 	and.w	r3, r3, #31
  4050be:	2b01      	cmp	r3, #1
  4050c0:	d106      	bne.n	4050d0 <udc_process_setup+0x60>
		if (udc_req_iface()) {
  4050c2:	4b0d      	ldr	r3, [pc, #52]	; (4050f8 <udc_process_setup+0x88>)
  4050c4:	4798      	blx	r3
  4050c6:	4603      	mov	r3, r0
  4050c8:	2b00      	cmp	r3, #0
  4050ca:	d001      	beq.n	4050d0 <udc_process_setup+0x60>
			return true;
  4050cc:	2301      	movs	r3, #1
  4050ce:	e00d      	b.n	4050ec <udc_process_setup+0x7c>
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
  4050d0:	4b07      	ldr	r3, [pc, #28]	; (4050f0 <udc_process_setup+0x80>)
  4050d2:	781b      	ldrb	r3, [r3, #0]
  4050d4:	f003 031f 	and.w	r3, r3, #31
  4050d8:	2b02      	cmp	r3, #2
  4050da:	d106      	bne.n	4050ea <udc_process_setup+0x7a>
		if (udc_req_ep()) {
  4050dc:	4b07      	ldr	r3, [pc, #28]	; (4050fc <udc_process_setup+0x8c>)
  4050de:	4798      	blx	r3
  4050e0:	4603      	mov	r3, r0
  4050e2:	2b00      	cmp	r3, #0
  4050e4:	d001      	beq.n	4050ea <udc_process_setup+0x7a>
			return true;
  4050e6:	2301      	movs	r3, #1
  4050e8:	e000      	b.n	4050ec <udc_process_setup+0x7c>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
  4050ea:	2300      	movs	r3, #0
#endif
}
  4050ec:	4618      	mov	r0, r3
  4050ee:	bd80      	pop	{r7, pc}
  4050f0:	2000896c 	.word	0x2000896c
  4050f4:	00404dd9 	.word	0x00404dd9
  4050f8:	00404f49 	.word	0x00404f49
  4050fc:	00404fe1 	.word	0x00404fe1

00405100 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405100:	b580      	push	{r7, lr}
  405102:	b084      	sub	sp, #16
  405104:	af00      	add	r7, sp, #0
  405106:	6078      	str	r0, [r7, #4]
  405108:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40510a:	6878      	ldr	r0, [r7, #4]
  40510c:	4b2c      	ldr	r3, [pc, #176]	; (4051c0 <pio_handler_process+0xc0>)
  40510e:	4798      	blx	r3
  405110:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  405112:	6878      	ldr	r0, [r7, #4]
  405114:	4b2b      	ldr	r3, [pc, #172]	; (4051c4 <pio_handler_process+0xc4>)
  405116:	4798      	blx	r3
  405118:	4602      	mov	r2, r0
  40511a:	68fb      	ldr	r3, [r7, #12]
  40511c:	4013      	ands	r3, r2
  40511e:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  405120:	68fb      	ldr	r3, [r7, #12]
  405122:	2b00      	cmp	r3, #0
  405124:	d03c      	beq.n	4051a0 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  405126:	2300      	movs	r3, #0
  405128:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  40512a:	e034      	b.n	405196 <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  40512c:	4a26      	ldr	r2, [pc, #152]	; (4051c8 <pio_handler_process+0xc8>)
  40512e:	68bb      	ldr	r3, [r7, #8]
  405130:	011b      	lsls	r3, r3, #4
  405132:	4413      	add	r3, r2
  405134:	681a      	ldr	r2, [r3, #0]
  405136:	683b      	ldr	r3, [r7, #0]
  405138:	429a      	cmp	r2, r3
  40513a:	d126      	bne.n	40518a <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40513c:	4a22      	ldr	r2, [pc, #136]	; (4051c8 <pio_handler_process+0xc8>)
  40513e:	68bb      	ldr	r3, [r7, #8]
  405140:	011b      	lsls	r3, r3, #4
  405142:	4413      	add	r3, r2
  405144:	3304      	adds	r3, #4
  405146:	681a      	ldr	r2, [r3, #0]
  405148:	68fb      	ldr	r3, [r7, #12]
  40514a:	4013      	ands	r3, r2
  40514c:	2b00      	cmp	r3, #0
  40514e:	d01c      	beq.n	40518a <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  405150:	4a1d      	ldr	r2, [pc, #116]	; (4051c8 <pio_handler_process+0xc8>)
  405152:	68bb      	ldr	r3, [r7, #8]
  405154:	011b      	lsls	r3, r3, #4
  405156:	4413      	add	r3, r2
  405158:	330c      	adds	r3, #12
  40515a:	681b      	ldr	r3, [r3, #0]
  40515c:	491a      	ldr	r1, [pc, #104]	; (4051c8 <pio_handler_process+0xc8>)
  40515e:	68ba      	ldr	r2, [r7, #8]
  405160:	0112      	lsls	r2, r2, #4
  405162:	440a      	add	r2, r1
  405164:	6810      	ldr	r0, [r2, #0]
  405166:	4918      	ldr	r1, [pc, #96]	; (4051c8 <pio_handler_process+0xc8>)
  405168:	68ba      	ldr	r2, [r7, #8]
  40516a:	0112      	lsls	r2, r2, #4
  40516c:	440a      	add	r2, r1
  40516e:	3204      	adds	r2, #4
  405170:	6812      	ldr	r2, [r2, #0]
  405172:	4611      	mov	r1, r2
  405174:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  405176:	4a14      	ldr	r2, [pc, #80]	; (4051c8 <pio_handler_process+0xc8>)
  405178:	68bb      	ldr	r3, [r7, #8]
  40517a:	011b      	lsls	r3, r3, #4
  40517c:	4413      	add	r3, r2
  40517e:	3304      	adds	r3, #4
  405180:	681b      	ldr	r3, [r3, #0]
  405182:	43db      	mvns	r3, r3
  405184:	68fa      	ldr	r2, [r7, #12]
  405186:	4013      	ands	r3, r2
  405188:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  40518a:	68bb      	ldr	r3, [r7, #8]
  40518c:	3301      	adds	r3, #1
  40518e:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  405190:	68bb      	ldr	r3, [r7, #8]
  405192:	2b06      	cmp	r3, #6
  405194:	d803      	bhi.n	40519e <pio_handler_process+0x9e>
		while (status != 0) {
  405196:	68fb      	ldr	r3, [r7, #12]
  405198:	2b00      	cmp	r3, #0
  40519a:	d1c7      	bne.n	40512c <pio_handler_process+0x2c>
  40519c:	e000      	b.n	4051a0 <pio_handler_process+0xa0>
				break;
  40519e:	bf00      	nop
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  4051a0:	4b0a      	ldr	r3, [pc, #40]	; (4051cc <pio_handler_process+0xcc>)
  4051a2:	681b      	ldr	r3, [r3, #0]
  4051a4:	2b00      	cmp	r3, #0
  4051a6:	d007      	beq.n	4051b8 <pio_handler_process+0xb8>
		if (pio_capture_handler) {
  4051a8:	4b09      	ldr	r3, [pc, #36]	; (4051d0 <pio_handler_process+0xd0>)
  4051aa:	681b      	ldr	r3, [r3, #0]
  4051ac:	2b00      	cmp	r3, #0
  4051ae:	d003      	beq.n	4051b8 <pio_handler_process+0xb8>
			pio_capture_handler(p_pio);
  4051b0:	4b07      	ldr	r3, [pc, #28]	; (4051d0 <pio_handler_process+0xd0>)
  4051b2:	681b      	ldr	r3, [r3, #0]
  4051b4:	6878      	ldr	r0, [r7, #4]
  4051b6:	4798      	blx	r3
		}
	}
#endif
}
  4051b8:	bf00      	nop
  4051ba:	3710      	adds	r7, #16
  4051bc:	46bd      	mov	sp, r7
  4051be:	bd80      	pop	{r7, pc}
  4051c0:	004075b1 	.word	0x004075b1
  4051c4:	004075c9 	.word	0x004075c9
  4051c8:	200087bc 	.word	0x200087bc
  4051cc:	20008984 	.word	0x20008984
  4051d0:	20008830 	.word	0x20008830

004051d4 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4051d4:	b580      	push	{r7, lr}
  4051d6:	b086      	sub	sp, #24
  4051d8:	af00      	add	r7, sp, #0
  4051da:	60f8      	str	r0, [r7, #12]
  4051dc:	60b9      	str	r1, [r7, #8]
  4051de:	607a      	str	r2, [r7, #4]
  4051e0:	603b      	str	r3, [r7, #0]
    uint8_t i;
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4051e2:	4b21      	ldr	r3, [pc, #132]	; (405268 <pio_handler_set+0x94>)
  4051e4:	681b      	ldr	r3, [r3, #0]
  4051e6:	2b06      	cmp	r3, #6
  4051e8:	d901      	bls.n	4051ee <pio_handler_set+0x1a>
		return 1;
  4051ea:	2301      	movs	r3, #1
  4051ec:	e038      	b.n	405260 <pio_handler_set+0x8c>

    /* Check interrupt for this pin, if already defined, redefine it. */
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  4051ee:	2300      	movs	r3, #0
  4051f0:	75fb      	strb	r3, [r7, #23]
  4051f2:	e011      	b.n	405218 <pio_handler_set+0x44>
		pSource = &(gs_interrupt_sources[i]);
  4051f4:	7dfb      	ldrb	r3, [r7, #23]
  4051f6:	011b      	lsls	r3, r3, #4
  4051f8:	4a1c      	ldr	r2, [pc, #112]	; (40526c <pio_handler_set+0x98>)
  4051fa:	4413      	add	r3, r2
  4051fc:	613b      	str	r3, [r7, #16]
		if (pSource->id == ul_id && pSource->mask == ul_mask) {
  4051fe:	693b      	ldr	r3, [r7, #16]
  405200:	681a      	ldr	r2, [r3, #0]
  405202:	68bb      	ldr	r3, [r7, #8]
  405204:	429a      	cmp	r2, r3
  405206:	d104      	bne.n	405212 <pio_handler_set+0x3e>
  405208:	693b      	ldr	r3, [r7, #16]
  40520a:	685a      	ldr	r2, [r3, #4]
  40520c:	687b      	ldr	r3, [r7, #4]
  40520e:	429a      	cmp	r2, r3
  405210:	d008      	beq.n	405224 <pio_handler_set+0x50>
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  405212:	7dfb      	ldrb	r3, [r7, #23]
  405214:	3301      	adds	r3, #1
  405216:	75fb      	strb	r3, [r7, #23]
  405218:	7dfa      	ldrb	r2, [r7, #23]
  40521a:	4b13      	ldr	r3, [pc, #76]	; (405268 <pio_handler_set+0x94>)
  40521c:	681b      	ldr	r3, [r3, #0]
  40521e:	429a      	cmp	r2, r3
  405220:	d9e8      	bls.n	4051f4 <pio_handler_set+0x20>
  405222:	e000      	b.n	405226 <pio_handler_set+0x52>
			break;
  405224:	bf00      	nop
		}
	}

	/* Define new source */
	pSource->id = ul_id;
  405226:	693b      	ldr	r3, [r7, #16]
  405228:	68ba      	ldr	r2, [r7, #8]
  40522a:	601a      	str	r2, [r3, #0]
	pSource->mask = ul_mask;
  40522c:	693b      	ldr	r3, [r7, #16]
  40522e:	687a      	ldr	r2, [r7, #4]
  405230:	605a      	str	r2, [r3, #4]
	pSource->attr = ul_attr;
  405232:	693b      	ldr	r3, [r7, #16]
  405234:	683a      	ldr	r2, [r7, #0]
  405236:	609a      	str	r2, [r3, #8]
	pSource->handler = p_handler;
  405238:	693b      	ldr	r3, [r7, #16]
  40523a:	6a3a      	ldr	r2, [r7, #32]
  40523c:	60da      	str	r2, [r3, #12]
	if (i == gs_ul_nb_sources + 1) {
  40523e:	7dfa      	ldrb	r2, [r7, #23]
  405240:	4b09      	ldr	r3, [pc, #36]	; (405268 <pio_handler_set+0x94>)
  405242:	681b      	ldr	r3, [r3, #0]
  405244:	3301      	adds	r3, #1
  405246:	429a      	cmp	r2, r3
  405248:	d104      	bne.n	405254 <pio_handler_set+0x80>
		gs_ul_nb_sources++;
  40524a:	4b07      	ldr	r3, [pc, #28]	; (405268 <pio_handler_set+0x94>)
  40524c:	681b      	ldr	r3, [r3, #0]
  40524e:	3301      	adds	r3, #1
  405250:	4a05      	ldr	r2, [pc, #20]	; (405268 <pio_handler_set+0x94>)
  405252:	6013      	str	r3, [r2, #0]
	}

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  405254:	683a      	ldr	r2, [r7, #0]
  405256:	6879      	ldr	r1, [r7, #4]
  405258:	68f8      	ldr	r0, [r7, #12]
  40525a:	4b05      	ldr	r3, [pc, #20]	; (405270 <pio_handler_set+0x9c>)
  40525c:	4798      	blx	r3

	return 0;
  40525e:	2300      	movs	r3, #0
}
  405260:	4618      	mov	r0, r3
  405262:	3718      	adds	r7, #24
  405264:	46bd      	mov	sp, r7
  405266:	bd80      	pop	{r7, pc}
  405268:	2000882c 	.word	0x2000882c
  40526c:	200087bc 	.word	0x200087bc
  405270:	0040750d 	.word	0x0040750d

00405274 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  405274:	b580      	push	{r7, lr}
  405276:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  405278:	2109      	movs	r1, #9
  40527a:	4802      	ldr	r0, [pc, #8]	; (405284 <PIOA_Handler+0x10>)
  40527c:	4b02      	ldr	r3, [pc, #8]	; (405288 <PIOA_Handler+0x14>)
  40527e:	4798      	blx	r3
}
  405280:	bf00      	nop
  405282:	bd80      	pop	{r7, pc}
  405284:	400e0e00 	.word	0x400e0e00
  405288:	00405101 	.word	0x00405101

0040528c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40528c:	b580      	push	{r7, lr}
  40528e:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  405290:	210a      	movs	r1, #10
  405292:	4802      	ldr	r0, [pc, #8]	; (40529c <PIOB_Handler+0x10>)
  405294:	4b02      	ldr	r3, [pc, #8]	; (4052a0 <PIOB_Handler+0x14>)
  405296:	4798      	blx	r3
}
  405298:	bf00      	nop
  40529a:	bd80      	pop	{r7, pc}
  40529c:	400e1000 	.word	0x400e1000
  4052a0:	00405101 	.word	0x00405101

004052a4 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4052a4:	b580      	push	{r7, lr}
  4052a6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4052a8:	210b      	movs	r1, #11
  4052aa:	4802      	ldr	r0, [pc, #8]	; (4052b4 <PIOC_Handler+0x10>)
  4052ac:	4b02      	ldr	r3, [pc, #8]	; (4052b8 <PIOC_Handler+0x14>)
  4052ae:	4798      	blx	r3
}
  4052b0:	bf00      	nop
  4052b2:	bd80      	pop	{r7, pc}
  4052b4:	400e1200 	.word	0x400e1200
  4052b8:	00405101 	.word	0x00405101

004052bc <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  4052bc:	b580      	push	{r7, lr}
  4052be:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
  4052c0:	210c      	movs	r1, #12
  4052c2:	4802      	ldr	r0, [pc, #8]	; (4052cc <PIOD_Handler+0x10>)
  4052c4:	4b02      	ldr	r3, [pc, #8]	; (4052d0 <PIOD_Handler+0x14>)
  4052c6:	4798      	blx	r3
}
  4052c8:	bf00      	nop
  4052ca:	bd80      	pop	{r7, pc}
  4052cc:	400e1400 	.word	0x400e1400
  4052d0:	00405101 	.word	0x00405101

004052d4 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  4052d4:	b580      	push	{r7, lr}
  4052d6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOE, ID_PIOE);
  4052d8:	210d      	movs	r1, #13
  4052da:	4802      	ldr	r0, [pc, #8]	; (4052e4 <PIOE_Handler+0x10>)
  4052dc:	4b02      	ldr	r3, [pc, #8]	; (4052e8 <PIOE_Handler+0x14>)
  4052de:	4798      	blx	r3
}
  4052e0:	bf00      	nop
  4052e2:	bd80      	pop	{r7, pc}
  4052e4:	400e1600 	.word	0x400e1600
  4052e8:	00405101 	.word	0x00405101

004052ec <NVIC_EnableIRQ>:
{
  4052ec:	b480      	push	{r7}
  4052ee:	b083      	sub	sp, #12
  4052f0:	af00      	add	r7, sp, #0
  4052f2:	4603      	mov	r3, r0
  4052f4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4052f6:	4909      	ldr	r1, [pc, #36]	; (40531c <NVIC_EnableIRQ+0x30>)
  4052f8:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4052fc:	095b      	lsrs	r3, r3, #5
  4052fe:	79fa      	ldrb	r2, [r7, #7]
  405300:	f002 021f 	and.w	r2, r2, #31
  405304:	2001      	movs	r0, #1
  405306:	fa00 f202 	lsl.w	r2, r0, r2
  40530a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40530e:	bf00      	nop
  405310:	370c      	adds	r7, #12
  405312:	46bd      	mov	sp, r7
  405314:	f85d 7b04 	ldr.w	r7, [sp], #4
  405318:	4770      	bx	lr
  40531a:	bf00      	nop
  40531c:	e000e100 	.word	0xe000e100

00405320 <NVIC_SetPriority>:
{
  405320:	b480      	push	{r7}
  405322:	b083      	sub	sp, #12
  405324:	af00      	add	r7, sp, #0
  405326:	4603      	mov	r3, r0
  405328:	6039      	str	r1, [r7, #0]
  40532a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  40532c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  405330:	2b00      	cmp	r3, #0
  405332:	da0b      	bge.n	40534c <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  405334:	490d      	ldr	r1, [pc, #52]	; (40536c <NVIC_SetPriority+0x4c>)
  405336:	79fb      	ldrb	r3, [r7, #7]
  405338:	f003 030f 	and.w	r3, r3, #15
  40533c:	3b04      	subs	r3, #4
  40533e:	683a      	ldr	r2, [r7, #0]
  405340:	b2d2      	uxtb	r2, r2
  405342:	0112      	lsls	r2, r2, #4
  405344:	b2d2      	uxtb	r2, r2
  405346:	440b      	add	r3, r1
  405348:	761a      	strb	r2, [r3, #24]
}
  40534a:	e009      	b.n	405360 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  40534c:	4908      	ldr	r1, [pc, #32]	; (405370 <NVIC_SetPriority+0x50>)
  40534e:	f997 3007 	ldrsb.w	r3, [r7, #7]
  405352:	683a      	ldr	r2, [r7, #0]
  405354:	b2d2      	uxtb	r2, r2
  405356:	0112      	lsls	r2, r2, #4
  405358:	b2d2      	uxtb	r2, r2
  40535a:	440b      	add	r3, r1
  40535c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  405360:	bf00      	nop
  405362:	370c      	adds	r7, #12
  405364:	46bd      	mov	sp, r7
  405366:	f85d 7b04 	ldr.w	r7, [sp], #4
  40536a:	4770      	bx	lr
  40536c:	e000ed00 	.word	0xe000ed00
  405370:	e000e100 	.word	0xe000e100

00405374 <cpu_irq_save>:
{
  405374:	b480      	push	{r7}
  405376:	b083      	sub	sp, #12
  405378:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40537a:	f3ef 8310 	mrs	r3, PRIMASK
  40537e:	607b      	str	r3, [r7, #4]
  return(result);
  405380:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  405382:	2b00      	cmp	r3, #0
  405384:	bf0c      	ite	eq
  405386:	2301      	moveq	r3, #1
  405388:	2300      	movne	r3, #0
  40538a:	b2db      	uxtb	r3, r3
  40538c:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40538e:	b672      	cpsid	i
  405390:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  405394:	4b04      	ldr	r3, [pc, #16]	; (4053a8 <cpu_irq_save+0x34>)
  405396:	2200      	movs	r2, #0
  405398:	701a      	strb	r2, [r3, #0]
	return flags;
  40539a:	683b      	ldr	r3, [r7, #0]
}
  40539c:	4618      	mov	r0, r3
  40539e:	370c      	adds	r7, #12
  4053a0:	46bd      	mov	sp, r7
  4053a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4053a6:	4770      	bx	lr
  4053a8:	200001aa 	.word	0x200001aa

004053ac <cpu_irq_is_enabled_flags>:
{
  4053ac:	b480      	push	{r7}
  4053ae:	b083      	sub	sp, #12
  4053b0:	af00      	add	r7, sp, #0
  4053b2:	6078      	str	r0, [r7, #4]
	return (flags);
  4053b4:	687b      	ldr	r3, [r7, #4]
  4053b6:	2b00      	cmp	r3, #0
  4053b8:	bf14      	ite	ne
  4053ba:	2301      	movne	r3, #1
  4053bc:	2300      	moveq	r3, #0
  4053be:	b2db      	uxtb	r3, r3
}
  4053c0:	4618      	mov	r0, r3
  4053c2:	370c      	adds	r7, #12
  4053c4:	46bd      	mov	sp, r7
  4053c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4053ca:	4770      	bx	lr

004053cc <cpu_irq_restore>:
{
  4053cc:	b580      	push	{r7, lr}
  4053ce:	b082      	sub	sp, #8
  4053d0:	af00      	add	r7, sp, #0
  4053d2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4053d4:	6878      	ldr	r0, [r7, #4]
  4053d6:	4b07      	ldr	r3, [pc, #28]	; (4053f4 <cpu_irq_restore+0x28>)
  4053d8:	4798      	blx	r3
  4053da:	4603      	mov	r3, r0
  4053dc:	2b00      	cmp	r3, #0
  4053de:	d005      	beq.n	4053ec <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4053e0:	4b05      	ldr	r3, [pc, #20]	; (4053f8 <cpu_irq_restore+0x2c>)
  4053e2:	2201      	movs	r2, #1
  4053e4:	701a      	strb	r2, [r3, #0]
  4053e6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4053ea:	b662      	cpsie	i
}
  4053ec:	bf00      	nop
  4053ee:	3708      	adds	r7, #8
  4053f0:	46bd      	mov	sp, r7
  4053f2:	bd80      	pop	{r7, pc}
  4053f4:	004053ad 	.word	0x004053ad
  4053f8:	200001aa 	.word	0x200001aa

004053fc <sleepmgr_lock_mode>:
{
  4053fc:	b580      	push	{r7, lr}
  4053fe:	b084      	sub	sp, #16
  405400:	af00      	add	r7, sp, #0
  405402:	4603      	mov	r3, r0
  405404:	71fb      	strb	r3, [r7, #7]
	if(sleepmgr_locks[mode] >= 0xff) {
  405406:	79fb      	ldrb	r3, [r7, #7]
  405408:	4a0a      	ldr	r2, [pc, #40]	; (405434 <sleepmgr_lock_mode+0x38>)
  40540a:	5cd3      	ldrb	r3, [r2, r3]
  40540c:	2bff      	cmp	r3, #255	; 0xff
  40540e:	d100      	bne.n	405412 <sleepmgr_lock_mode+0x16>
		while (true) {
  405410:	e7fe      	b.n	405410 <sleepmgr_lock_mode+0x14>
	flags = cpu_irq_save();
  405412:	4b09      	ldr	r3, [pc, #36]	; (405438 <sleepmgr_lock_mode+0x3c>)
  405414:	4798      	blx	r3
  405416:	60f8      	str	r0, [r7, #12]
	++sleepmgr_locks[mode];
  405418:	79fb      	ldrb	r3, [r7, #7]
  40541a:	4a06      	ldr	r2, [pc, #24]	; (405434 <sleepmgr_lock_mode+0x38>)
  40541c:	5cd2      	ldrb	r2, [r2, r3]
  40541e:	3201      	adds	r2, #1
  405420:	b2d1      	uxtb	r1, r2
  405422:	4a04      	ldr	r2, [pc, #16]	; (405434 <sleepmgr_lock_mode+0x38>)
  405424:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
  405426:	68f8      	ldr	r0, [r7, #12]
  405428:	4b04      	ldr	r3, [pc, #16]	; (40543c <sleepmgr_lock_mode+0x40>)
  40542a:	4798      	blx	r3
}
  40542c:	bf00      	nop
  40542e:	3710      	adds	r7, #16
  405430:	46bd      	mov	sp, r7
  405432:	bd80      	pop	{r7, pc}
  405434:	20008964 	.word	0x20008964
  405438:	00405375 	.word	0x00405375
  40543c:	004053cd 	.word	0x004053cd

00405440 <sleepmgr_unlock_mode>:
 * manager can put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to unlock.
 */
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
  405440:	b580      	push	{r7, lr}
  405442:	b084      	sub	sp, #16
  405444:	af00      	add	r7, sp, #0
  405446:	4603      	mov	r3, r0
  405448:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
  40544a:	79fb      	ldrb	r3, [r7, #7]
  40544c:	4a0a      	ldr	r2, [pc, #40]	; (405478 <sleepmgr_unlock_mode+0x38>)
  40544e:	5cd3      	ldrb	r3, [r2, r3]
  405450:	2b00      	cmp	r3, #0
  405452:	d100      	bne.n	405456 <sleepmgr_unlock_mode+0x16>
		while (true) {
  405454:	e7fe      	b.n	405454 <sleepmgr_unlock_mode+0x14>
			// Check APP.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  405456:	4b09      	ldr	r3, [pc, #36]	; (40547c <sleepmgr_unlock_mode+0x3c>)
  405458:	4798      	blx	r3
  40545a:	60f8      	str	r0, [r7, #12]

	--sleepmgr_locks[mode];
  40545c:	79fb      	ldrb	r3, [r7, #7]
  40545e:	4a06      	ldr	r2, [pc, #24]	; (405478 <sleepmgr_unlock_mode+0x38>)
  405460:	5cd2      	ldrb	r2, [r2, r3]
  405462:	3a01      	subs	r2, #1
  405464:	b2d1      	uxtb	r1, r2
  405466:	4a04      	ldr	r2, [pc, #16]	; (405478 <sleepmgr_unlock_mode+0x38>)
  405468:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  40546a:	68f8      	ldr	r0, [r7, #12]
  40546c:	4b04      	ldr	r3, [pc, #16]	; (405480 <sleepmgr_unlock_mode+0x40>)
  40546e:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  405470:	bf00      	nop
  405472:	3710      	adds	r7, #16
  405474:	46bd      	mov	sp, r7
  405476:	bd80      	pop	{r7, pc}
  405478:	20008964 	.word	0x20008964
  40547c:	00405375 	.word	0x00405375
  405480:	004053cd 	.word	0x004053cd

00405484 <udd_sleep_mode>:
/*! \brief Authorize or not the CPU powerdown mode
 *
 * \param b_enable   true to authorize idle mode
 */
static void udd_sleep_mode(bool b_idle)
{
  405484:	b580      	push	{r7, lr}
  405486:	b082      	sub	sp, #8
  405488:	af00      	add	r7, sp, #0
  40548a:	4603      	mov	r3, r0
  40548c:	71fb      	strb	r3, [r7, #7]
	if (!b_idle && udd_b_idle) {
  40548e:	79fb      	ldrb	r3, [r7, #7]
  405490:	f083 0301 	eor.w	r3, r3, #1
  405494:	b2db      	uxtb	r3, r3
  405496:	2b00      	cmp	r3, #0
  405498:	d006      	beq.n	4054a8 <udd_sleep_mode+0x24>
  40549a:	4b0d      	ldr	r3, [pc, #52]	; (4054d0 <udd_sleep_mode+0x4c>)
  40549c:	781b      	ldrb	r3, [r3, #0]
  40549e:	2b00      	cmp	r3, #0
  4054a0:	d002      	beq.n	4054a8 <udd_sleep_mode+0x24>
		sleepmgr_unlock_mode(UDP_SLEEP_MODE_USB_IDLE);
  4054a2:	2002      	movs	r0, #2
  4054a4:	4b0b      	ldr	r3, [pc, #44]	; (4054d4 <udd_sleep_mode+0x50>)
  4054a6:	4798      	blx	r3
	}
	if (b_idle && !udd_b_idle) {
  4054a8:	79fb      	ldrb	r3, [r7, #7]
  4054aa:	2b00      	cmp	r3, #0
  4054ac:	d009      	beq.n	4054c2 <udd_sleep_mode+0x3e>
  4054ae:	4b08      	ldr	r3, [pc, #32]	; (4054d0 <udd_sleep_mode+0x4c>)
  4054b0:	781b      	ldrb	r3, [r3, #0]
  4054b2:	f083 0301 	eor.w	r3, r3, #1
  4054b6:	b2db      	uxtb	r3, r3
  4054b8:	2b00      	cmp	r3, #0
  4054ba:	d002      	beq.n	4054c2 <udd_sleep_mode+0x3e>
		sleepmgr_lock_mode(UDP_SLEEP_MODE_USB_IDLE);
  4054bc:	2002      	movs	r0, #2
  4054be:	4b06      	ldr	r3, [pc, #24]	; (4054d8 <udd_sleep_mode+0x54>)
  4054c0:	4798      	blx	r3
	}
	udd_b_idle = b_idle;
  4054c2:	4a03      	ldr	r2, [pc, #12]	; (4054d0 <udd_sleep_mode+0x4c>)
  4054c4:	79fb      	ldrb	r3, [r7, #7]
  4054c6:	7013      	strb	r3, [r2, #0]
}
  4054c8:	bf00      	nop
  4054ca:	3708      	adds	r7, #8
  4054cc:	46bd      	mov	sp, r7
  4054ce:	bd80      	pop	{r7, pc}
  4054d0:	20008834 	.word	0x20008834
  4054d4:	00405441 	.word	0x00405441
  4054d8:	004053fd 	.word	0x004053fd

004054dc <UDP_Handler>:
 * - control endpoint events (setup reception, end of data transfer, underflow, overflow, stall)
 * - bulk/interrupt/isochronous endpoints events (end of data transfer)
 *
 */
ISR(UDD_USB_INT_FUN)
{
  4054dc:	b580      	push	{r7, lr}
  4054de:	af00      	add	r7, sp, #0
	/* For fast wakeup clocks restore
	 * In WAIT mode, clocks are switched to FASTRC.
	 * After wakeup clocks should be restored, before that ISR should not
	 * be served.
	 */
	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
  4054e0:	4b63      	ldr	r3, [pc, #396]	; (405670 <UDP_Handler+0x194>)
  4054e2:	4798      	blx	r3
  4054e4:	4603      	mov	r3, r0
  4054e6:	f083 0301 	eor.w	r3, r3, #1
  4054ea:	b2db      	uxtb	r3, r3
  4054ec:	2b00      	cmp	r3, #0
  4054ee:	d00c      	beq.n	40550a <UDP_Handler+0x2e>
  4054f0:	4b60      	ldr	r3, [pc, #384]	; (405674 <UDP_Handler+0x198>)
  4054f2:	69db      	ldr	r3, [r3, #28]
  4054f4:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4054f8:	2b00      	cmp	r3, #0
  4054fa:	d106      	bne.n	40550a <UDP_Handler+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
  4054fc:	b672      	cpsid	i
  4054fe:	f3bf 8f5f 	dmb	sy
		cpu_irq_disable();
  405502:	4b5d      	ldr	r3, [pc, #372]	; (405678 <UDP_Handler+0x19c>)
  405504:	2200      	movs	r2, #0
  405506:	701a      	strb	r2, [r3, #0]
		return;
  405508:	e0b1      	b.n	40566e <UDP_Handler+0x192>
	}

	/* The UDP peripheral clock in the Power Management Controller (PMC)
	   must be enabled before any read/write operations to the UDP registers
	   including the UDP_TXVC register. */
	udd_enable_periph_ck();
  40550a:	2023      	movs	r0, #35	; 0x23
  40550c:	4b5b      	ldr	r3, [pc, #364]	; (40567c <UDP_Handler+0x1a0>)
  40550e:	4798      	blx	r3

	if (Is_udd_sof_interrupt_enabled() && Is_udd_sof()) {
  405510:	4b58      	ldr	r3, [pc, #352]	; (405674 <UDP_Handler+0x198>)
  405512:	699b      	ldr	r3, [r3, #24]
  405514:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  405518:	2b00      	cmp	r3, #0
  40551a:	d00c      	beq.n	405536 <UDP_Handler+0x5a>
  40551c:	4b55      	ldr	r3, [pc, #340]	; (405674 <UDP_Handler+0x198>)
  40551e:	69db      	ldr	r3, [r3, #28]
  405520:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  405524:	2b00      	cmp	r3, #0
  405526:	d006      	beq.n	405536 <UDP_Handler+0x5a>
		udd_ack_sof();
  405528:	4b52      	ldr	r3, [pc, #328]	; (405674 <UDP_Handler+0x198>)
  40552a:	f44f 6200 	mov.w	r2, #2048	; 0x800
  40552e:	621a      	str	r2, [r3, #32]
		udc_sof_notify();
  405530:	4b53      	ldr	r3, [pc, #332]	; (405680 <UDP_Handler+0x1a4>)
  405532:	4798      	blx	r3
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_sof_end;
  405534:	e099      	b.n	40566a <UDP_Handler+0x18e>
	}

	if (udd_ctrl_interrupt()) {
  405536:	4b53      	ldr	r3, [pc, #332]	; (405684 <UDP_Handler+0x1a8>)
  405538:	4798      	blx	r3
  40553a:	4603      	mov	r3, r0
  40553c:	2b00      	cmp	r3, #0
  40553e:	f040 8091 	bne.w	405664 <UDP_Handler+0x188>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
	}

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt()) {
  405542:	4b51      	ldr	r3, [pc, #324]	; (405688 <UDP_Handler+0x1ac>)
  405544:	4798      	blx	r3
  405546:	4603      	mov	r3, r0
  405548:	2b00      	cmp	r3, #0
  40554a:	f040 808d 	bne.w	405668 <UDP_Handler+0x18c>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
	}
#endif

	if ((Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) ||
  40554e:	4b49      	ldr	r3, [pc, #292]	; (405674 <UDP_Handler+0x198>)
  405550:	699b      	ldr	r3, [r3, #24]
  405552:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  405556:	2b00      	cmp	r3, #0
  405558:	d005      	beq.n	405566 <UDP_Handler+0x8a>
  40555a:	4b46      	ldr	r3, [pc, #280]	; (405674 <UDP_Handler+0x198>)
  40555c:	69db      	ldr	r3, [r3, #28]
  40555e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  405562:	2b00      	cmp	r3, #0
  405564:	d117      	bne.n	405596 <UDP_Handler+0xba>
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  405566:	4b43      	ldr	r3, [pc, #268]	; (405674 <UDP_Handler+0x198>)
  405568:	699b      	ldr	r3, [r3, #24]
  40556a:	f403 7300 	and.w	r3, r3, #512	; 0x200
	if ((Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) ||
  40556e:	2b00      	cmp	r3, #0
  405570:	d005      	beq.n	40557e <UDP_Handler+0xa2>
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  405572:	4b40      	ldr	r3, [pc, #256]	; (405674 <UDP_Handler+0x198>)
  405574:	69db      	ldr	r3, [r3, #28]
  405576:	f403 7300 	and.w	r3, r3, #512	; 0x200
  40557a:	2b00      	cmp	r3, #0
  40557c:	d10b      	bne.n	405596 <UDP_Handler+0xba>
		(Is_udd_ext_resume_interrupt_enabled() && Is_udd_ext_resume())) {
  40557e:	4b3d      	ldr	r3, [pc, #244]	; (405674 <UDP_Handler+0x198>)
  405580:	699b      	ldr	r3, [r3, #24]
  405582:	f403 6380 	and.w	r3, r3, #1024	; 0x400
		(Is_udd_resume_interrupt_enabled() && Is_udd_resume()) ||
  405586:	2b00      	cmp	r3, #0
  405588:	d01d      	beq.n	4055c6 <UDP_Handler+0xea>
		(Is_udd_ext_resume_interrupt_enabled() && Is_udd_ext_resume())) {
  40558a:	4b3a      	ldr	r3, [pc, #232]	; (405674 <UDP_Handler+0x198>)
  40558c:	69db      	ldr	r3, [r3, #28]
  40558e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  405592:	2b00      	cmp	r3, #0
  405594:	d017      	beq.n	4055c6 <UDP_Handler+0xea>
		// Ack wakeup interrupt and enable suspend interrupt
		udd_ack_wakeups();
  405596:	4b37      	ldr	r3, [pc, #220]	; (405674 <UDP_Handler+0x198>)
  405598:	f44f 5218 	mov.w	r2, #9728	; 0x2600
  40559c:	621a      	str	r2, [r3, #32]
		// Do resume operations
		udd_disable_wakeups();
  40559e:	4b35      	ldr	r3, [pc, #212]	; (405674 <UDP_Handler+0x198>)
  4055a0:	f44f 5218 	mov.w	r2, #9728	; 0x2600
  4055a4:	615a      	str	r2, [r3, #20]

		udd_sleep_mode(true); // Enter in IDLE mode
  4055a6:	2001      	movs	r0, #1
  4055a8:	4b38      	ldr	r3, [pc, #224]	; (40568c <UDP_Handler+0x1b0>)
  4055aa:	4798      	blx	r3
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		udd_ack_suspend();
  4055ac:	4b31      	ldr	r3, [pc, #196]	; (405674 <UDP_Handler+0x198>)
  4055ae:	f44f 7280 	mov.w	r2, #256	; 0x100
  4055b2:	621a      	str	r2, [r3, #32]
		udd_enable_suspend_interrupt();
  4055b4:	4b2f      	ldr	r3, [pc, #188]	; (405674 <UDP_Handler+0x198>)
  4055b6:	f44f 7280 	mov.w	r2, #256	; 0x100
  4055ba:	611a      	str	r2, [r3, #16]
		udd_enable_sof_interrupt();
  4055bc:	4b2d      	ldr	r3, [pc, #180]	; (405674 <UDP_Handler+0x198>)
  4055be:	f44f 6200 	mov.w	r2, #2048	; 0x800
  4055c2:	611a      	str	r2, [r3, #16]
		goto udd_interrupt_end;
  4055c4:	e051      	b.n	40566a <UDP_Handler+0x18e>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
  4055c6:	4b2b      	ldr	r3, [pc, #172]	; (405674 <UDP_Handler+0x198>)
  4055c8:	699b      	ldr	r3, [r3, #24]
  4055ca:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4055ce:	2b00      	cmp	r3, #0
  4055d0:	d020      	beq.n	405614 <UDP_Handler+0x138>
  4055d2:	4b28      	ldr	r3, [pc, #160]	; (405674 <UDP_Handler+0x198>)
  4055d4:	69db      	ldr	r3, [r3, #28]
  4055d6:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4055da:	2b00      	cmp	r3, #0
  4055dc:	d01a      	beq.n	405614 <UDP_Handler+0x138>
		// Ack suspend interrupt and enable resume interrupt
		udd_ack_suspend();
  4055de:	4b25      	ldr	r3, [pc, #148]	; (405674 <UDP_Handler+0x198>)
  4055e0:	f44f 7280 	mov.w	r2, #256	; 0x100
  4055e4:	621a      	str	r2, [r3, #32]
		udd_disable_suspend_interrupt();
  4055e6:	4b23      	ldr	r3, [pc, #140]	; (405674 <UDP_Handler+0x198>)
  4055e8:	f44f 7280 	mov.w	r2, #256	; 0x100
  4055ec:	615a      	str	r2, [r3, #20]
		udd_enable_wake_up_interrupt();
  4055ee:	4b21      	ldr	r3, [pc, #132]	; (405674 <UDP_Handler+0x198>)
  4055f0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  4055f4:	611a      	str	r2, [r3, #16]
		udd_enable_resume_interrupt();
  4055f6:	4b1f      	ldr	r3, [pc, #124]	; (405674 <UDP_Handler+0x198>)
  4055f8:	f44f 7200 	mov.w	r2, #512	; 0x200
  4055fc:	611a      	str	r2, [r3, #16]
		udd_enable_ext_resume_interrupt();
  4055fe:	4b1d      	ldr	r3, [pc, #116]	; (405674 <UDP_Handler+0x198>)
  405600:	f44f 6280 	mov.w	r2, #1024	; 0x400
  405604:	611a      	str	r2, [r3, #16]
		udd_disable_periph_ck();
  405606:	2023      	movs	r0, #35	; 0x23
  405608:	4b21      	ldr	r3, [pc, #132]	; (405690 <UDP_Handler+0x1b4>)
  40560a:	4798      	blx	r3

		udd_sleep_mode(false); // Enter in SUSPEND mode
  40560c:	2000      	movs	r0, #0
  40560e:	4b1f      	ldr	r3, [pc, #124]	; (40568c <UDP_Handler+0x1b0>)
  405610:	4798      	blx	r3
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
  405612:	e02a      	b.n	40566a <UDP_Handler+0x18e>
	}
	if (Is_udd_reset()) {
  405614:	4b17      	ldr	r3, [pc, #92]	; (405674 <UDP_Handler+0x198>)
  405616:	69db      	ldr	r3, [r3, #28]
  405618:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  40561c:	2b00      	cmp	r3, #0
  40561e:	d025      	beq.n	40566c <UDP_Handler+0x190>
		// USB bus reset detection
		udd_ack_reset();
  405620:	4b14      	ldr	r3, [pc, #80]	; (405674 <UDP_Handler+0x198>)
  405622:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  405626:	621a      	str	r2, [r3, #32]

		// Abort all jobs on-going
#if (0 != USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
  405628:	4b1a      	ldr	r3, [pc, #104]	; (405694 <UDP_Handler+0x1b8>)
  40562a:	4798      	blx	r3
#endif
		// Reset USB Device Stack Core
		udc_reset();
  40562c:	4b1a      	ldr	r3, [pc, #104]	; (405698 <UDP_Handler+0x1bc>)
  40562e:	4798      	blx	r3
		// Reset device state
		udd_disable_address_state();
  405630:	4a10      	ldr	r2, [pc, #64]	; (405674 <UDP_Handler+0x198>)
  405632:	4b10      	ldr	r3, [pc, #64]	; (405674 <UDP_Handler+0x198>)
  405634:	685b      	ldr	r3, [r3, #4]
  405636:	f023 0301 	bic.w	r3, r3, #1
  40563a:	6053      	str	r3, [r2, #4]
		udd_disable_configured_state();
  40563c:	4a0d      	ldr	r2, [pc, #52]	; (405674 <UDP_Handler+0x198>)
  40563e:	4b0d      	ldr	r3, [pc, #52]	; (405674 <UDP_Handler+0x198>)
  405640:	685b      	ldr	r3, [r3, #4]
  405642:	f023 0302 	bic.w	r3, r3, #2
  405646:	6053      	str	r3, [r2, #4]
		// Reset endpoint control
		udd_reset_ep_ctrl();
  405648:	4b14      	ldr	r3, [pc, #80]	; (40569c <UDP_Handler+0x1c0>)
  40564a:	4798      	blx	r3
		// Reset endpoint control management
		udd_ctrl_init();
  40564c:	4b14      	ldr	r3, [pc, #80]	; (4056a0 <UDP_Handler+0x1c4>)
  40564e:	4798      	blx	r3
		// After a USB reset, the suspend and SOF interrupt masks has been reseted
		// Thus, re-enable these
		udd_enable_suspend_interrupt();
  405650:	4b08      	ldr	r3, [pc, #32]	; (405674 <UDP_Handler+0x198>)
  405652:	f44f 7280 	mov.w	r2, #256	; 0x100
  405656:	611a      	str	r2, [r3, #16]
		udd_enable_sof_interrupt();
  405658:	4b06      	ldr	r3, [pc, #24]	; (405674 <UDP_Handler+0x198>)
  40565a:	f44f 6200 	mov.w	r2, #2048	; 0x800
  40565e:	611a      	str	r2, [r3, #16]
		goto udd_interrupt_end;
  405660:	bf00      	nop
  405662:	e002      	b.n	40566a <UDP_Handler+0x18e>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
  405664:	bf00      	nop
  405666:	e000      	b.n	40566a <UDP_Handler+0x18e>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
  405668:	bf00      	nop
	}

udd_interrupt_end:
udd_interrupt_sof_end:
	return;
  40566a:	bf00      	nop
  40566c:	bf00      	nop
}
  40566e:	bd80      	pop	{r7, pc}
  405670:	004083ad 	.word	0x004083ad
  405674:	40084000 	.word	0x40084000
  405678:	200001aa 	.word	0x200001aa
  40567c:	0040823d 	.word	0x0040823d
  405680:	00404835 	.word	0x00404835
  405684:	0040686d 	.word	0x0040686d
  405688:	00406f71 	.word	0x00406f71
  40568c:	00405485 	.word	0x00405485
  405690:	004082c1 	.word	0x004082c1
  405694:	004069c1 	.word	0x004069c1
  405698:	004047e1 	.word	0x004047e1
  40569c:	004060bd 	.word	0x004060bd
  4056a0:	00406165 	.word	0x00406165

004056a4 <udd_enable>:
#endif
}


void udd_enable(void)
{
  4056a4:	b580      	push	{r7, lr}
  4056a6:	b082      	sub	sp, #8
  4056a8:	af00      	add	r7, sp, #0
	irqflags_t flags;

	flags = cpu_irq_save();
  4056aa:	4b12      	ldr	r3, [pc, #72]	; (4056f4 <udd_enable+0x50>)
  4056ac:	4798      	blx	r3
  4056ae:	6078      	str	r0, [r7, #4]
#if SAMG55
	matrix_set_usb_device();
#endif

	// Enable USB hardware
	udd_enable_periph_ck();
  4056b0:	2023      	movs	r0, #35	; 0x23
  4056b2:	4b11      	ldr	r3, [pc, #68]	; (4056f8 <udd_enable+0x54>)
  4056b4:	4798      	blx	r3
	sysclk_enable_usb();
  4056b6:	4b11      	ldr	r3, [pc, #68]	; (4056fc <udd_enable+0x58>)
  4056b8:	4798      	blx	r3
	// Cortex, uses NVIC, no need to register IRQ handler
	NVIC_SetPriority((IRQn_Type) ID_UDP, UDD_USB_INT_LEVEL);
  4056ba:	2100      	movs	r1, #0
  4056bc:	2023      	movs	r0, #35	; 0x23
  4056be:	4b10      	ldr	r3, [pc, #64]	; (405700 <udd_enable+0x5c>)
  4056c0:	4798      	blx	r3
	NVIC_EnableIRQ((IRQn_Type) ID_UDP);
  4056c2:	2023      	movs	r0, #35	; 0x23
  4056c4:	4b0f      	ldr	r3, [pc, #60]	; (405704 <udd_enable+0x60>)
  4056c6:	4798      	blx	r3

	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	udd_ep_job_table_reset();
  4056c8:	4b0f      	ldr	r3, [pc, #60]	; (405708 <udd_enable+0x64>)
  4056ca:	4798      	blx	r3
#endif

	// Always authorize asynchronous USB interrupts to exit of sleep mode
	pmc_set_fast_startup_input(PMC_FSMR_USBAL);
  4056cc:	f44f 2080 	mov.w	r0, #262144	; 0x40000
  4056d0:	4b0e      	ldr	r3, [pc, #56]	; (40570c <udd_enable+0x68>)
  4056d2:	4798      	blx	r3

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
  4056d4:	4b0e      	ldr	r3, [pc, #56]	; (405710 <udd_enable+0x6c>)
  4056d6:	2200      	movs	r2, #0
  4056d8:	701a      	strb	r2, [r3, #0]
	sleepmgr_lock_mode(UDP_SLEEP_MODE_USB_SUSPEND);
  4056da:	2000      	movs	r0, #0
  4056dc:	4b0d      	ldr	r3, [pc, #52]	; (405714 <udd_enable+0x70>)
  4056de:	4798      	blx	r3
	if (Is_udd_vbus_high()) {
		udd_vbus_handler(USB_VBUS_PIO_ID, USB_VBUS_PIO_MASK);
	}
#else
#  ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
	udd_attach();
  4056e0:	4b0d      	ldr	r3, [pc, #52]	; (405718 <udd_enable+0x74>)
  4056e2:	4798      	blx	r3
#  endif
#endif

	cpu_irq_restore(flags);
  4056e4:	6878      	ldr	r0, [r7, #4]
  4056e6:	4b0d      	ldr	r3, [pc, #52]	; (40571c <udd_enable+0x78>)
  4056e8:	4798      	blx	r3
}
  4056ea:	bf00      	nop
  4056ec:	3708      	adds	r7, #8
  4056ee:	46bd      	mov	sp, r7
  4056f0:	bd80      	pop	{r7, pc}
  4056f2:	bf00      	nop
  4056f4:	00405375 	.word	0x00405375
  4056f8:	0040823d 	.word	0x0040823d
  4056fc:	004078a1 	.word	0x004078a1
  405700:	00405321 	.word	0x00405321
  405704:	004052ed 	.word	0x004052ed
  405708:	00406915 	.word	0x00406915
  40570c:	00408381 	.word	0x00408381
  405710:	20008834 	.word	0x20008834
  405714:	004053fd 	.word	0x004053fd
  405718:	00405721 	.word	0x00405721
  40571c:	004053cd 	.word	0x004053cd

00405720 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
  405720:	b580      	push	{r7, lr}
  405722:	b082      	sub	sp, #8
  405724:	af00      	add	r7, sp, #0
	irqflags_t flags;
	flags = cpu_irq_save();
  405726:	4b18      	ldr	r3, [pc, #96]	; (405788 <udd_attach+0x68>)
  405728:	4798      	blx	r3
  40572a:	6078      	str	r0, [r7, #4]

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
  40572c:	2001      	movs	r0, #1
  40572e:	4b17      	ldr	r3, [pc, #92]	; (40578c <udd_attach+0x6c>)
  405730:	4798      	blx	r3

	// Enable peripheral clock and USB clock
	udd_enable_periph_ck();
  405732:	2023      	movs	r0, #35	; 0x23
  405734:	4b16      	ldr	r3, [pc, #88]	; (405790 <udd_attach+0x70>)
  405736:	4798      	blx	r3

	// Authorize attach if VBus is present
	udd_enable_transceiver();
  405738:	4a16      	ldr	r2, [pc, #88]	; (405794 <udd_attach+0x74>)
  40573a:	4b16      	ldr	r3, [pc, #88]	; (405794 <udd_attach+0x74>)
  40573c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40573e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  405742:	6753      	str	r3, [r2, #116]	; 0x74
	udd_attach_device();
  405744:	4a13      	ldr	r2, [pc, #76]	; (405794 <udd_attach+0x74>)
  405746:	4b13      	ldr	r3, [pc, #76]	; (405794 <udd_attach+0x74>)
  405748:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40574a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  40574e:	6753      	str	r3, [r2, #116]	; 0x74

	// Enable USB line events
	udd_enable_suspend_interrupt();
  405750:	4b10      	ldr	r3, [pc, #64]	; (405794 <udd_attach+0x74>)
  405752:	f44f 7280 	mov.w	r2, #256	; 0x100
  405756:	611a      	str	r2, [r3, #16]
	udd_enable_wake_up_interrupt();
  405758:	4b0e      	ldr	r3, [pc, #56]	; (405794 <udd_attach+0x74>)
  40575a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  40575e:	611a      	str	r2, [r3, #16]
	udd_enable_resume_interrupt();
  405760:	4b0c      	ldr	r3, [pc, #48]	; (405794 <udd_attach+0x74>)
  405762:	f44f 7200 	mov.w	r2, #512	; 0x200
  405766:	611a      	str	r2, [r3, #16]
	udd_enable_ext_resume_interrupt();
  405768:	4b0a      	ldr	r3, [pc, #40]	; (405794 <udd_attach+0x74>)
  40576a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40576e:	611a      	str	r2, [r3, #16]
	udd_enable_sof_interrupt();
  405770:	4b08      	ldr	r3, [pc, #32]	; (405794 <udd_attach+0x74>)
  405772:	f44f 6200 	mov.w	r2, #2048	; 0x800
  405776:	611a      	str	r2, [r3, #16]

	cpu_irq_restore(flags);
  405778:	6878      	ldr	r0, [r7, #4]
  40577a:	4b07      	ldr	r3, [pc, #28]	; (405798 <udd_attach+0x78>)
  40577c:	4798      	blx	r3
}
  40577e:	bf00      	nop
  405780:	3708      	adds	r7, #8
  405782:	46bd      	mov	sp, r7
  405784:	bd80      	pop	{r7, pc}
  405786:	bf00      	nop
  405788:	00405375 	.word	0x00405375
  40578c:	00405485 	.word	0x00405485
  405790:	0040823d 	.word	0x0040823d
  405794:	40084000 	.word	0x40084000
  405798:	004053cd 	.word	0x004053cd

0040579c <udd_is_high_speed>:
	udd_sleep_mode(false);
}


bool udd_is_high_speed(void)
{
  40579c:	b480      	push	{r7}
  40579e:	af00      	add	r7, sp, #0
	return false;
  4057a0:	2300      	movs	r3, #0
}
  4057a2:	4618      	mov	r0, r3
  4057a4:	46bd      	mov	sp, r7
  4057a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4057aa:	4770      	bx	lr

004057ac <udd_set_address>:


void udd_set_address(uint8_t address)
{
  4057ac:	b480      	push	{r7}
  4057ae:	b083      	sub	sp, #12
  4057b0:	af00      	add	r7, sp, #0
  4057b2:	4603      	mov	r3, r0
  4057b4:	71fb      	strb	r3, [r7, #7]
	udd_disable_address_state();
  4057b6:	4a15      	ldr	r2, [pc, #84]	; (40580c <udd_set_address+0x60>)
  4057b8:	4b14      	ldr	r3, [pc, #80]	; (40580c <udd_set_address+0x60>)
  4057ba:	685b      	ldr	r3, [r3, #4]
  4057bc:	f023 0301 	bic.w	r3, r3, #1
  4057c0:	6053      	str	r3, [r2, #4]
	udd_disable_address();
  4057c2:	4a12      	ldr	r2, [pc, #72]	; (40580c <udd_set_address+0x60>)
  4057c4:	4b11      	ldr	r3, [pc, #68]	; (40580c <udd_set_address+0x60>)
  4057c6:	689b      	ldr	r3, [r3, #8]
  4057c8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  4057cc:	6093      	str	r3, [r2, #8]
	if (address) {
  4057ce:	79fb      	ldrb	r3, [r7, #7]
  4057d0:	2b00      	cmp	r3, #0
  4057d2:	d015      	beq.n	405800 <udd_set_address+0x54>
		udd_configure_address(address);
  4057d4:	490d      	ldr	r1, [pc, #52]	; (40580c <udd_set_address+0x60>)
  4057d6:	4b0d      	ldr	r3, [pc, #52]	; (40580c <udd_set_address+0x60>)
  4057d8:	689b      	ldr	r3, [r3, #8]
  4057da:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
  4057de:	79fb      	ldrb	r3, [r7, #7]
  4057e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  4057e4:	4313      	orrs	r3, r2
  4057e6:	608b      	str	r3, [r1, #8]
		udd_enable_address();
  4057e8:	4a08      	ldr	r2, [pc, #32]	; (40580c <udd_set_address+0x60>)
  4057ea:	4b08      	ldr	r3, [pc, #32]	; (40580c <udd_set_address+0x60>)
  4057ec:	689b      	ldr	r3, [r3, #8]
  4057ee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4057f2:	6093      	str	r3, [r2, #8]
		udd_enable_address_state();
  4057f4:	4a05      	ldr	r2, [pc, #20]	; (40580c <udd_set_address+0x60>)
  4057f6:	4b05      	ldr	r3, [pc, #20]	; (40580c <udd_set_address+0x60>)
  4057f8:	685b      	ldr	r3, [r3, #4]
  4057fa:	f043 0301 	orr.w	r3, r3, #1
  4057fe:	6053      	str	r3, [r2, #4]
	}
}
  405800:	bf00      	nop
  405802:	370c      	adds	r7, #12
  405804:	46bd      	mov	sp, r7
  405806:	f85d 7b04 	ldr.w	r7, [sp], #4
  40580a:	4770      	bx	lr
  40580c:	40084000 	.word	0x40084000

00405810 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
  405810:	b480      	push	{r7}
  405812:	af00      	add	r7, sp, #0
	if (Is_udd_address_state_enabled())
  405814:	4b09      	ldr	r3, [pc, #36]	; (40583c <udd_getaddress+0x2c>)
  405816:	685b      	ldr	r3, [r3, #4]
  405818:	f003 0301 	and.w	r3, r3, #1
  40581c:	2b00      	cmp	r3, #0
  40581e:	d006      	beq.n	40582e <udd_getaddress+0x1e>
		return udd_get_configured_address();
  405820:	4b06      	ldr	r3, [pc, #24]	; (40583c <udd_getaddress+0x2c>)
  405822:	689b      	ldr	r3, [r3, #8]
  405824:	b2db      	uxtb	r3, r3
  405826:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40582a:	b2db      	uxtb	r3, r3
  40582c:	e000      	b.n	405830 <udd_getaddress+0x20>
	return 0;
  40582e:	2300      	movs	r3, #0
}
  405830:	4618      	mov	r0, r3
  405832:	46bd      	mov	sp, r7
  405834:	f85d 7b04 	ldr.w	r7, [sp], #4
  405838:	4770      	bx	lr
  40583a:	bf00      	nop
  40583c:	40084000 	.word	0x40084000

00405840 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
  405840:	b480      	push	{r7}
  405842:	af00      	add	r7, sp, #0
	return udd_frame_number();
  405844:	4b05      	ldr	r3, [pc, #20]	; (40585c <udd_get_frame_number+0x1c>)
  405846:	681b      	ldr	r3, [r3, #0]
  405848:	b29b      	uxth	r3, r3
  40584a:	f3c3 030a 	ubfx	r3, r3, #0, #11
  40584e:	b29b      	uxth	r3, r3
}
  405850:	4618      	mov	r0, r3
  405852:	46bd      	mov	sp, r7
  405854:	f85d 7b04 	ldr.w	r7, [sp], #4
  405858:	4770      	bx	lr
  40585a:	bf00      	nop
  40585c:	40084000 	.word	0x40084000

00405860 <udd_get_micro_frame_number>:


uint16_t udd_get_micro_frame_number(void)
{
  405860:	b480      	push	{r7}
  405862:	af00      	add	r7, sp, #0
	return 0;
  405864:	2300      	movs	r3, #0
}
  405866:	4618      	mov	r0, r3
  405868:	46bd      	mov	sp, r7
  40586a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40586e:	4770      	bx	lr

00405870 <udd_set_setup_payload>:
	}
}


void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
  405870:	b480      	push	{r7}
  405872:	b083      	sub	sp, #12
  405874:	af00      	add	r7, sp, #0
  405876:	6078      	str	r0, [r7, #4]
  405878:	460b      	mov	r3, r1
  40587a:	807b      	strh	r3, [r7, #2]
	udd_g_ctrlreq.payload = payload;
  40587c:	4a05      	ldr	r2, [pc, #20]	; (405894 <udd_set_setup_payload+0x24>)
  40587e:	687b      	ldr	r3, [r7, #4]
  405880:	6093      	str	r3, [r2, #8]
	udd_g_ctrlreq.payload_size = payload_size;
  405882:	4a04      	ldr	r2, [pc, #16]	; (405894 <udd_set_setup_payload+0x24>)
  405884:	887b      	ldrh	r3, [r7, #2]
  405886:	8193      	strh	r3, [r2, #12]
}
  405888:	bf00      	nop
  40588a:	370c      	adds	r7, #12
  40588c:	46bd      	mov	sp, r7
  40588e:	f85d 7b04 	ldr.w	r7, [sp], #4
  405892:	4770      	bx	lr
  405894:	2000896c 	.word	0x2000896c

00405898 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
  405898:	b480      	push	{r7}
  40589a:	b087      	sub	sp, #28
  40589c:	af00      	add	r7, sp, #0
  40589e:	4603      	mov	r3, r0
  4058a0:	71fb      	strb	r3, [r7, #7]
  4058a2:	460b      	mov	r3, r1
  4058a4:	71bb      	strb	r3, [r7, #6]
  4058a6:	4613      	mov	r3, r2
  4058a8:	80bb      	strh	r3, [r7, #4]
	udd_ep_job_t *ptr_job;
	bool b_dir_in;
	bool b_iso;
	b_dir_in = ep & USB_EP_DIR_IN;
  4058aa:	79fb      	ldrb	r3, [r7, #7]
  4058ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4058b0:	2b00      	cmp	r3, #0
  4058b2:	bf14      	ite	ne
  4058b4:	2301      	movne	r3, #1
  4058b6:	2300      	moveq	r3, #0
  4058b8:	75fb      	strb	r3, [r7, #23]
	b_iso = (bmAttributes&USB_EP_TYPE_MASK) == USB_EP_TYPE_ISOCHRONOUS;
  4058ba:	79bb      	ldrb	r3, [r7, #6]
  4058bc:	f003 0303 	and.w	r3, r3, #3
  4058c0:	2b01      	cmp	r3, #1
  4058c2:	bf0c      	ite	eq
  4058c4:	2301      	moveq	r3, #1
  4058c6:	2300      	movne	r3, #0
  4058c8:	75bb      	strb	r3, [r7, #22]
	ep = ep & USB_EP_ADDR_MASK;
  4058ca:	79fb      	ldrb	r3, [r7, #7]
  4058cc:	f003 030f 	and.w	r3, r3, #15
  4058d0:	71fb      	strb	r3, [r7, #7]

	if (ep > USB_DEVICE_MAX_EP) {
  4058d2:	79fb      	ldrb	r3, [r7, #7]
  4058d4:	2b03      	cmp	r3, #3
  4058d6:	d901      	bls.n	4058dc <udd_ep_alloc+0x44>
		return false;
  4058d8:	2300      	movs	r3, #0
  4058da:	e0bd      	b.n	405a58 <udd_ep_alloc+0x1c0>
	}
	if (Is_udd_endpoint_enabled(ep)) {
  4058dc:	4a61      	ldr	r2, [pc, #388]	; (405a64 <udd_ep_alloc+0x1cc>)
  4058de:	79fb      	ldrb	r3, [r7, #7]
  4058e0:	330c      	adds	r3, #12
  4058e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4058e6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  4058ea:	2b00      	cmp	r3, #0
  4058ec:	d001      	beq.n	4058f2 <udd_ep_alloc+0x5a>
		return false;
  4058ee:	2300      	movs	r3, #0
  4058f0:	e0b2      	b.n	405a58 <udd_ep_alloc+0x1c0>
	}

	// Check parameters
	if (b_iso && (!udd_is_endpoint_support_iso(ep))) {
  4058f2:	7dbb      	ldrb	r3, [r7, #22]
  4058f4:	2b00      	cmp	r3, #0
  4058f6:	d007      	beq.n	405908 <udd_ep_alloc+0x70>
  4058f8:	79fb      	ldrb	r3, [r7, #7]
  4058fa:	2b00      	cmp	r3, #0
  4058fc:	d002      	beq.n	405904 <udd_ep_alloc+0x6c>
  4058fe:	79fb      	ldrb	r3, [r7, #7]
  405900:	2b03      	cmp	r3, #3
  405902:	d101      	bne.n	405908 <udd_ep_alloc+0x70>
		return false;
  405904:	2300      	movs	r3, #0
  405906:	e0a7      	b.n	405a58 <udd_ep_alloc+0x1c0>
	}
	if (MaxEndpointSize > udd_get_endpoint_size_max(ep)) {
  405908:	88ba      	ldrh	r2, [r7, #4]
  40590a:	79fb      	ldrb	r3, [r7, #7]
  40590c:	2b04      	cmp	r3, #4
  40590e:	d002      	beq.n	405916 <udd_ep_alloc+0x7e>
  405910:	79fb      	ldrb	r3, [r7, #7]
  405912:	2b05      	cmp	r3, #5
  405914:	d102      	bne.n	40591c <udd_ep_alloc+0x84>
  405916:	f44f 7300 	mov.w	r3, #512	; 0x200
  40591a:	e000      	b.n	40591e <udd_ep_alloc+0x86>
  40591c:	2340      	movs	r3, #64	; 0x40
  40591e:	429a      	cmp	r2, r3
  405920:	dd01      	ble.n	405926 <udd_ep_alloc+0x8e>
		return false;
  405922:	2300      	movs	r3, #0
  405924:	e098      	b.n	405a58 <udd_ep_alloc+0x1c0>
	}
	ptr_job = &udd_ep_job[ep - 1];
  405926:	79fb      	ldrb	r3, [r7, #7]
  405928:	1e5a      	subs	r2, r3, #1
  40592a:	4613      	mov	r3, r2
  40592c:	009b      	lsls	r3, r3, #2
  40592e:	4413      	add	r3, r2
  405930:	009b      	lsls	r3, r3, #2
  405932:	4a4d      	ldr	r2, [pc, #308]	; (405a68 <udd_ep_alloc+0x1d0>)
  405934:	4413      	add	r3, r2
  405936:	613b      	str	r3, [r7, #16]

	// Set endpoint size
	ptr_job->size = MaxEndpointSize;
  405938:	88bb      	ldrh	r3, [r7, #4]
  40593a:	f3c3 0309 	ubfx	r3, r3, #0, #10
  40593e:	b299      	uxth	r1, r3
  405940:	693a      	ldr	r2, [r7, #16]
  405942:	8a13      	ldrh	r3, [r2, #16]
  405944:	f361 0309 	bfi	r3, r1, #0, #10
  405948:	8213      	strh	r3, [r2, #16]
	ptr_job->b_buf_end = false;
  40594a:	693a      	ldr	r2, [r7, #16]
  40594c:	7c53      	ldrb	r3, [r2, #17]
  40594e:	f36f 13c7 	bfc	r3, #7, #1
  405952:	7453      	strb	r3, [r2, #17]
	ptr_job->b_stall_requested = false;
  405954:	693a      	ldr	r2, [r7, #16]
  405956:	7c53      	ldrb	r3, [r2, #17]
  405958:	f36f 1345 	bfc	r3, #5, #1
  40595c:	7453      	strb	r3, [r2, #17]
	if (b_dir_in) {
  40595e:	7dfb      	ldrb	r3, [r7, #23]
  405960:	2b00      	cmp	r3, #0
  405962:	d004      	beq.n	40596e <udd_ep_alloc+0xd6>
		// No data buffered in FIFO
		ptr_job->bank = 0;
  405964:	693a      	ldr	r2, [r7, #16]
  405966:	7c53      	ldrb	r3, [r2, #17]
  405968:	f36f 0383 	bfc	r3, #2, #2
  40596c:	7453      	strb	r3, [r2, #17]
	}

	// Reset FIFOs
	udd_reset_endpoint(ep);
  40596e:	493d      	ldr	r1, [pc, #244]	; (405a64 <udd_ep_alloc+0x1cc>)
  405970:	4b3c      	ldr	r3, [pc, #240]	; (405a64 <udd_ep_alloc+0x1cc>)
  405972:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  405974:	79fb      	ldrb	r3, [r7, #7]
  405976:	2001      	movs	r0, #1
  405978:	fa00 f303 	lsl.w	r3, r0, r3
  40597c:	4313      	orrs	r3, r2
  40597e:	628b      	str	r3, [r1, #40]	; 0x28
  405980:	4938      	ldr	r1, [pc, #224]	; (405a64 <udd_ep_alloc+0x1cc>)
  405982:	4b38      	ldr	r3, [pc, #224]	; (405a64 <udd_ep_alloc+0x1cc>)
  405984:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  405986:	79fb      	ldrb	r3, [r7, #7]
  405988:	2001      	movs	r0, #1
  40598a:	fa00 f303 	lsl.w	r3, r0, r3
  40598e:	43db      	mvns	r3, r3
  405990:	4013      	ands	r3, r2
  405992:	628b      	str	r3, [r1, #40]	; 0x28
	// Set configuration of new endpoint
	udd_configure_endpoint(ep,
  405994:	4a33      	ldr	r2, [pc, #204]	; (405a64 <udd_ep_alloc+0x1cc>)
  405996:	79fb      	ldrb	r3, [r7, #7]
  405998:	330c      	adds	r3, #12
  40599a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40599e:	60fb      	str	r3, [r7, #12]
  4059a0:	68fb      	ldr	r3, [r7, #12]
  4059a2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4059a6:	60fb      	str	r3, [r7, #12]
  4059a8:	68fb      	ldr	r3, [r7, #12]
  4059aa:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
  4059ae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4059b2:	60fb      	str	r3, [r7, #12]
  4059b4:	7dfb      	ldrb	r3, [r7, #23]
  4059b6:	2b00      	cmp	r3, #0
  4059b8:	d00c      	beq.n	4059d4 <udd_ep_alloc+0x13c>
  4059ba:	79bb      	ldrb	r3, [r7, #6]
  4059bc:	f043 0304 	orr.w	r3, r3, #4
  4059c0:	b2db      	uxtb	r3, r3
  4059c2:	021b      	lsls	r3, r3, #8
  4059c4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  4059c8:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
  4059cc:	f248 7380 	movw	r3, #34688	; 0x8780
  4059d0:	4013      	ands	r3, r2
  4059d2:	e008      	b.n	4059e6 <udd_ep_alloc+0x14e>
  4059d4:	79bb      	ldrb	r3, [r7, #6]
  4059d6:	021b      	lsls	r3, r3, #8
  4059d8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  4059dc:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
  4059e0:	f248 7380 	movw	r3, #34688	; 0x8780
  4059e4:	4013      	ands	r3, r2
  4059e6:	68fa      	ldr	r2, [r7, #12]
  4059e8:	4313      	orrs	r3, r2
  4059ea:	60fb      	str	r3, [r7, #12]
  4059ec:	491d      	ldr	r1, [pc, #116]	; (405a64 <udd_ep_alloc+0x1cc>)
  4059ee:	79fb      	ldrb	r3, [r7, #7]
  4059f0:	68fa      	ldr	r2, [r7, #12]
  4059f2:	330c      	adds	r3, #12
  4059f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4059f8:	bf00      	nop
  4059fa:	4a1a      	ldr	r2, [pc, #104]	; (405a64 <udd_ep_alloc+0x1cc>)
  4059fc:	79fb      	ldrb	r3, [r7, #7]
  4059fe:	330c      	adds	r3, #12
  405a00:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  405a04:	7dfb      	ldrb	r3, [r7, #23]
  405a06:	2b00      	cmp	r3, #0
  405a08:	d009      	beq.n	405a1e <udd_ep_alloc+0x186>
  405a0a:	79bb      	ldrb	r3, [r7, #6]
  405a0c:	f043 0304 	orr.w	r3, r3, #4
  405a10:	b2db      	uxtb	r3, r3
  405a12:	021b      	lsls	r3, r3, #8
  405a14:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  405a18:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  405a1c:	e005      	b.n	405a2a <udd_ep_alloc+0x192>
  405a1e:	79bb      	ldrb	r3, [r7, #6]
  405a20:	021b      	lsls	r3, r3, #8
  405a22:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  405a26:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  405a2a:	401a      	ands	r2, r3
  405a2c:	7dfb      	ldrb	r3, [r7, #23]
  405a2e:	2b00      	cmp	r3, #0
  405a30:	d009      	beq.n	405a46 <udd_ep_alloc+0x1ae>
  405a32:	79bb      	ldrb	r3, [r7, #6]
  405a34:	f043 0304 	orr.w	r3, r3, #4
  405a38:	b2db      	uxtb	r3, r3
  405a3a:	021b      	lsls	r3, r3, #8
  405a3c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  405a40:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  405a44:	e005      	b.n	405a52 <udd_ep_alloc+0x1ba>
  405a46:	79bb      	ldrb	r3, [r7, #6]
  405a48:	021b      	lsls	r3, r3, #8
  405a4a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  405a4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  405a52:	429a      	cmp	r2, r3
  405a54:	d1d1      	bne.n	4059fa <udd_ep_alloc+0x162>
		(b_dir_in ? (bmAttributes | 0x4) : bmAttributes),
		0);
	return true;
  405a56:	2301      	movs	r3, #1
}
  405a58:	4618      	mov	r0, r3
  405a5a:	371c      	adds	r7, #28
  405a5c:	46bd      	mov	sp, r7
  405a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
  405a62:	4770      	bx	lr
  405a64:	40084000 	.word	0x40084000
  405a68:	2000883c 	.word	0x2000883c

00405a6c <udd_ep_free>:


void udd_ep_free(udd_ep_id_t ep)
{
  405a6c:	b580      	push	{r7, lr}
  405a6e:	b084      	sub	sp, #16
  405a70:	af00      	add	r7, sp, #0
  405a72:	4603      	mov	r3, r0
  405a74:	71fb      	strb	r3, [r7, #7]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  405a76:	79fb      	ldrb	r3, [r7, #7]
  405a78:	f003 030f 	and.w	r3, r3, #15
  405a7c:	73fb      	strb	r3, [r7, #15]
	if (USB_DEVICE_MAX_EP < ep_index) {
  405a7e:	7bfb      	ldrb	r3, [r7, #15]
  405a80:	2b03      	cmp	r3, #3
  405a82:	d822      	bhi.n	405aca <udd_ep_free+0x5e>
		return;
	}
	udd_disable_endpoint(ep_index);
  405a84:	4a13      	ldr	r2, [pc, #76]	; (405ad4 <udd_ep_free+0x68>)
  405a86:	7bfb      	ldrb	r3, [r7, #15]
  405a88:	330c      	adds	r3, #12
  405a8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405a8e:	60bb      	str	r3, [r7, #8]
  405a90:	68bb      	ldr	r3, [r7, #8]
  405a92:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405a96:	60bb      	str	r3, [r7, #8]
  405a98:	68bb      	ldr	r3, [r7, #8]
  405a9a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  405a9e:	60bb      	str	r3, [r7, #8]
  405aa0:	490c      	ldr	r1, [pc, #48]	; (405ad4 <udd_ep_free+0x68>)
  405aa2:	7bfb      	ldrb	r3, [r7, #15]
  405aa4:	68ba      	ldr	r2, [r7, #8]
  405aa6:	330c      	adds	r3, #12
  405aa8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405aac:	bf00      	nop
  405aae:	4a09      	ldr	r2, [pc, #36]	; (405ad4 <udd_ep_free+0x68>)
  405ab0:	7bfb      	ldrb	r3, [r7, #15]
  405ab2:	330c      	adds	r3, #12
  405ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405ab8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  405abc:	2b00      	cmp	r3, #0
  405abe:	d1f6      	bne.n	405aae <udd_ep_free+0x42>
	udd_ep_abort_job(ep);
  405ac0:	79fb      	ldrb	r3, [r7, #7]
  405ac2:	4618      	mov	r0, r3
  405ac4:	4b04      	ldr	r3, [pc, #16]	; (405ad8 <udd_ep_free+0x6c>)
  405ac6:	4798      	blx	r3
  405ac8:	e000      	b.n	405acc <udd_ep_free+0x60>
		return;
  405aca:	bf00      	nop
}
  405acc:	3710      	adds	r7, #16
  405ace:	46bd      	mov	sp, r7
  405ad0:	bd80      	pop	{r7, pc}
  405ad2:	bf00      	nop
  405ad4:	40084000 	.word	0x40084000
  405ad8:	00406a05 	.word	0x00406a05

00405adc <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
  405adc:	b480      	push	{r7}
  405ade:	b085      	sub	sp, #20
  405ae0:	af00      	add	r7, sp, #0
  405ae2:	4603      	mov	r3, r0
  405ae4:	71fb      	strb	r3, [r7, #7]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  405ae6:	79fb      	ldrb	r3, [r7, #7]
  405ae8:	f003 030f 	and.w	r3, r3, #15
  405aec:	73fb      	strb	r3, [r7, #15]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
  405aee:	7bfb      	ldrb	r3, [r7, #15]
  405af0:	1e5a      	subs	r2, r3, #1
  405af2:	4613      	mov	r3, r2
  405af4:	009b      	lsls	r3, r3, #2
  405af6:	4413      	add	r3, r2
  405af8:	009b      	lsls	r3, r3, #2
  405afa:	4a13      	ldr	r2, [pc, #76]	; (405b48 <udd_ep_is_halted+0x6c>)
  405afc:	4413      	add	r3, r2
  405afe:	60bb      	str	r3, [r7, #8]
	if (USB_DEVICE_MAX_EP < ep_index) {
  405b00:	7bfb      	ldrb	r3, [r7, #15]
  405b02:	2b03      	cmp	r3, #3
  405b04:	d901      	bls.n	405b0a <udd_ep_is_halted+0x2e>
		return false;
  405b06:	2300      	movs	r3, #0
  405b08:	e017      	b.n	405b3a <udd_ep_is_halted+0x5e>
	}
	return ptr_job->b_stall_requested ||
  405b0a:	68bb      	ldr	r3, [r7, #8]
  405b0c:	7c5b      	ldrb	r3, [r3, #17]
  405b0e:	f003 0320 	and.w	r3, r3, #32
  405b12:	b2db      	uxtb	r3, r3
  405b14:	2b00      	cmp	r3, #0
  405b16:	d10a      	bne.n	405b2e <udd_ep_is_halted+0x52>
			Is_udd_endpoint_stall_pending(ep & USB_EP_ADDR_MASK);
  405b18:	4a0c      	ldr	r2, [pc, #48]	; (405b4c <udd_ep_is_halted+0x70>)
  405b1a:	79fb      	ldrb	r3, [r7, #7]
  405b1c:	f003 030f 	and.w	r3, r3, #15
  405b20:	330c      	adds	r3, #12
  405b22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405b26:	f003 0328 	and.w	r3, r3, #40	; 0x28
	return ptr_job->b_stall_requested ||
  405b2a:	2b00      	cmp	r3, #0
  405b2c:	d001      	beq.n	405b32 <udd_ep_is_halted+0x56>
  405b2e:	2301      	movs	r3, #1
  405b30:	e000      	b.n	405b34 <udd_ep_is_halted+0x58>
  405b32:	2300      	movs	r3, #0
  405b34:	f003 0301 	and.w	r3, r3, #1
  405b38:	b2db      	uxtb	r3, r3
}
  405b3a:	4618      	mov	r0, r3
  405b3c:	3714      	adds	r7, #20
  405b3e:	46bd      	mov	sp, r7
  405b40:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b44:	4770      	bx	lr
  405b46:	bf00      	nop
  405b48:	2000883c 	.word	0x2000883c
  405b4c:	40084000 	.word	0x40084000

00405b50 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
  405b50:	b580      	push	{r7, lr}
  405b52:	b086      	sub	sp, #24
  405b54:	af00      	add	r7, sp, #0
  405b56:	4603      	mov	r3, r0
  405b58:	71fb      	strb	r3, [r7, #7]
	bool b_dir_in = ep & USB_EP_DIR_IN;
  405b5a:	79fb      	ldrb	r3, [r7, #7]
  405b5c:	f003 0380 	and.w	r3, r3, #128	; 0x80
  405b60:	2b00      	cmp	r3, #0
  405b62:	bf14      	ite	ne
  405b64:	2301      	movne	r3, #1
  405b66:	2300      	moveq	r3, #0
  405b68:	75fb      	strb	r3, [r7, #23]
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
  405b6a:	79fb      	ldrb	r3, [r7, #7]
  405b6c:	f003 030f 	and.w	r3, r3, #15
  405b70:	75bb      	strb	r3, [r7, #22]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
  405b72:	7dbb      	ldrb	r3, [r7, #22]
  405b74:	1e5a      	subs	r2, r3, #1
  405b76:	4613      	mov	r3, r2
  405b78:	009b      	lsls	r3, r3, #2
  405b7a:	4413      	add	r3, r2
  405b7c:	009b      	lsls	r3, r3, #2
  405b7e:	4a2d      	ldr	r2, [pc, #180]	; (405c34 <udd_ep_set_halt+0xe4>)
  405b80:	4413      	add	r3, r2
  405b82:	613b      	str	r3, [r7, #16]
	irqflags_t flags;
	if (USB_DEVICE_MAX_EP < ep_index) {
  405b84:	7dbb      	ldrb	r3, [r7, #22]
  405b86:	2b03      	cmp	r3, #3
  405b88:	d901      	bls.n	405b8e <udd_ep_set_halt+0x3e>
		return false;
  405b8a:	2300      	movs	r3, #0
  405b8c:	e04d      	b.n	405c2a <udd_ep_set_halt+0xda>
	}
	flags = cpu_irq_save();
  405b8e:	4b2a      	ldr	r3, [pc, #168]	; (405c38 <udd_ep_set_halt+0xe8>)
  405b90:	4798      	blx	r3
  405b92:	60f8      	str	r0, [r7, #12]
	if (b_dir_in && (Is_udd_transmit_ready(ep_index)
  405b94:	7dfb      	ldrb	r3, [r7, #23]
  405b96:	2b00      	cmp	r3, #0
  405b98:	d01f      	beq.n	405bda <udd_ep_set_halt+0x8a>
  405b9a:	4a28      	ldr	r2, [pc, #160]	; (405c3c <udd_ep_set_halt+0xec>)
  405b9c:	7dbb      	ldrb	r3, [r7, #22]
  405b9e:	330c      	adds	r3, #12
  405ba0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405ba4:	f003 0310 	and.w	r3, r3, #16
  405ba8:	2b00      	cmp	r3, #0
  405baa:	d106      	bne.n	405bba <udd_ep_set_halt+0x6a>
				|| ptr_job->bank > 1)) {
  405bac:	693b      	ldr	r3, [r7, #16]
  405bae:	7c5b      	ldrb	r3, [r3, #17]
  405bb0:	f3c3 0381 	ubfx	r3, r3, #2, #2
  405bb4:	b2db      	uxtb	r3, r3
  405bb6:	2b01      	cmp	r3, #1
  405bb8:	dd0f      	ble.n	405bda <udd_ep_set_halt+0x8a>
		// Halt until banks sent
		ptr_job->b_stall_requested = true;
  405bba:	693a      	ldr	r2, [r7, #16]
  405bbc:	7c53      	ldrb	r3, [r2, #17]
  405bbe:	f043 0320 	orr.w	r3, r3, #32
  405bc2:	7453      	strb	r3, [r2, #17]
		udd_enable_endpoint_interrupt(ep_index);
  405bc4:	4a1d      	ldr	r2, [pc, #116]	; (405c3c <udd_ep_set_halt+0xec>)
  405bc6:	7dbb      	ldrb	r3, [r7, #22]
  405bc8:	2101      	movs	r1, #1
  405bca:	fa01 f303 	lsl.w	r3, r1, r3
  405bce:	6113      	str	r3, [r2, #16]
		cpu_irq_restore(flags);
  405bd0:	68f8      	ldr	r0, [r7, #12]
  405bd2:	4b1b      	ldr	r3, [pc, #108]	; (405c40 <udd_ep_set_halt+0xf0>)
  405bd4:	4798      	blx	r3
		return true;
  405bd6:	2301      	movs	r3, #1
  405bd8:	e027      	b.n	405c2a <udd_ep_set_halt+0xda>
	} else {
		// Stall endpoint
		udd_enable_stall_handshake(ep_index);
  405bda:	4a18      	ldr	r2, [pc, #96]	; (405c3c <udd_ep_set_halt+0xec>)
  405bdc:	7dbb      	ldrb	r3, [r7, #22]
  405bde:	330c      	adds	r3, #12
  405be0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405be4:	60bb      	str	r3, [r7, #8]
  405be6:	68bb      	ldr	r3, [r7, #8]
  405be8:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405bec:	60bb      	str	r3, [r7, #8]
  405bee:	68bb      	ldr	r3, [r7, #8]
  405bf0:	f043 0320 	orr.w	r3, r3, #32
  405bf4:	60bb      	str	r3, [r7, #8]
  405bf6:	4911      	ldr	r1, [pc, #68]	; (405c3c <udd_ep_set_halt+0xec>)
  405bf8:	7dbb      	ldrb	r3, [r7, #22]
  405bfa:	68ba      	ldr	r2, [r7, #8]
  405bfc:	330c      	adds	r3, #12
  405bfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405c02:	bf00      	nop
  405c04:	4a0d      	ldr	r2, [pc, #52]	; (405c3c <udd_ep_set_halt+0xec>)
  405c06:	7dbb      	ldrb	r3, [r7, #22]
  405c08:	330c      	adds	r3, #12
  405c0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405c0e:	f003 0320 	and.w	r3, r3, #32
  405c12:	2b20      	cmp	r3, #32
  405c14:	d1f6      	bne.n	405c04 <udd_ep_set_halt+0xb4>
		udd_enable_endpoint_interrupt(ep_index);
  405c16:	4a09      	ldr	r2, [pc, #36]	; (405c3c <udd_ep_set_halt+0xec>)
  405c18:	7dbb      	ldrb	r3, [r7, #22]
  405c1a:	2101      	movs	r1, #1
  405c1c:	fa01 f303 	lsl.w	r3, r1, r3
  405c20:	6113      	str	r3, [r2, #16]
		cpu_irq_restore(flags);
  405c22:	68f8      	ldr	r0, [r7, #12]
  405c24:	4b06      	ldr	r3, [pc, #24]	; (405c40 <udd_ep_set_halt+0xf0>)
  405c26:	4798      	blx	r3
	}
	return true;
  405c28:	2301      	movs	r3, #1
}
  405c2a:	4618      	mov	r0, r3
  405c2c:	3718      	adds	r7, #24
  405c2e:	46bd      	mov	sp, r7
  405c30:	bd80      	pop	{r7, pc}
  405c32:	bf00      	nop
  405c34:	2000883c 	.word	0x2000883c
  405c38:	00405375 	.word	0x00405375
  405c3c:	40084000 	.word	0x40084000
  405c40:	004053cd 	.word	0x004053cd

00405c44 <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
  405c44:	b580      	push	{r7, lr}
  405c46:	b086      	sub	sp, #24
  405c48:	af00      	add	r7, sp, #0
  405c4a:	4603      	mov	r3, r0
  405c4c:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
  405c4e:	79fb      	ldrb	r3, [r7, #7]
  405c50:	f003 030f 	and.w	r3, r3, #15
  405c54:	71fb      	strb	r3, [r7, #7]
	if (USB_DEVICE_MAX_EP < ep)
  405c56:	79fb      	ldrb	r3, [r7, #7]
  405c58:	2b03      	cmp	r3, #3
  405c5a:	d901      	bls.n	405c60 <udd_ep_clear_halt+0x1c>
		return false;
  405c5c:	2300      	movs	r3, #0
  405c5e:	e075      	b.n	405d4c <udd_ep_clear_halt+0x108>
	ptr_job = &udd_ep_job[ep - 1];
  405c60:	79fb      	ldrb	r3, [r7, #7]
  405c62:	1e5a      	subs	r2, r3, #1
  405c64:	4613      	mov	r3, r2
  405c66:	009b      	lsls	r3, r3, #2
  405c68:	4413      	add	r3, r2
  405c6a:	009b      	lsls	r3, r3, #2
  405c6c:	4a39      	ldr	r2, [pc, #228]	; (405d54 <udd_ep_clear_halt+0x110>)
  405c6e:	4413      	add	r3, r2
  405c70:	617b      	str	r3, [r7, #20]

	ptr_job->b_stall_requested = false;
  405c72:	697a      	ldr	r2, [r7, #20]
  405c74:	7c53      	ldrb	r3, [r2, #17]
  405c76:	f36f 1345 	bfc	r3, #5, #1
  405c7a:	7453      	strb	r3, [r2, #17]
	if (Is_udd_endpoint_stall_requested(ep)) {
  405c7c:	4a36      	ldr	r2, [pc, #216]	; (405d58 <udd_ep_clear_halt+0x114>)
  405c7e:	79fb      	ldrb	r3, [r7, #7]
  405c80:	330c      	adds	r3, #12
  405c82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405c86:	f003 0320 	and.w	r3, r3, #32
  405c8a:	2b00      	cmp	r3, #0
  405c8c:	d05d      	beq.n	405d4a <udd_ep_clear_halt+0x106>
		// Remove stall
		udd_disable_stall_handshake(ep);
  405c8e:	4a32      	ldr	r2, [pc, #200]	; (405d58 <udd_ep_clear_halt+0x114>)
  405c90:	79fb      	ldrb	r3, [r7, #7]
  405c92:	330c      	adds	r3, #12
  405c94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405c98:	613b      	str	r3, [r7, #16]
  405c9a:	693b      	ldr	r3, [r7, #16]
  405c9c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405ca0:	613b      	str	r3, [r7, #16]
  405ca2:	693b      	ldr	r3, [r7, #16]
  405ca4:	f023 0320 	bic.w	r3, r3, #32
  405ca8:	613b      	str	r3, [r7, #16]
  405caa:	492b      	ldr	r1, [pc, #172]	; (405d58 <udd_ep_clear_halt+0x114>)
  405cac:	79fb      	ldrb	r3, [r7, #7]
  405cae:	693a      	ldr	r2, [r7, #16]
  405cb0:	330c      	adds	r3, #12
  405cb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405cb6:	bf00      	nop
  405cb8:	4a27      	ldr	r2, [pc, #156]	; (405d58 <udd_ep_clear_halt+0x114>)
  405cba:	79fb      	ldrb	r3, [r7, #7]
  405cbc:	330c      	adds	r3, #12
  405cbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405cc2:	f003 0320 	and.w	r3, r3, #32
  405cc6:	2b00      	cmp	r3, #0
  405cc8:	d1f6      	bne.n	405cb8 <udd_ep_clear_halt+0x74>
		// Reset FIFO and data toggle (after stall cleared)
		udd_reset_endpoint(ep);
  405cca:	4923      	ldr	r1, [pc, #140]	; (405d58 <udd_ep_clear_halt+0x114>)
  405ccc:	4b22      	ldr	r3, [pc, #136]	; (405d58 <udd_ep_clear_halt+0x114>)
  405cce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  405cd0:	79fb      	ldrb	r3, [r7, #7]
  405cd2:	2001      	movs	r0, #1
  405cd4:	fa00 f303 	lsl.w	r3, r0, r3
  405cd8:	4313      	orrs	r3, r2
  405cda:	628b      	str	r3, [r1, #40]	; 0x28
  405cdc:	491e      	ldr	r1, [pc, #120]	; (405d58 <udd_ep_clear_halt+0x114>)
  405cde:	4b1e      	ldr	r3, [pc, #120]	; (405d58 <udd_ep_clear_halt+0x114>)
  405ce0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  405ce2:	79fb      	ldrb	r3, [r7, #7]
  405ce4:	2001      	movs	r0, #1
  405ce6:	fa00 f303 	lsl.w	r3, r0, r3
  405cea:	43db      	mvns	r3, r3
  405cec:	4013      	ands	r3, r2
  405cee:	628b      	str	r3, [r1, #40]	; 0x28
		// Clear stall status
		udd_ack_stall(ep);
  405cf0:	4a19      	ldr	r2, [pc, #100]	; (405d58 <udd_ep_clear_halt+0x114>)
  405cf2:	79fb      	ldrb	r3, [r7, #7]
  405cf4:	330c      	adds	r3, #12
  405cf6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405cfa:	60fb      	str	r3, [r7, #12]
  405cfc:	68fb      	ldr	r3, [r7, #12]
  405cfe:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405d02:	60fb      	str	r3, [r7, #12]
  405d04:	68fb      	ldr	r3, [r7, #12]
  405d06:	f023 0308 	bic.w	r3, r3, #8
  405d0a:	60fb      	str	r3, [r7, #12]
  405d0c:	4912      	ldr	r1, [pc, #72]	; (405d58 <udd_ep_clear_halt+0x114>)
  405d0e:	79fb      	ldrb	r3, [r7, #7]
  405d10:	68fa      	ldr	r2, [r7, #12]
  405d12:	330c      	adds	r3, #12
  405d14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405d18:	bf00      	nop
  405d1a:	4a0f      	ldr	r2, [pc, #60]	; (405d58 <udd_ep_clear_halt+0x114>)
  405d1c:	79fb      	ldrb	r3, [r7, #7]
  405d1e:	330c      	adds	r3, #12
  405d20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405d24:	f003 0308 	and.w	r3, r3, #8
  405d28:	2b00      	cmp	r3, #0
  405d2a:	d1f6      	bne.n	405d1a <udd_ep_clear_halt+0xd6>
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
  405d2c:	697b      	ldr	r3, [r7, #20]
  405d2e:	7c5b      	ldrb	r3, [r3, #17]
  405d30:	f003 0310 	and.w	r3, r3, #16
  405d34:	b2db      	uxtb	r3, r3
  405d36:	2b00      	cmp	r3, #0
  405d38:	d007      	beq.n	405d4a <udd_ep_clear_halt+0x106>
			ptr_job->busy = false;
  405d3a:	697a      	ldr	r2, [r7, #20]
  405d3c:	7c53      	ldrb	r3, [r2, #17]
  405d3e:	f36f 1304 	bfc	r3, #4, #1
  405d42:	7453      	strb	r3, [r2, #17]
			ptr_job->call_nohalt();
  405d44:	697b      	ldr	r3, [r7, #20]
  405d46:	681b      	ldr	r3, [r3, #0]
  405d48:	4798      	blx	r3
		}
	}
	return true;
  405d4a:	2301      	movs	r3, #1
}
  405d4c:	4618      	mov	r0, r3
  405d4e:	3718      	adds	r7, #24
  405d50:	46bd      	mov	sp, r7
  405d52:	bd80      	pop	{r7, pc}
  405d54:	2000883c 	.word	0x2000883c
  405d58:	40084000 	.word	0x40084000

00405d5c <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
  405d5c:	b580      	push	{r7, lr}
  405d5e:	b088      	sub	sp, #32
  405d60:	af00      	add	r7, sp, #0
  405d62:	60ba      	str	r2, [r7, #8]
  405d64:	607b      	str	r3, [r7, #4]
  405d66:	4603      	mov	r3, r0
  405d68:	73fb      	strb	r3, [r7, #15]
  405d6a:	460b      	mov	r3, r1
  405d6c:	73bb      	strb	r3, [r7, #14]
	udd_ep_job_t *ptr_job;
	irqflags_t flags;
	bool b_dir_in = ep & USB_EP_DIR_IN;
  405d6e:	7bfb      	ldrb	r3, [r7, #15]
  405d70:	f003 0380 	and.w	r3, r3, #128	; 0x80
  405d74:	2b00      	cmp	r3, #0
  405d76:	bf14      	ite	ne
  405d78:	2301      	movne	r3, #1
  405d7a:	2300      	moveq	r3, #0
  405d7c:	77fb      	strb	r3, [r7, #31]

	ep &= USB_EP_ADDR_MASK;
  405d7e:	7bfb      	ldrb	r3, [r7, #15]
  405d80:	f003 030f 	and.w	r3, r3, #15
  405d84:	73fb      	strb	r3, [r7, #15]
	if (USB_DEVICE_MAX_EP < ep) {
  405d86:	7bfb      	ldrb	r3, [r7, #15]
  405d88:	2b03      	cmp	r3, #3
  405d8a:	d901      	bls.n	405d90 <udd_ep_run+0x34>
		return false;
  405d8c:	2300      	movs	r3, #0
  405d8e:	e083      	b.n	405e98 <udd_ep_run+0x13c>
	}
	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
  405d90:	7bfb      	ldrb	r3, [r7, #15]
  405d92:	1e5a      	subs	r2, r3, #1
  405d94:	4613      	mov	r3, r2
  405d96:	009b      	lsls	r3, r3, #2
  405d98:	4413      	add	r3, r2
  405d9a:	009b      	lsls	r3, r3, #2
  405d9c:	4a40      	ldr	r2, [pc, #256]	; (405ea0 <udd_ep_run+0x144>)
  405d9e:	4413      	add	r3, r2
  405da0:	61bb      	str	r3, [r7, #24]

	if ((!Is_udd_endpoint_enabled(ep))
  405da2:	4a40      	ldr	r2, [pc, #256]	; (405ea4 <udd_ep_run+0x148>)
  405da4:	7bfb      	ldrb	r3, [r7, #15]
  405da6:	330c      	adds	r3, #12
  405da8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405dac:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  405db0:	2b00      	cmp	r3, #0
  405db2:	d00f      	beq.n	405dd4 <udd_ep_run+0x78>
			|| ptr_job->b_stall_requested
  405db4:	69bb      	ldr	r3, [r7, #24]
  405db6:	7c5b      	ldrb	r3, [r3, #17]
  405db8:	f003 0320 	and.w	r3, r3, #32
  405dbc:	b2db      	uxtb	r3, r3
  405dbe:	2b00      	cmp	r3, #0
  405dc0:	d108      	bne.n	405dd4 <udd_ep_run+0x78>
			|| Is_udd_endpoint_stall_requested(ep)) {
  405dc2:	4a38      	ldr	r2, [pc, #224]	; (405ea4 <udd_ep_run+0x148>)
  405dc4:	7bfb      	ldrb	r3, [r7, #15]
  405dc6:	330c      	adds	r3, #12
  405dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405dcc:	f003 0320 	and.w	r3, r3, #32
  405dd0:	2b00      	cmp	r3, #0
  405dd2:	d001      	beq.n	405dd8 <udd_ep_run+0x7c>
		return false; // Endpoint is halted
  405dd4:	2300      	movs	r3, #0
  405dd6:	e05f      	b.n	405e98 <udd_ep_run+0x13c>
	}

	flags = cpu_irq_save();
  405dd8:	4b33      	ldr	r3, [pc, #204]	; (405ea8 <udd_ep_run+0x14c>)
  405dda:	4798      	blx	r3
  405ddc:	6178      	str	r0, [r7, #20]
	if (ptr_job->busy == true) {
  405dde:	69bb      	ldr	r3, [r7, #24]
  405de0:	7c5b      	ldrb	r3, [r3, #17]
  405de2:	f003 0310 	and.w	r3, r3, #16
  405de6:	b2db      	uxtb	r3, r3
  405de8:	2b00      	cmp	r3, #0
  405dea:	d004      	beq.n	405df6 <udd_ep_run+0x9a>
		cpu_irq_restore(flags);
  405dec:	6978      	ldr	r0, [r7, #20]
  405dee:	4b2f      	ldr	r3, [pc, #188]	; (405eac <udd_ep_run+0x150>)
  405df0:	4798      	blx	r3
		return false; // Job already on going
  405df2:	2300      	movs	r3, #0
  405df4:	e050      	b.n	405e98 <udd_ep_run+0x13c>
	}
	ptr_job->busy = true;
  405df6:	69ba      	ldr	r2, [r7, #24]
  405df8:	7c53      	ldrb	r3, [r2, #17]
  405dfa:	f043 0310 	orr.w	r3, r3, #16
  405dfe:	7453      	strb	r3, [r2, #17]
	cpu_irq_restore(flags);
  405e00:	6978      	ldr	r0, [r7, #20]
  405e02:	4b2a      	ldr	r3, [pc, #168]	; (405eac <udd_ep_run+0x150>)
  405e04:	4798      	blx	r3

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
  405e06:	69bb      	ldr	r3, [r7, #24]
  405e08:	68ba      	ldr	r2, [r7, #8]
  405e0a:	605a      	str	r2, [r3, #4]
	ptr_job->buf_size = buf_size;
  405e0c:	69bb      	ldr	r3, [r7, #24]
  405e0e:	687a      	ldr	r2, [r7, #4]
  405e10:	609a      	str	r2, [r3, #8]
	ptr_job->buf_cnt = 0;
  405e12:	69bb      	ldr	r3, [r7, #24]
  405e14:	2200      	movs	r2, #0
  405e16:	60da      	str	r2, [r3, #12]
	ptr_job->call_trans = callback;
  405e18:	69bb      	ldr	r3, [r7, #24]
  405e1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  405e1c:	601a      	str	r2, [r3, #0]
	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
  405e1e:	7bbb      	ldrb	r3, [r7, #14]
  405e20:	2b00      	cmp	r3, #0
  405e22:	d102      	bne.n	405e2a <udd_ep_run+0xce>
  405e24:	687b      	ldr	r3, [r7, #4]
  405e26:	2b00      	cmp	r3, #0
  405e28:	d101      	bne.n	405e2e <udd_ep_run+0xd2>
  405e2a:	2301      	movs	r3, #1
  405e2c:	e000      	b.n	405e30 <udd_ep_run+0xd4>
  405e2e:	2300      	movs	r3, #0
  405e30:	b2db      	uxtb	r3, r3
  405e32:	f003 0301 	and.w	r3, r3, #1
  405e36:	b2d9      	uxtb	r1, r3
  405e38:	69ba      	ldr	r2, [r7, #24]
  405e3a:	7c53      	ldrb	r3, [r2, #17]
  405e3c:	f361 1386 	bfi	r3, r1, #6, #1
  405e40:	7453      	strb	r3, [r2, #17]
	ptr_job->b_buf_end = false;
  405e42:	69ba      	ldr	r2, [r7, #24]
  405e44:	7c53      	ldrb	r3, [r2, #17]
  405e46:	f36f 13c7 	bfc	r3, #7, #1
  405e4a:	7453      	strb	r3, [r2, #17]

	flags = cpu_irq_save();
  405e4c:	4b16      	ldr	r3, [pc, #88]	; (405ea8 <udd_ep_run+0x14c>)
  405e4e:	4798      	blx	r3
  405e50:	6178      	str	r0, [r7, #20]
	udd_enable_endpoint_interrupt(ep);
  405e52:	4a14      	ldr	r2, [pc, #80]	; (405ea4 <udd_ep_run+0x148>)
  405e54:	7bfb      	ldrb	r3, [r7, #15]
  405e56:	2101      	movs	r1, #1
  405e58:	fa01 f303 	lsl.w	r3, r1, r3
  405e5c:	6113      	str	r3, [r2, #16]
	// Request first transfer
	if (b_dir_in) {
  405e5e:	7ffb      	ldrb	r3, [r7, #31]
  405e60:	2b00      	cmp	r3, #0
  405e62:	d015      	beq.n	405e90 <udd_ep_run+0x134>
		if (Is_udd_in_pending(ep)) {
  405e64:	4a0f      	ldr	r2, [pc, #60]	; (405ea4 <udd_ep_run+0x148>)
  405e66:	7bfb      	ldrb	r3, [r7, #15]
  405e68:	330c      	adds	r3, #12
  405e6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405e6e:	f003 0311 	and.w	r3, r3, #17
  405e72:	2b00      	cmp	r3, #0
  405e74:	d10c      	bne.n	405e90 <udd_ep_run+0x134>
			// Append more data (handled in interrupt service)
		} else {
			// Start new, try to fill 1~2 banks before handling status
			if (udd_ep_in_sent(ep, true)) {
  405e76:	7bfb      	ldrb	r3, [r7, #15]
  405e78:	2101      	movs	r1, #1
  405e7a:	4618      	mov	r0, r3
  405e7c:	4b0c      	ldr	r3, [pc, #48]	; (405eb0 <udd_ep_run+0x154>)
  405e7e:	4798      	blx	r3
  405e80:	4603      	mov	r3, r0
  405e82:	2b00      	cmp	r3, #0
  405e84:	d004      	beq.n	405e90 <udd_ep_run+0x134>
				// Over one bank
				udd_ep_in_sent(ep, false);
  405e86:	7bfb      	ldrb	r3, [r7, #15]
  405e88:	2100      	movs	r1, #0
  405e8a:	4618      	mov	r0, r3
  405e8c:	4b08      	ldr	r3, [pc, #32]	; (405eb0 <udd_ep_run+0x154>)
  405e8e:	4798      	blx	r3
			}
		}
	} else {
		// Waiting for OUT received interrupt
	}
	cpu_irq_restore(flags);
  405e90:	6978      	ldr	r0, [r7, #20]
  405e92:	4b06      	ldr	r3, [pc, #24]	; (405eac <udd_ep_run+0x150>)
  405e94:	4798      	blx	r3

	return true;
  405e96:	2301      	movs	r3, #1
}
  405e98:	4618      	mov	r0, r3
  405e9a:	3720      	adds	r7, #32
  405e9c:	46bd      	mov	sp, r7
  405e9e:	bd80      	pop	{r7, pc}
  405ea0:	2000883c 	.word	0x2000883c
  405ea4:	40084000 	.word	0x40084000
  405ea8:	00405375 	.word	0x00405375
  405eac:	004053cd 	.word	0x004053cd
  405eb0:	00406d5d 	.word	0x00406d5d

00405eb4 <udd_ep_abort>:


void udd_ep_abort(udd_ep_id_t ep)
{
  405eb4:	b580      	push	{r7, lr}
  405eb6:	b088      	sub	sp, #32
  405eb8:	af00      	add	r7, sp, #0
  405eba:	4603      	mov	r3, r0
  405ebc:	71fb      	strb	r3, [r7, #7]
	bool b_dir_in = ep & USB_EP_DIR_IN;
  405ebe:	79fb      	ldrb	r3, [r7, #7]
  405ec0:	f003 0380 	and.w	r3, r3, #128	; 0x80
  405ec4:	2b00      	cmp	r3, #0
  405ec6:	bf14      	ite	ne
  405ec8:	2301      	movne	r3, #1
  405eca:	2300      	moveq	r3, #0
  405ecc:	77fb      	strb	r3, [r7, #31]
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
  405ece:	79fb      	ldrb	r3, [r7, #7]
  405ed0:	f003 030f 	and.w	r3, r3, #15
  405ed4:	71fb      	strb	r3, [r7, #7]
	if (USB_DEVICE_MAX_EP < ep)
  405ed6:	79fb      	ldrb	r3, [r7, #7]
  405ed8:	2b03      	cmp	r3, #3
  405eda:	f200 80df 	bhi.w	40609c <udd_ep_abort+0x1e8>
		return;

	// Disable interrupts
	flags = cpu_irq_save();
  405ede:	4b71      	ldr	r3, [pc, #452]	; (4060a4 <udd_ep_abort+0x1f0>)
  405ee0:	4798      	blx	r3
  405ee2:	61b8      	str	r0, [r7, #24]
	udd_disable_endpoint_interrupt(ep);
  405ee4:	4a70      	ldr	r2, [pc, #448]	; (4060a8 <udd_ep_abort+0x1f4>)
  405ee6:	79fb      	ldrb	r3, [r7, #7]
  405ee8:	2101      	movs	r1, #1
  405eea:	fa01 f303 	lsl.w	r3, r1, r3
  405eee:	6153      	str	r3, [r2, #20]
	cpu_irq_restore(flags);
  405ef0:	69b8      	ldr	r0, [r7, #24]
  405ef2:	4b6e      	ldr	r3, [pc, #440]	; (4060ac <udd_ep_abort+0x1f8>)
  405ef4:	4798      	blx	r3
	// Clear pending statuses
	if (b_dir_in) {
  405ef6:	7ffb      	ldrb	r3, [r7, #31]
  405ef8:	2b00      	cmp	r3, #0
  405efa:	f000 80ae 	beq.w	40605a <udd_ep_abort+0x1a6>
		// Kill banks
		if (Is_udd_transmit_ready(ep)) {
  405efe:	4a6a      	ldr	r2, [pc, #424]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f00:	79fb      	ldrb	r3, [r7, #7]
  405f02:	330c      	adds	r3, #12
  405f04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f08:	f003 0310 	and.w	r3, r3, #16
  405f0c:	2b00      	cmp	r3, #0
  405f0e:	d073      	beq.n	405ff8 <udd_ep_abort+0x144>
			udd_kill_data_in_fifo(ep,
  405f10:	79fb      	ldrb	r3, [r7, #7]
  405f12:	2b00      	cmp	r3, #0
  405f14:	d052      	beq.n	405fbc <udd_ep_abort+0x108>
  405f16:	79fb      	ldrb	r3, [r7, #7]
  405f18:	2b03      	cmp	r3, #3
  405f1a:	d04f      	beq.n	405fbc <udd_ep_abort+0x108>
  405f1c:	4a62      	ldr	r2, [pc, #392]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f1e:	79fb      	ldrb	r3, [r7, #7]
  405f20:	330c      	adds	r3, #12
  405f22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f26:	617b      	str	r3, [r7, #20]
  405f28:	697b      	ldr	r3, [r7, #20]
  405f2a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405f2e:	617b      	str	r3, [r7, #20]
  405f30:	697b      	ldr	r3, [r7, #20]
  405f32:	f023 0310 	bic.w	r3, r3, #16
  405f36:	617b      	str	r3, [r7, #20]
  405f38:	495b      	ldr	r1, [pc, #364]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f3a:	79fb      	ldrb	r3, [r7, #7]
  405f3c:	697a      	ldr	r2, [r7, #20]
  405f3e:	330c      	adds	r3, #12
  405f40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405f44:	bf00      	nop
  405f46:	4a58      	ldr	r2, [pc, #352]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f48:	79fb      	ldrb	r3, [r7, #7]
  405f4a:	330c      	adds	r3, #12
  405f4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f50:	f003 0310 	and.w	r3, r3, #16
  405f54:	2b00      	cmp	r3, #0
  405f56:	d1f6      	bne.n	405f46 <udd_ep_abort+0x92>
  405f58:	bf00      	nop
  405f5a:	4a53      	ldr	r2, [pc, #332]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f5c:	79fb      	ldrb	r3, [r7, #7]
  405f5e:	330c      	adds	r3, #12
  405f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f64:	f003 0310 	and.w	r3, r3, #16
  405f68:	2b00      	cmp	r3, #0
  405f6a:	d1f6      	bne.n	405f5a <udd_ep_abort+0xa6>
  405f6c:	4a4e      	ldr	r2, [pc, #312]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f6e:	79fb      	ldrb	r3, [r7, #7]
  405f70:	330c      	adds	r3, #12
  405f72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405f76:	613b      	str	r3, [r7, #16]
  405f78:	693b      	ldr	r3, [r7, #16]
  405f7a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405f7e:	613b      	str	r3, [r7, #16]
  405f80:	693b      	ldr	r3, [r7, #16]
  405f82:	f043 0310 	orr.w	r3, r3, #16
  405f86:	613b      	str	r3, [r7, #16]
  405f88:	4947      	ldr	r1, [pc, #284]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f8a:	79fb      	ldrb	r3, [r7, #7]
  405f8c:	693a      	ldr	r2, [r7, #16]
  405f8e:	330c      	adds	r3, #12
  405f90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405f94:	bf00      	nop
  405f96:	4a44      	ldr	r2, [pc, #272]	; (4060a8 <udd_ep_abort+0x1f4>)
  405f98:	79fb      	ldrb	r3, [r7, #7]
  405f9a:	330c      	adds	r3, #12
  405f9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405fa0:	f003 0310 	and.w	r3, r3, #16
  405fa4:	2b10      	cmp	r3, #16
  405fa6:	d1f6      	bne.n	405f96 <udd_ep_abort+0xe2>
  405fa8:	bf00      	nop
  405faa:	4a3f      	ldr	r2, [pc, #252]	; (4060a8 <udd_ep_abort+0x1f4>)
  405fac:	79fb      	ldrb	r3, [r7, #7]
  405fae:	330c      	adds	r3, #12
  405fb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405fb4:	f003 0310 	and.w	r3, r3, #16
  405fb8:	2b00      	cmp	r3, #0
  405fba:	d0f6      	beq.n	405faa <udd_ep_abort+0xf6>
  405fbc:	4a3a      	ldr	r2, [pc, #232]	; (4060a8 <udd_ep_abort+0x1f4>)
  405fbe:	79fb      	ldrb	r3, [r7, #7]
  405fc0:	330c      	adds	r3, #12
  405fc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405fc6:	60fb      	str	r3, [r7, #12]
  405fc8:	68fb      	ldr	r3, [r7, #12]
  405fca:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  405fce:	60fb      	str	r3, [r7, #12]
  405fd0:	68fb      	ldr	r3, [r7, #12]
  405fd2:	f023 0310 	bic.w	r3, r3, #16
  405fd6:	60fb      	str	r3, [r7, #12]
  405fd8:	4933      	ldr	r1, [pc, #204]	; (4060a8 <udd_ep_abort+0x1f4>)
  405fda:	79fb      	ldrb	r3, [r7, #7]
  405fdc:	68fa      	ldr	r2, [r7, #12]
  405fde:	330c      	adds	r3, #12
  405fe0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  405fe4:	bf00      	nop
  405fe6:	4a30      	ldr	r2, [pc, #192]	; (4060a8 <udd_ep_abort+0x1f4>)
  405fe8:	79fb      	ldrb	r3, [r7, #7]
  405fea:	330c      	adds	r3, #12
  405fec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  405ff0:	f003 0310 	and.w	r3, r3, #16
  405ff4:	2b00      	cmp	r3, #0
  405ff6:	d1f6      	bne.n	405fe6 <udd_ep_abort+0x132>
					udd_get_endpoint_bank_max_nbr(ep)>1);
		}
		udd_ack_in_sent(ep);
  405ff8:	4a2b      	ldr	r2, [pc, #172]	; (4060a8 <udd_ep_abort+0x1f4>)
  405ffa:	79fb      	ldrb	r3, [r7, #7]
  405ffc:	330c      	adds	r3, #12
  405ffe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406002:	60bb      	str	r3, [r7, #8]
  406004:	68bb      	ldr	r3, [r7, #8]
  406006:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40600a:	60bb      	str	r3, [r7, #8]
  40600c:	68bb      	ldr	r3, [r7, #8]
  40600e:	f023 0301 	bic.w	r3, r3, #1
  406012:	60bb      	str	r3, [r7, #8]
  406014:	4924      	ldr	r1, [pc, #144]	; (4060a8 <udd_ep_abort+0x1f4>)
  406016:	79fb      	ldrb	r3, [r7, #7]
  406018:	68ba      	ldr	r2, [r7, #8]
  40601a:	330c      	adds	r3, #12
  40601c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406020:	bf00      	nop
  406022:	4a21      	ldr	r2, [pc, #132]	; (4060a8 <udd_ep_abort+0x1f4>)
  406024:	79fb      	ldrb	r3, [r7, #7]
  406026:	330c      	adds	r3, #12
  406028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40602c:	f003 0301 	and.w	r3, r3, #1
  406030:	2b00      	cmp	r3, #0
  406032:	d1f6      	bne.n	406022 <udd_ep_abort+0x16e>
		// Reset number of buffered banks
		udd_ep_job[ep - 1].bank = 0;
  406034:	79fb      	ldrb	r3, [r7, #7]
  406036:	1e5a      	subs	r2, r3, #1
  406038:	491d      	ldr	r1, [pc, #116]	; (4060b0 <udd_ep_abort+0x1fc>)
  40603a:	4613      	mov	r3, r2
  40603c:	009b      	lsls	r3, r3, #2
  40603e:	4413      	add	r3, r2
  406040:	009b      	lsls	r3, r3, #2
  406042:	440b      	add	r3, r1
  406044:	f103 0210 	add.w	r2, r3, #16
  406048:	7853      	ldrb	r3, [r2, #1]
  40604a:	f36f 0383 	bfc	r3, #2, #2
  40604e:	7053      	strb	r3, [r2, #1]
  406050:	e00c      	b.n	40606c <udd_ep_abort+0x1b8>
	} else {
		// Clear all pending banks statuses
		while(Is_udd_any_bank_received(ep)) {
			udd_ep_ack_out_received(ep);
  406052:	79fb      	ldrb	r3, [r7, #7]
  406054:	4618      	mov	r0, r3
  406056:	4b17      	ldr	r3, [pc, #92]	; (4060b4 <udd_ep_abort+0x200>)
  406058:	4798      	blx	r3
		while(Is_udd_any_bank_received(ep)) {
  40605a:	4a13      	ldr	r2, [pc, #76]	; (4060a8 <udd_ep_abort+0x1f4>)
  40605c:	79fb      	ldrb	r3, [r7, #7]
  40605e:	330c      	adds	r3, #12
  406060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406064:	f003 0342 	and.w	r3, r3, #66	; 0x42
  406068:	2b00      	cmp	r3, #0
  40606a:	d1f2      	bne.n	406052 <udd_ep_abort+0x19e>
		}
	}
	// Reset FIFO and data toggle
	udd_reset_endpoint(ep);
  40606c:	490e      	ldr	r1, [pc, #56]	; (4060a8 <udd_ep_abort+0x1f4>)
  40606e:	4b0e      	ldr	r3, [pc, #56]	; (4060a8 <udd_ep_abort+0x1f4>)
  406070:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  406072:	79fb      	ldrb	r3, [r7, #7]
  406074:	2001      	movs	r0, #1
  406076:	fa00 f303 	lsl.w	r3, r0, r3
  40607a:	4313      	orrs	r3, r2
  40607c:	628b      	str	r3, [r1, #40]	; 0x28
  40607e:	490a      	ldr	r1, [pc, #40]	; (4060a8 <udd_ep_abort+0x1f4>)
  406080:	4b09      	ldr	r3, [pc, #36]	; (4060a8 <udd_ep_abort+0x1f4>)
  406082:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  406084:	79fb      	ldrb	r3, [r7, #7]
  406086:	2001      	movs	r0, #1
  406088:	fa00 f303 	lsl.w	r3, r0, r3
  40608c:	43db      	mvns	r3, r3
  40608e:	4013      	ands	r3, r2
  406090:	628b      	str	r3, [r1, #40]	; 0x28
	// Abort job
	udd_ep_abort_job(ep);
  406092:	79fb      	ldrb	r3, [r7, #7]
  406094:	4618      	mov	r0, r3
  406096:	4b08      	ldr	r3, [pc, #32]	; (4060b8 <udd_ep_abort+0x204>)
  406098:	4798      	blx	r3
  40609a:	e000      	b.n	40609e <udd_ep_abort+0x1ea>
		return;
  40609c:	bf00      	nop
}
  40609e:	3720      	adds	r7, #32
  4060a0:	46bd      	mov	sp, r7
  4060a2:	bd80      	pop	{r7, pc}
  4060a4:	00405375 	.word	0x00405375
  4060a8:	40084000 	.word	0x40084000
  4060ac:	004053cd 	.word	0x004053cd
  4060b0:	2000883c 	.word	0x2000883c
  4060b4:	00406ab5 	.word	0x00406ab5
  4060b8:	00406a05 	.word	0x00406a05

004060bc <udd_reset_ep_ctrl>:

//--------------------------------------------------------
//--- INTERNAL ROUTINES TO MANAGED THE CONTROL ENDPOINT

static void udd_reset_ep_ctrl(void)
{
  4060bc:	b580      	push	{r7, lr}
  4060be:	b084      	sub	sp, #16
  4060c0:	af00      	add	r7, sp, #0
	irqflags_t flags;

	// Reset USB address to 0
	udd_enable_address();
  4060c2:	4a25      	ldr	r2, [pc, #148]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060c4:	4b24      	ldr	r3, [pc, #144]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060c6:	689b      	ldr	r3, [r3, #8]
  4060c8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4060cc:	6093      	str	r3, [r2, #8]
	udd_configure_address(0);
  4060ce:	4a22      	ldr	r2, [pc, #136]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060d0:	4b21      	ldr	r3, [pc, #132]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060d2:	689b      	ldr	r3, [r3, #8]
  4060d4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  4060d8:	6093      	str	r3, [r2, #8]
	// Alloc and configure control endpoint in OUT direction
	udd_configure_endpoint(0, USB_EP_TYPE_CONTROL, 0);
  4060da:	4b1f      	ldr	r3, [pc, #124]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4060de:	60bb      	str	r3, [r7, #8]
  4060e0:	68bb      	ldr	r3, [r7, #8]
  4060e2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4060e6:	60bb      	str	r3, [r7, #8]
  4060e8:	68bb      	ldr	r3, [r7, #8]
  4060ea:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
  4060ee:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4060f2:	60bb      	str	r3, [r7, #8]
  4060f4:	68bb      	ldr	r3, [r7, #8]
  4060f6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4060fa:	60bb      	str	r3, [r7, #8]
  4060fc:	4a16      	ldr	r2, [pc, #88]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  4060fe:	68bb      	ldr	r3, [r7, #8]
  406100:	6313      	str	r3, [r2, #48]	; 0x30
  406102:	bf00      	nop
  406104:	4b14      	ldr	r3, [pc, #80]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  406106:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406108:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  40610c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  406110:	d1f8      	bne.n	406104 <udd_reset_ep_ctrl+0x48>
	udd_enable_endpoint(0);
  406112:	4b11      	ldr	r3, [pc, #68]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  406114:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406116:	607b      	str	r3, [r7, #4]
  406118:	687b      	ldr	r3, [r7, #4]
  40611a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40611e:	607b      	str	r3, [r7, #4]
  406120:	687b      	ldr	r3, [r7, #4]
  406122:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  406126:	607b      	str	r3, [r7, #4]
  406128:	4a0b      	ldr	r2, [pc, #44]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  40612a:	687b      	ldr	r3, [r7, #4]
  40612c:	6313      	str	r3, [r2, #48]	; 0x30
  40612e:	bf00      	nop
  406130:	4b09      	ldr	r3, [pc, #36]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  406132:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406134:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  406138:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  40613c:	d1f8      	bne.n	406130 <udd_reset_ep_ctrl+0x74>

	flags = cpu_irq_save();
  40613e:	4b07      	ldr	r3, [pc, #28]	; (40615c <udd_reset_ep_ctrl+0xa0>)
  406140:	4798      	blx	r3
  406142:	60f8      	str	r0, [r7, #12]
	udd_enable_endpoint_interrupt(0);
  406144:	4b04      	ldr	r3, [pc, #16]	; (406158 <udd_reset_ep_ctrl+0x9c>)
  406146:	2201      	movs	r2, #1
  406148:	611a      	str	r2, [r3, #16]
	cpu_irq_restore(flags);
  40614a:	68f8      	ldr	r0, [r7, #12]
  40614c:	4b04      	ldr	r3, [pc, #16]	; (406160 <udd_reset_ep_ctrl+0xa4>)
  40614e:	4798      	blx	r3
}
  406150:	bf00      	nop
  406152:	3710      	adds	r7, #16
  406154:	46bd      	mov	sp, r7
  406156:	bd80      	pop	{r7, pc}
  406158:	40084000 	.word	0x40084000
  40615c:	00405375 	.word	0x00405375
  406160:	004053cd 	.word	0x004053cd

00406164 <udd_ctrl_init>:

static void udd_ctrl_init(void)
{
  406164:	b480      	push	{r7}
  406166:	af00      	add	r7, sp, #0
	udd_g_ctrlreq.callback = NULL;
  406168:	4b08      	ldr	r3, [pc, #32]	; (40618c <udd_ctrl_init+0x28>)
  40616a:	2200      	movs	r2, #0
  40616c:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
  40616e:	4b07      	ldr	r3, [pc, #28]	; (40618c <udd_ctrl_init+0x28>)
  406170:	2200      	movs	r2, #0
  406172:	615a      	str	r2, [r3, #20]
	udd_g_ctrlreq.payload_size = 0;
  406174:	4b05      	ldr	r3, [pc, #20]	; (40618c <udd_ctrl_init+0x28>)
  406176:	2200      	movs	r2, #0
  406178:	819a      	strh	r2, [r3, #12]
	udd_ep_control_state = UDD_EPCTRL_SETUP;
  40617a:	4b05      	ldr	r3, [pc, #20]	; (406190 <udd_ctrl_init+0x2c>)
  40617c:	2200      	movs	r2, #0
  40617e:	701a      	strb	r2, [r3, #0]
}
  406180:	bf00      	nop
  406182:	46bd      	mov	sp, r7
  406184:	f85d 7b04 	ldr.w	r7, [sp], #4
  406188:	4770      	bx	lr
  40618a:	bf00      	nop
  40618c:	2000896c 	.word	0x2000896c
  406190:	20008835 	.word	0x20008835

00406194 <udd_ctrl_setup_received>:


static void udd_ctrl_setup_received(void)
{
  406194:	b580      	push	{r7, lr}
  406196:	b086      	sub	sp, #24
  406198:	af00      	add	r7, sp, #0
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
  40619a:	4b63      	ldr	r3, [pc, #396]	; (406328 <udd_ctrl_setup_received+0x194>)
  40619c:	781b      	ldrb	r3, [r3, #0]
  40619e:	2b00      	cmp	r3, #0
  4061a0:	d003      	beq.n	4061aa <udd_ctrl_setup_received+0x16>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
  4061a2:	4b62      	ldr	r3, [pc, #392]	; (40632c <udd_ctrl_setup_received+0x198>)
  4061a4:	4798      	blx	r3

		// Reinitializes control endpoint management
		udd_ctrl_init();
  4061a6:	4b62      	ldr	r3, [pc, #392]	; (406330 <udd_ctrl_setup_received+0x19c>)
  4061a8:	4798      	blx	r3
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
  4061aa:	4b62      	ldr	r3, [pc, #392]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4061ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4061ae:	0c1b      	lsrs	r3, r3, #16
  4061b0:	f3c3 030a 	ubfx	r3, r3, #0, #11
  4061b4:	2b08      	cmp	r3, #8
  4061b6:	d017      	beq.n	4061e8 <udd_ctrl_setup_received+0x54>
		udd_ack_setup_received(0);
  4061b8:	4b5e      	ldr	r3, [pc, #376]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4061ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4061bc:	613b      	str	r3, [r7, #16]
  4061be:	693b      	ldr	r3, [r7, #16]
  4061c0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4061c4:	613b      	str	r3, [r7, #16]
  4061c6:	693b      	ldr	r3, [r7, #16]
  4061c8:	f023 0304 	bic.w	r3, r3, #4
  4061cc:	613b      	str	r3, [r7, #16]
  4061ce:	4a59      	ldr	r2, [pc, #356]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4061d0:	693b      	ldr	r3, [r7, #16]
  4061d2:	6313      	str	r3, [r2, #48]	; 0x30
  4061d4:	bf00      	nop
  4061d6:	4b57      	ldr	r3, [pc, #348]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4061d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4061da:	f003 0304 	and.w	r3, r3, #4
  4061de:	2b00      	cmp	r3, #0
  4061e0:	d1f9      	bne.n	4061d6 <udd_ctrl_setup_received+0x42>
		udd_ctrl_stall_data();
  4061e2:	4b55      	ldr	r3, [pc, #340]	; (406338 <udd_ctrl_setup_received+0x1a4>)
  4061e4:	4798      	blx	r3
		return; // Error data number doesn't correspond to SETUP packet
  4061e6:	e09b      	b.n	406320 <udd_ctrl_setup_received+0x18c>
	}
	for (i = 0; i < 8; i++) {
  4061e8:	2300      	movs	r3, #0
  4061ea:	75fb      	strb	r3, [r7, #23]
  4061ec:	e009      	b.n	406202 <udd_ctrl_setup_received+0x6e>
		((uint8_t *) & udd_g_ctrlreq.req)[i] =
  4061ee:	7dfb      	ldrb	r3, [r7, #23]
  4061f0:	4a52      	ldr	r2, [pc, #328]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  4061f2:	4413      	add	r3, r2
			udd_endpoint_fifo_read(0);
  4061f4:	4a4f      	ldr	r2, [pc, #316]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4061f6:	6d12      	ldr	r2, [r2, #80]	; 0x50
		((uint8_t *) & udd_g_ctrlreq.req)[i] =
  4061f8:	b2d2      	uxtb	r2, r2
  4061fa:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < 8; i++) {
  4061fc:	7dfb      	ldrb	r3, [r7, #23]
  4061fe:	3301      	adds	r3, #1
  406200:	75fb      	strb	r3, [r7, #23]
  406202:	7dfb      	ldrb	r3, [r7, #23]
  406204:	2b07      	cmp	r3, #7
  406206:	d9f2      	bls.n	4061ee <udd_ctrl_setup_received+0x5a>
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
  406208:	4b4c      	ldr	r3, [pc, #304]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  40620a:	885a      	ldrh	r2, [r3, #2]
  40620c:	4b4b      	ldr	r3, [pc, #300]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  40620e:	805a      	strh	r2, [r3, #2]
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
  406210:	4b4a      	ldr	r3, [pc, #296]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  406212:	889a      	ldrh	r2, [r3, #4]
  406214:	4b49      	ldr	r3, [pc, #292]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  406216:	809a      	strh	r2, [r3, #4]
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
  406218:	4b48      	ldr	r3, [pc, #288]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  40621a:	88da      	ldrh	r2, [r3, #6]
  40621c:	4b47      	ldr	r3, [pc, #284]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  40621e:	80da      	strh	r2, [r3, #6]

	// Decode setup request
	if (udc_process_setup() == false) {
  406220:	4b47      	ldr	r3, [pc, #284]	; (406340 <udd_ctrl_setup_received+0x1ac>)
  406222:	4798      	blx	r3
  406224:	4603      	mov	r3, r0
  406226:	f083 0301 	eor.w	r3, r3, #1
  40622a:	b2db      	uxtb	r3, r3
  40622c:	2b00      	cmp	r3, #0
  40622e:	d017      	beq.n	406260 <udd_ctrl_setup_received+0xcc>
		// Setup request unknown then stall it
		udd_ack_setup_received(0);
  406230:	4b40      	ldr	r3, [pc, #256]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  406232:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406234:	60fb      	str	r3, [r7, #12]
  406236:	68fb      	ldr	r3, [r7, #12]
  406238:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40623c:	60fb      	str	r3, [r7, #12]
  40623e:	68fb      	ldr	r3, [r7, #12]
  406240:	f023 0304 	bic.w	r3, r3, #4
  406244:	60fb      	str	r3, [r7, #12]
  406246:	4a3b      	ldr	r2, [pc, #236]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  406248:	68fb      	ldr	r3, [r7, #12]
  40624a:	6313      	str	r3, [r2, #48]	; 0x30
  40624c:	bf00      	nop
  40624e:	4b39      	ldr	r3, [pc, #228]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  406250:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406252:	f003 0304 	and.w	r3, r3, #4
  406256:	2b00      	cmp	r3, #0
  406258:	d1f9      	bne.n	40624e <udd_ctrl_setup_received+0xba>
		udd_ctrl_stall_data();
  40625a:	4b37      	ldr	r3, [pc, #220]	; (406338 <udd_ctrl_setup_received+0x1a4>)
  40625c:	4798      	blx	r3
		return;
  40625e:	e05f      	b.n	406320 <udd_ctrl_setup_received+0x18c>
	}

	if (Udd_setup_is_in()) {
  406260:	4b36      	ldr	r3, [pc, #216]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  406262:	781b      	ldrb	r3, [r3, #0]
  406264:	b25b      	sxtb	r3, r3
  406266:	2b00      	cmp	r3, #0
  406268:	da35      	bge.n	4062d6 <udd_ctrl_setup_received+0x142>
		// Set DIR
		udd_set_endpoint_direction_in(0);
  40626a:	4b32      	ldr	r3, [pc, #200]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  40626c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40626e:	60bb      	str	r3, [r7, #8]
  406270:	68bb      	ldr	r3, [r7, #8]
  406272:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406276:	60bb      	str	r3, [r7, #8]
  406278:	68bb      	ldr	r3, [r7, #8]
  40627a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40627e:	60bb      	str	r3, [r7, #8]
  406280:	4a2c      	ldr	r2, [pc, #176]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  406282:	68bb      	ldr	r3, [r7, #8]
  406284:	6313      	str	r3, [r2, #48]	; 0x30
  406286:	bf00      	nop
  406288:	4b2a      	ldr	r3, [pc, #168]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  40628a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40628c:	f003 0380 	and.w	r3, r3, #128	; 0x80
  406290:	2b80      	cmp	r3, #128	; 0x80
  406292:	d1f9      	bne.n	406288 <udd_ctrl_setup_received+0xf4>
		udd_ack_setup_received(0);
  406294:	4b27      	ldr	r3, [pc, #156]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  406296:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406298:	607b      	str	r3, [r7, #4]
  40629a:	687b      	ldr	r3, [r7, #4]
  40629c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4062a0:	607b      	str	r3, [r7, #4]
  4062a2:	687b      	ldr	r3, [r7, #4]
  4062a4:	f023 0304 	bic.w	r3, r3, #4
  4062a8:	607b      	str	r3, [r7, #4]
  4062aa:	4a22      	ldr	r2, [pc, #136]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4062ac:	687b      	ldr	r3, [r7, #4]
  4062ae:	6313      	str	r3, [r2, #48]	; 0x30
  4062b0:	bf00      	nop
  4062b2:	4b20      	ldr	r3, [pc, #128]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4062b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4062b6:	f003 0304 	and.w	r3, r3, #4
  4062ba:	2b00      	cmp	r3, #0
  4062bc:	d1f9      	bne.n	4062b2 <udd_ctrl_setup_received+0x11e>
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
  4062be:	4b21      	ldr	r3, [pc, #132]	; (406344 <udd_ctrl_setup_received+0x1b0>)
  4062c0:	2200      	movs	r2, #0
  4062c2:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_nb_trans = 0;
  4062c4:	4b20      	ldr	r3, [pc, #128]	; (406348 <udd_ctrl_setup_received+0x1b4>)
  4062c6:	2200      	movs	r2, #0
  4062c8:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
  4062ca:	4b17      	ldr	r3, [pc, #92]	; (406328 <udd_ctrl_setup_received+0x194>)
  4062cc:	2202      	movs	r2, #2
  4062ce:	701a      	strb	r2, [r3, #0]
		udd_ctrl_in_sent(); // Send first data transfer
  4062d0:	4b1e      	ldr	r3, [pc, #120]	; (40634c <udd_ctrl_setup_received+0x1b8>)
  4062d2:	4798      	blx	r3
  4062d4:	e024      	b.n	406320 <udd_ctrl_setup_received+0x18c>
	} else {
		udd_ack_setup_received(0);
  4062d6:	4b17      	ldr	r3, [pc, #92]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4062d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4062da:	603b      	str	r3, [r7, #0]
  4062dc:	683b      	ldr	r3, [r7, #0]
  4062de:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4062e2:	603b      	str	r3, [r7, #0]
  4062e4:	683b      	ldr	r3, [r7, #0]
  4062e6:	f023 0304 	bic.w	r3, r3, #4
  4062ea:	603b      	str	r3, [r7, #0]
  4062ec:	4a11      	ldr	r2, [pc, #68]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4062ee:	683b      	ldr	r3, [r7, #0]
  4062f0:	6313      	str	r3, [r2, #48]	; 0x30
  4062f2:	bf00      	nop
  4062f4:	4b0f      	ldr	r3, [pc, #60]	; (406334 <udd_ctrl_setup_received+0x1a0>)
  4062f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4062f8:	f003 0304 	and.w	r3, r3, #4
  4062fc:	2b00      	cmp	r3, #0
  4062fe:	d1f9      	bne.n	4062f4 <udd_ctrl_setup_received+0x160>
		if (0 == udd_g_ctrlreq.req.wLength) {
  406300:	4b0e      	ldr	r3, [pc, #56]	; (40633c <udd_ctrl_setup_received+0x1a8>)
  406302:	88db      	ldrh	r3, [r3, #6]
  406304:	2b00      	cmp	r3, #0
  406306:	d102      	bne.n	40630e <udd_ctrl_setup_received+0x17a>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
  406308:	4b11      	ldr	r3, [pc, #68]	; (406350 <udd_ctrl_setup_received+0x1bc>)
  40630a:	4798      	blx	r3
			return;
  40630c:	e008      	b.n	406320 <udd_ctrl_setup_received+0x18c>
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
  40630e:	4b0d      	ldr	r3, [pc, #52]	; (406344 <udd_ctrl_setup_received+0x1b0>)
  406310:	2200      	movs	r2, #0
  406312:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_nb_trans = 0;
  406314:	4b0c      	ldr	r3, [pc, #48]	; (406348 <udd_ctrl_setup_received+0x1b4>)
  406316:	2200      	movs	r2, #0
  406318:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
  40631a:	4b03      	ldr	r3, [pc, #12]	; (406328 <udd_ctrl_setup_received+0x194>)
  40631c:	2201      	movs	r2, #1
  40631e:	701a      	strb	r2, [r3, #0]
	}
}
  406320:	3718      	adds	r7, #24
  406322:	46bd      	mov	sp, r7
  406324:	bd80      	pop	{r7, pc}
  406326:	bf00      	nop
  406328:	20008835 	.word	0x20008835
  40632c:	00406851 	.word	0x00406851
  406330:	00406165 	.word	0x00406165
  406334:	40084000 	.word	0x40084000
  406338:	004067a1 	.word	0x004067a1
  40633c:	2000896c 	.word	0x2000896c
  406340:	00405071 	.word	0x00405071
  406344:	20008836 	.word	0x20008836
  406348:	20008838 	.word	0x20008838
  40634c:	00406355 	.word	0x00406355
  406350:	004067ed 	.word	0x004067ed

00406354 <udd_ctrl_in_sent>:


static void udd_ctrl_in_sent(void)
{
  406354:	b580      	push	{r7, lr}
  406356:	b088      	sub	sp, #32
  406358:	af00      	add	r7, sp, #0
	uint16_t nb_remain;
	uint8_t i;
	uint8_t *ptr_src;
	irqflags_t flags;

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
  40635a:	4b71      	ldr	r3, [pc, #452]	; (406520 <udd_ctrl_in_sent+0x1cc>)
  40635c:	781b      	ldrb	r3, [r3, #0]
  40635e:	2b03      	cmp	r3, #3
  406360:	d119      	bne.n	406396 <udd_ctrl_in_sent+0x42>
		// Ack
		udd_ack_in_sent(0);
  406362:	4b70      	ldr	r3, [pc, #448]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406364:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406366:	613b      	str	r3, [r7, #16]
  406368:	693b      	ldr	r3, [r7, #16]
  40636a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40636e:	613b      	str	r3, [r7, #16]
  406370:	693b      	ldr	r3, [r7, #16]
  406372:	f023 0301 	bic.w	r3, r3, #1
  406376:	613b      	str	r3, [r7, #16]
  406378:	4a6a      	ldr	r2, [pc, #424]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  40637a:	693b      	ldr	r3, [r7, #16]
  40637c:	6313      	str	r3, [r2, #48]	; 0x30
  40637e:	bf00      	nop
  406380:	4b68      	ldr	r3, [pc, #416]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406382:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406384:	f003 0301 	and.w	r3, r3, #1
  406388:	2b00      	cmp	r3, #0
  40638a:	d1f9      	bne.n	406380 <udd_ctrl_in_sent+0x2c>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
  40638c:	4b66      	ldr	r3, [pc, #408]	; (406528 <udd_ctrl_in_sent+0x1d4>)
  40638e:	4798      	blx	r3
		// Reinitializes control endpoint management
		udd_ctrl_init();
  406390:	4b66      	ldr	r3, [pc, #408]	; (40652c <udd_ctrl_in_sent+0x1d8>)
  406392:	4798      	blx	r3
		return;
  406394:	e0c1      	b.n	40651a <udd_ctrl_in_sent+0x1c6>
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
  406396:	4b66      	ldr	r3, [pc, #408]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  406398:	899a      	ldrh	r2, [r3, #12]
  40639a:	4b66      	ldr	r3, [pc, #408]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  40639c:	881b      	ldrh	r3, [r3, #0]
  40639e:	1ad3      	subs	r3, r2, r3
  4063a0:	83fb      	strh	r3, [r7, #30]
	if (0 == nb_remain) {
  4063a2:	8bfb      	ldrh	r3, [r7, #30]
  4063a4:	2b00      	cmp	r3, #0
  4063a6:	d13c      	bne.n	406422 <udd_ctrl_in_sent+0xce>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous payload buffer
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
  4063a8:	4b63      	ldr	r3, [pc, #396]	; (406538 <udd_ctrl_in_sent+0x1e4>)
  4063aa:	881a      	ldrh	r2, [r3, #0]
  4063ac:	4b61      	ldr	r3, [pc, #388]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  4063ae:	881b      	ldrh	r3, [r3, #0]
  4063b0:	4413      	add	r3, r2
  4063b2:	b29a      	uxth	r2, r3
  4063b4:	4b60      	ldr	r3, [pc, #384]	; (406538 <udd_ctrl_in_sent+0x1e4>)
  4063b6:	801a      	strh	r2, [r3, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans)
  4063b8:	4b5d      	ldr	r3, [pc, #372]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  4063ba:	88da      	ldrh	r2, [r3, #6]
  4063bc:	4b5e      	ldr	r3, [pc, #376]	; (406538 <udd_ctrl_in_sent+0x1e4>)
  4063be:	881b      	ldrh	r3, [r3, #0]
  4063c0:	429a      	cmp	r2, r3
  4063c2:	d003      	beq.n	4063cc <udd_ctrl_in_sent+0x78>
				|| b_shortpacket) {
  4063c4:	4b5d      	ldr	r3, [pc, #372]	; (40653c <udd_ctrl_in_sent+0x1e8>)
  4063c6:	781b      	ldrb	r3, [r3, #0]
  4063c8:	2b00      	cmp	r3, #0
  4063ca:	d017      	beq.n	4063fc <udd_ctrl_in_sent+0xa8>
			// All data requested are transfered or a short packet has been sent
			// then it is the end of data phase.
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
  4063cc:	4b5c      	ldr	r3, [pc, #368]	; (406540 <udd_ctrl_in_sent+0x1ec>)
  4063ce:	4798      	blx	r3
			udd_ack_in_sent(0);
  4063d0:	4b54      	ldr	r3, [pc, #336]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4063d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4063d4:	60fb      	str	r3, [r7, #12]
  4063d6:	68fb      	ldr	r3, [r7, #12]
  4063d8:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4063dc:	60fb      	str	r3, [r7, #12]
  4063de:	68fb      	ldr	r3, [r7, #12]
  4063e0:	f023 0301 	bic.w	r3, r3, #1
  4063e4:	60fb      	str	r3, [r7, #12]
  4063e6:	4a4f      	ldr	r2, [pc, #316]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4063e8:	68fb      	ldr	r3, [r7, #12]
  4063ea:	6313      	str	r3, [r2, #48]	; 0x30
  4063ec:	bf00      	nop
  4063ee:	4b4d      	ldr	r3, [pc, #308]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4063f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4063f2:	f003 0301 	and.w	r3, r3, #1
  4063f6:	2b00      	cmp	r3, #0
  4063f8:	d1f9      	bne.n	4063ee <udd_ctrl_in_sent+0x9a>
			return;
  4063fa:	e08e      	b.n	40651a <udd_ctrl_in_sent+0x1c6>
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
  4063fc:	4b4c      	ldr	r3, [pc, #304]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  4063fe:	695b      	ldr	r3, [r3, #20]
  406400:	2b00      	cmp	r3, #0
  406402:	d00e      	beq.n	406422 <udd_ctrl_in_sent+0xce>
				|| (!udd_g_ctrlreq.over_under_run())) {
  406404:	4b4a      	ldr	r3, [pc, #296]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  406406:	695b      	ldr	r3, [r3, #20]
  406408:	4798      	blx	r3
  40640a:	4603      	mov	r3, r0
  40640c:	f083 0301 	eor.w	r3, r3, #1
  406410:	b2db      	uxtb	r3, r3
  406412:	2b00      	cmp	r3, #0
  406414:	d105      	bne.n	406422 <udd_ctrl_in_sent+0xce>
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_nb_trans = 0;
  406416:	4b47      	ldr	r3, [pc, #284]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  406418:	2200      	movs	r2, #0
  40641a:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
  40641c:	4b44      	ldr	r3, [pc, #272]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  40641e:	899b      	ldrh	r3, [r3, #12]
  406420:	83fb      	strh	r3, [r7, #30]
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
  406422:	8bfb      	ldrh	r3, [r7, #30]
  406424:	2b3f      	cmp	r3, #63	; 0x3f
  406426:	d905      	bls.n	406434 <udd_ctrl_in_sent+0xe0>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
  406428:	2340      	movs	r3, #64	; 0x40
  40642a:	83fb      	strh	r3, [r7, #30]
		b_shortpacket = false;
  40642c:	4b43      	ldr	r3, [pc, #268]	; (40653c <udd_ctrl_in_sent+0x1e8>)
  40642e:	2200      	movs	r2, #0
  406430:	701a      	strb	r2, [r3, #0]
  406432:	e002      	b.n	40643a <udd_ctrl_in_sent+0xe6>
	} else {
		b_shortpacket = true;
  406434:	4b41      	ldr	r3, [pc, #260]	; (40653c <udd_ctrl_in_sent+0x1e8>)
  406436:	2201      	movs	r2, #1
  406438:	701a      	strb	r2, [r3, #0]
	}
	// Fill buffer of endpoint control
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
  40643a:	4b3d      	ldr	r3, [pc, #244]	; (406530 <udd_ctrl_in_sent+0x1dc>)
  40643c:	689b      	ldr	r3, [r3, #8]
  40643e:	4a3d      	ldr	r2, [pc, #244]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  406440:	8812      	ldrh	r2, [r2, #0]
  406442:	4413      	add	r3, r2
  406444:	61bb      	str	r3, [r7, #24]
	// The IN data don't must be written in endpoint 0 DPRAM during
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is received the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
  406446:	4b3f      	ldr	r3, [pc, #252]	; (406544 <udd_ctrl_in_sent+0x1f0>)
  406448:	4798      	blx	r3
  40644a:	6178      	str	r0, [r7, #20]
	if (Is_udd_bank0_received(0)) {
  40644c:	4b35      	ldr	r3, [pc, #212]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  40644e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406450:	f003 0302 	and.w	r3, r3, #2
  406454:	2b00      	cmp	r3, #0
  406456:	d01b      	beq.n	406490 <udd_ctrl_in_sent+0x13c>
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
  406458:	6978      	ldr	r0, [r7, #20]
  40645a:	4b3b      	ldr	r3, [pc, #236]	; (406548 <udd_ctrl_in_sent+0x1f4>)
  40645c:	4798      	blx	r3
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
  40645e:	4b30      	ldr	r3, [pc, #192]	; (406520 <udd_ctrl_in_sent+0x1cc>)
  406460:	2204      	movs	r2, #4
  406462:	701a      	strb	r2, [r3, #0]
		udd_ack_in_sent(0);
  406464:	4b2f      	ldr	r3, [pc, #188]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406466:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406468:	60bb      	str	r3, [r7, #8]
  40646a:	68bb      	ldr	r3, [r7, #8]
  40646c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406470:	60bb      	str	r3, [r7, #8]
  406472:	68bb      	ldr	r3, [r7, #8]
  406474:	f023 0301 	bic.w	r3, r3, #1
  406478:	60bb      	str	r3, [r7, #8]
  40647a:	4a2a      	ldr	r2, [pc, #168]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  40647c:	68bb      	ldr	r3, [r7, #8]
  40647e:	6313      	str	r3, [r2, #48]	; 0x30
  406480:	bf00      	nop
  406482:	4b28      	ldr	r3, [pc, #160]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406484:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406486:	f003 0301 	and.w	r3, r3, #1
  40648a:	2b00      	cmp	r3, #0
  40648c:	d1f9      	bne.n	406482 <udd_ctrl_in_sent+0x12e>
		return; // Exit of IN DATA phase
  40648e:	e044      	b.n	40651a <udd_ctrl_in_sent+0x1c6>
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
  406490:	2300      	movs	r3, #0
  406492:	777b      	strb	r3, [r7, #29]
  406494:	e008      	b.n	4064a8 <udd_ctrl_in_sent+0x154>
		udd_endpoint_fifo_write(0, *ptr_src++);
  406496:	4923      	ldr	r1, [pc, #140]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406498:	69bb      	ldr	r3, [r7, #24]
  40649a:	1c5a      	adds	r2, r3, #1
  40649c:	61ba      	str	r2, [r7, #24]
  40649e:	781b      	ldrb	r3, [r3, #0]
  4064a0:	650b      	str	r3, [r1, #80]	; 0x50
	for (i = 0; i < nb_remain; i++) {
  4064a2:	7f7b      	ldrb	r3, [r7, #29]
  4064a4:	3301      	adds	r3, #1
  4064a6:	777b      	strb	r3, [r7, #29]
  4064a8:	7f7b      	ldrb	r3, [r7, #29]
  4064aa:	b29b      	uxth	r3, r3
  4064ac:	8bfa      	ldrh	r2, [r7, #30]
  4064ae:	429a      	cmp	r2, r3
  4064b0:	d8f1      	bhi.n	406496 <udd_ctrl_in_sent+0x142>
	}
	udd_ctrl_payload_nb_trans += nb_remain;
  4064b2:	4b20      	ldr	r3, [pc, #128]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  4064b4:	881a      	ldrh	r2, [r3, #0]
  4064b6:	8bfb      	ldrh	r3, [r7, #30]
  4064b8:	4413      	add	r3, r2
  4064ba:	b29a      	uxth	r2, r3
  4064bc:	4b1d      	ldr	r3, [pc, #116]	; (406534 <udd_ctrl_in_sent+0x1e0>)
  4064be:	801a      	strh	r2, [r3, #0]
	// Validate and send the data available in the control endpoint buffer
	udd_set_transmit_ready(0);
  4064c0:	4b18      	ldr	r3, [pc, #96]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4064c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4064c4:	607b      	str	r3, [r7, #4]
  4064c6:	687b      	ldr	r3, [r7, #4]
  4064c8:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4064cc:	607b      	str	r3, [r7, #4]
  4064ce:	687b      	ldr	r3, [r7, #4]
  4064d0:	f043 0310 	orr.w	r3, r3, #16
  4064d4:	607b      	str	r3, [r7, #4]
  4064d6:	4a13      	ldr	r2, [pc, #76]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4064d8:	687b      	ldr	r3, [r7, #4]
  4064da:	6313      	str	r3, [r2, #48]	; 0x30
  4064dc:	bf00      	nop
  4064de:	4b11      	ldr	r3, [pc, #68]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4064e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4064e2:	f003 0310 	and.w	r3, r3, #16
  4064e6:	2b10      	cmp	r3, #16
  4064e8:	d1f9      	bne.n	4064de <udd_ctrl_in_sent+0x18a>
	udd_ack_in_sent(0);
  4064ea:	4b0e      	ldr	r3, [pc, #56]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  4064ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4064ee:	603b      	str	r3, [r7, #0]
  4064f0:	683b      	ldr	r3, [r7, #0]
  4064f2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4064f6:	603b      	str	r3, [r7, #0]
  4064f8:	683b      	ldr	r3, [r7, #0]
  4064fa:	f023 0301 	bic.w	r3, r3, #1
  4064fe:	603b      	str	r3, [r7, #0]
  406500:	4a08      	ldr	r2, [pc, #32]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  406502:	683b      	ldr	r3, [r7, #0]
  406504:	6313      	str	r3, [r2, #48]	; 0x30
  406506:	bf00      	nop
  406508:	4b06      	ldr	r3, [pc, #24]	; (406524 <udd_ctrl_in_sent+0x1d0>)
  40650a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40650c:	f003 0301 	and.w	r3, r3, #1
  406510:	2b00      	cmp	r3, #0
  406512:	d1f9      	bne.n	406508 <udd_ctrl_in_sent+0x1b4>

	// In case of abort of DATA IN phase, no need to enable nak OUT interrupt
	// because OUT endpoint is already free and ZLP OUT accepted.
	cpu_irq_restore(flags);
  406514:	6978      	ldr	r0, [r7, #20]
  406516:	4b0c      	ldr	r3, [pc, #48]	; (406548 <udd_ctrl_in_sent+0x1f4>)
  406518:	4798      	blx	r3
}
  40651a:	3720      	adds	r7, #32
  40651c:	46bd      	mov	sp, r7
  40651e:	bd80      	pop	{r7, pc}
  406520:	20008835 	.word	0x20008835
  406524:	40084000 	.word	0x40084000
  406528:	00406851 	.word	0x00406851
  40652c:	00406165 	.word	0x00406165
  406530:	2000896c 	.word	0x2000896c
  406534:	20008838 	.word	0x20008838
  406538:	20008836 	.word	0x20008836
  40653c:	20008878 	.word	0x20008878
  406540:	00406839 	.word	0x00406839
  406544:	00405375 	.word	0x00405375
  406548:	004053cd 	.word	0x004053cd

0040654c <udd_ctrl_out_received>:


static void udd_ctrl_out_received(void)
{
  40654c:	b580      	push	{r7, lr}
  40654e:	b088      	sub	sp, #32
  406550:	af00      	add	r7, sp, #0
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
  406552:	4b8a      	ldr	r3, [pc, #552]	; (40677c <udd_ctrl_out_received+0x230>)
  406554:	781b      	ldrb	r3, [r3, #0]
  406556:	2b01      	cmp	r3, #1
  406558:	d024      	beq.n	4065a4 <udd_ctrl_out_received+0x58>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
  40655a:	4b88      	ldr	r3, [pc, #544]	; (40677c <udd_ctrl_out_received+0x230>)
  40655c:	781b      	ldrb	r3, [r3, #0]
  40655e:	2b02      	cmp	r3, #2
  406560:	d003      	beq.n	40656a <udd_ctrl_out_received+0x1e>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
  406562:	4b86      	ldr	r3, [pc, #536]	; (40677c <udd_ctrl_out_received+0x230>)
  406564:	781b      	ldrb	r3, [r3, #0]
  406566:	2b04      	cmp	r3, #4
  406568:	d102      	bne.n	406570 <udd_ctrl_out_received+0x24>
				udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
  40656a:	4b85      	ldr	r3, [pc, #532]	; (406780 <udd_ctrl_out_received+0x234>)
  40656c:	4798      	blx	r3
  40656e:	e001      	b.n	406574 <udd_ctrl_out_received+0x28>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
  406570:	4b84      	ldr	r3, [pc, #528]	; (406784 <udd_ctrl_out_received+0x238>)
  406572:	4798      	blx	r3
		}
		udd_ack_bank0_received(0);
  406574:	4b84      	ldr	r3, [pc, #528]	; (406788 <udd_ctrl_out_received+0x23c>)
  406576:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406578:	617b      	str	r3, [r7, #20]
  40657a:	697b      	ldr	r3, [r7, #20]
  40657c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406580:	617b      	str	r3, [r7, #20]
  406582:	697b      	ldr	r3, [r7, #20]
  406584:	f023 0302 	bic.w	r3, r3, #2
  406588:	617b      	str	r3, [r7, #20]
  40658a:	4a7f      	ldr	r2, [pc, #508]	; (406788 <udd_ctrl_out_received+0x23c>)
  40658c:	697b      	ldr	r3, [r7, #20]
  40658e:	6313      	str	r3, [r2, #48]	; 0x30
  406590:	bf00      	nop
  406592:	4b7d      	ldr	r3, [pc, #500]	; (406788 <udd_ctrl_out_received+0x23c>)
  406594:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406596:	f003 0302 	and.w	r3, r3, #2
  40659a:	2b00      	cmp	r3, #0
  40659c:	d1f9      	bne.n	406592 <udd_ctrl_out_received+0x46>
		// Reinitializes control endpoint management
		udd_ctrl_init();
  40659e:	4b7b      	ldr	r3, [pc, #492]	; (40678c <udd_ctrl_out_received+0x240>)
  4065a0:	4798      	blx	r3
		return;
  4065a2:	e0e7      	b.n	406774 <udd_ctrl_out_received+0x228>
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
  4065a4:	4b78      	ldr	r3, [pc, #480]	; (406788 <udd_ctrl_out_received+0x23c>)
  4065a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4065a8:	0c1b      	lsrs	r3, r3, #16
  4065aa:	b29b      	uxth	r3, r3
  4065ac:	f3c3 030a 	ubfx	r3, r3, #0, #11
  4065b0:	83bb      	strh	r3, [r7, #28]
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
  4065b2:	4b77      	ldr	r3, [pc, #476]	; (406790 <udd_ctrl_out_received+0x244>)
  4065b4:	899b      	ldrh	r3, [r3, #12]
  4065b6:	461a      	mov	r2, r3
  4065b8:	4b76      	ldr	r3, [pc, #472]	; (406794 <udd_ctrl_out_received+0x248>)
  4065ba:	881b      	ldrh	r3, [r3, #0]
  4065bc:	4619      	mov	r1, r3
  4065be:	8bbb      	ldrh	r3, [r7, #28]
  4065c0:	440b      	add	r3, r1
  4065c2:	429a      	cmp	r2, r3
  4065c4:	da05      	bge.n	4065d2 <udd_ctrl_out_received+0x86>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
  4065c6:	4b72      	ldr	r3, [pc, #456]	; (406790 <udd_ctrl_out_received+0x244>)
  4065c8:	899a      	ldrh	r2, [r3, #12]
  4065ca:	4b72      	ldr	r3, [pc, #456]	; (406794 <udd_ctrl_out_received+0x248>)
  4065cc:	881b      	ldrh	r3, [r3, #0]
  4065ce:	1ad3      	subs	r3, r2, r3
  4065d0:	83bb      	strh	r3, [r7, #28]
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
  4065d2:	4b6f      	ldr	r3, [pc, #444]	; (406790 <udd_ctrl_out_received+0x244>)
  4065d4:	689b      	ldr	r3, [r3, #8]
  4065d6:	4a6f      	ldr	r2, [pc, #444]	; (406794 <udd_ctrl_out_received+0x248>)
  4065d8:	8812      	ldrh	r2, [r2, #0]
  4065da:	4413      	add	r3, r2
  4065dc:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < nb_data; i++) {
  4065de:	2300      	movs	r3, #0
  4065e0:	77fb      	strb	r3, [r7, #31]
  4065e2:	e009      	b.n	4065f8 <udd_ctrl_out_received+0xac>
		*ptr_dest++ = udd_endpoint_fifo_read(0);
  4065e4:	69bb      	ldr	r3, [r7, #24]
  4065e6:	1c5a      	adds	r2, r3, #1
  4065e8:	61ba      	str	r2, [r7, #24]
  4065ea:	4a67      	ldr	r2, [pc, #412]	; (406788 <udd_ctrl_out_received+0x23c>)
  4065ec:	6d12      	ldr	r2, [r2, #80]	; 0x50
  4065ee:	b2d2      	uxtb	r2, r2
  4065f0:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < nb_data; i++) {
  4065f2:	7ffb      	ldrb	r3, [r7, #31]
  4065f4:	3301      	adds	r3, #1
  4065f6:	77fb      	strb	r3, [r7, #31]
  4065f8:	7ffb      	ldrb	r3, [r7, #31]
  4065fa:	b29b      	uxth	r3, r3
  4065fc:	8bba      	ldrh	r2, [r7, #28]
  4065fe:	429a      	cmp	r2, r3
  406600:	d8f0      	bhi.n	4065e4 <udd_ctrl_out_received+0x98>
	}
	udd_ctrl_payload_nb_trans += nb_data;
  406602:	4b64      	ldr	r3, [pc, #400]	; (406794 <udd_ctrl_out_received+0x248>)
  406604:	881a      	ldrh	r2, [r3, #0]
  406606:	8bbb      	ldrh	r3, [r7, #28]
  406608:	4413      	add	r3, r2
  40660a:	b29a      	uxth	r2, r3
  40660c:	4b61      	ldr	r3, [pc, #388]	; (406794 <udd_ctrl_out_received+0x248>)
  40660e:	801a      	strh	r2, [r3, #0]

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
  406610:	8bbb      	ldrh	r3, [r7, #28]
  406612:	2b40      	cmp	r3, #64	; 0x40
  406614:	d10a      	bne.n	40662c <udd_ctrl_out_received+0xe0>
			|| (udd_g_ctrlreq.req.wLength <=
  406616:	4b5e      	ldr	r3, [pc, #376]	; (406790 <udd_ctrl_out_received+0x244>)
  406618:	88db      	ldrh	r3, [r3, #6]
  40661a:	461a      	mov	r2, r3
			(udd_ctrl_prev_payload_nb_trans +
  40661c:	4b5e      	ldr	r3, [pc, #376]	; (406798 <udd_ctrl_out_received+0x24c>)
  40661e:	881b      	ldrh	r3, [r3, #0]
  406620:	4619      	mov	r1, r3
  406622:	4b5c      	ldr	r3, [pc, #368]	; (406794 <udd_ctrl_out_received+0x248>)
  406624:	881b      	ldrh	r3, [r3, #0]
  406626:	440b      	add	r3, r1
			|| (udd_g_ctrlreq.req.wLength <=
  406628:	429a      	cmp	r2, r3
  40662a:	dc40      	bgt.n	4066ae <udd_ctrl_out_received+0x162>
			udd_ctrl_payload_nb_trans))) {
		// End of reception because it is a short packet
		// Before send ZLP, call intermediate callback
		// in case of data receive generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
  40662c:	4b59      	ldr	r3, [pc, #356]	; (406794 <udd_ctrl_out_received+0x248>)
  40662e:	881a      	ldrh	r2, [r3, #0]
  406630:	4b57      	ldr	r3, [pc, #348]	; (406790 <udd_ctrl_out_received+0x244>)
  406632:	819a      	strh	r2, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
  406634:	4b56      	ldr	r3, [pc, #344]	; (406790 <udd_ctrl_out_received+0x244>)
  406636:	695b      	ldr	r3, [r3, #20]
  406638:	2b00      	cmp	r3, #0
  40663a:	d020      	beq.n	40667e <udd_ctrl_out_received+0x132>
			if (!udd_g_ctrlreq.over_under_run()) {
  40663c:	4b54      	ldr	r3, [pc, #336]	; (406790 <udd_ctrl_out_received+0x244>)
  40663e:	695b      	ldr	r3, [r3, #20]
  406640:	4798      	blx	r3
  406642:	4603      	mov	r3, r0
  406644:	f083 0301 	eor.w	r3, r3, #1
  406648:	b2db      	uxtb	r3, r3
  40664a:	2b00      	cmp	r3, #0
  40664c:	d017      	beq.n	40667e <udd_ctrl_out_received+0x132>
				// Stall ZLP
				udd_ctrl_stall_data();
  40664e:	4b4d      	ldr	r3, [pc, #308]	; (406784 <udd_ctrl_out_received+0x238>)
  406650:	4798      	blx	r3
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_bank0_received(0);
  406652:	4b4d      	ldr	r3, [pc, #308]	; (406788 <udd_ctrl_out_received+0x23c>)
  406654:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406656:	613b      	str	r3, [r7, #16]
  406658:	693b      	ldr	r3, [r7, #16]
  40665a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40665e:	613b      	str	r3, [r7, #16]
  406660:	693b      	ldr	r3, [r7, #16]
  406662:	f023 0302 	bic.w	r3, r3, #2
  406666:	613b      	str	r3, [r7, #16]
  406668:	4a47      	ldr	r2, [pc, #284]	; (406788 <udd_ctrl_out_received+0x23c>)
  40666a:	693b      	ldr	r3, [r7, #16]
  40666c:	6313      	str	r3, [r2, #48]	; 0x30
  40666e:	bf00      	nop
  406670:	4b45      	ldr	r3, [pc, #276]	; (406788 <udd_ctrl_out_received+0x23c>)
  406672:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406674:	f003 0302 	and.w	r3, r3, #2
  406678:	2b00      	cmp	r3, #0
  40667a:	d1f9      	bne.n	406670 <udd_ctrl_out_received+0x124>
				return;
  40667c:	e07a      	b.n	406774 <udd_ctrl_out_received+0x228>
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_bank0_received(0);
  40667e:	4b42      	ldr	r3, [pc, #264]	; (406788 <udd_ctrl_out_received+0x23c>)
  406680:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406682:	60fb      	str	r3, [r7, #12]
  406684:	68fb      	ldr	r3, [r7, #12]
  406686:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40668a:	60fb      	str	r3, [r7, #12]
  40668c:	68fb      	ldr	r3, [r7, #12]
  40668e:	f023 0302 	bic.w	r3, r3, #2
  406692:	60fb      	str	r3, [r7, #12]
  406694:	4a3c      	ldr	r2, [pc, #240]	; (406788 <udd_ctrl_out_received+0x23c>)
  406696:	68fb      	ldr	r3, [r7, #12]
  406698:	6313      	str	r3, [r2, #48]	; 0x30
  40669a:	bf00      	nop
  40669c:	4b3a      	ldr	r3, [pc, #232]	; (406788 <udd_ctrl_out_received+0x23c>)
  40669e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4066a0:	f003 0302 	and.w	r3, r3, #2
  4066a4:	2b00      	cmp	r3, #0
  4066a6:	d1f9      	bne.n	40669c <udd_ctrl_out_received+0x150>
		udd_ctrl_send_zlp_in();
  4066a8:	4b3c      	ldr	r3, [pc, #240]	; (40679c <udd_ctrl_out_received+0x250>)
  4066aa:	4798      	blx	r3
		return;
  4066ac:	e062      	b.n	406774 <udd_ctrl_out_received+0x228>
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
  4066ae:	4b38      	ldr	r3, [pc, #224]	; (406790 <udd_ctrl_out_received+0x244>)
  4066b0:	899a      	ldrh	r2, [r3, #12]
  4066b2:	4b38      	ldr	r3, [pc, #224]	; (406794 <udd_ctrl_out_received+0x248>)
  4066b4:	881b      	ldrh	r3, [r3, #0]
  4066b6:	429a      	cmp	r2, r3
  4066b8:	d147      	bne.n	40674a <udd_ctrl_out_received+0x1fe>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
  4066ba:	4b35      	ldr	r3, [pc, #212]	; (406790 <udd_ctrl_out_received+0x244>)
  4066bc:	695b      	ldr	r3, [r3, #20]
  4066be:	2b00      	cmp	r3, #0
  4066c0:	d117      	bne.n	4066f2 <udd_ctrl_out_received+0x1a6>
			// No callback available to request a new payload buffer
			udd_ctrl_stall_data();
  4066c2:	4b30      	ldr	r3, [pc, #192]	; (406784 <udd_ctrl_out_received+0x238>)
  4066c4:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_bank0_received(0);
  4066c6:	4b30      	ldr	r3, [pc, #192]	; (406788 <udd_ctrl_out_received+0x23c>)
  4066c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4066ca:	60bb      	str	r3, [r7, #8]
  4066cc:	68bb      	ldr	r3, [r7, #8]
  4066ce:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4066d2:	60bb      	str	r3, [r7, #8]
  4066d4:	68bb      	ldr	r3, [r7, #8]
  4066d6:	f023 0302 	bic.w	r3, r3, #2
  4066da:	60bb      	str	r3, [r7, #8]
  4066dc:	4a2a      	ldr	r2, [pc, #168]	; (406788 <udd_ctrl_out_received+0x23c>)
  4066de:	68bb      	ldr	r3, [r7, #8]
  4066e0:	6313      	str	r3, [r2, #48]	; 0x30
  4066e2:	bf00      	nop
  4066e4:	4b28      	ldr	r3, [pc, #160]	; (406788 <udd_ctrl_out_received+0x23c>)
  4066e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4066e8:	f003 0302 	and.w	r3, r3, #2
  4066ec:	2b00      	cmp	r3, #0
  4066ee:	d1f9      	bne.n	4066e4 <udd_ctrl_out_received+0x198>
			return;
  4066f0:	e040      	b.n	406774 <udd_ctrl_out_received+0x228>
		}
		if (!udd_g_ctrlreq.over_under_run()) {
  4066f2:	4b27      	ldr	r3, [pc, #156]	; (406790 <udd_ctrl_out_received+0x244>)
  4066f4:	695b      	ldr	r3, [r3, #20]
  4066f6:	4798      	blx	r3
  4066f8:	4603      	mov	r3, r0
  4066fa:	f083 0301 	eor.w	r3, r3, #1
  4066fe:	b2db      	uxtb	r3, r3
  406700:	2b00      	cmp	r3, #0
  406702:	d017      	beq.n	406734 <udd_ctrl_out_received+0x1e8>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
  406704:	4b1f      	ldr	r3, [pc, #124]	; (406784 <udd_ctrl_out_received+0x238>)
  406706:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_bank0_received(0);
  406708:	4b1f      	ldr	r3, [pc, #124]	; (406788 <udd_ctrl_out_received+0x23c>)
  40670a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40670c:	607b      	str	r3, [r7, #4]
  40670e:	687b      	ldr	r3, [r7, #4]
  406710:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406714:	607b      	str	r3, [r7, #4]
  406716:	687b      	ldr	r3, [r7, #4]
  406718:	f023 0302 	bic.w	r3, r3, #2
  40671c:	607b      	str	r3, [r7, #4]
  40671e:	4a1a      	ldr	r2, [pc, #104]	; (406788 <udd_ctrl_out_received+0x23c>)
  406720:	687b      	ldr	r3, [r7, #4]
  406722:	6313      	str	r3, [r2, #48]	; 0x30
  406724:	bf00      	nop
  406726:	4b18      	ldr	r3, [pc, #96]	; (406788 <udd_ctrl_out_received+0x23c>)
  406728:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40672a:	f003 0302 	and.w	r3, r3, #2
  40672e:	2b00      	cmp	r3, #0
  406730:	d1f9      	bne.n	406726 <udd_ctrl_out_received+0x1da>
			return;
  406732:	e01f      	b.n	406774 <udd_ctrl_out_received+0x228>
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
  406734:	4b18      	ldr	r3, [pc, #96]	; (406798 <udd_ctrl_out_received+0x24c>)
  406736:	881a      	ldrh	r2, [r3, #0]
  406738:	4b16      	ldr	r3, [pc, #88]	; (406794 <udd_ctrl_out_received+0x248>)
  40673a:	881b      	ldrh	r3, [r3, #0]
  40673c:	4413      	add	r3, r2
  40673e:	b29a      	uxth	r2, r3
  406740:	4b15      	ldr	r3, [pc, #84]	; (406798 <udd_ctrl_out_received+0x24c>)
  406742:	801a      	strh	r2, [r3, #0]
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
  406744:	4b13      	ldr	r3, [pc, #76]	; (406794 <udd_ctrl_out_received+0x248>)
  406746:	2200      	movs	r2, #0
  406748:	801a      	strh	r2, [r3, #0]
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_bank0_received(0);
  40674a:	4b0f      	ldr	r3, [pc, #60]	; (406788 <udd_ctrl_out_received+0x23c>)
  40674c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40674e:	603b      	str	r3, [r7, #0]
  406750:	683b      	ldr	r3, [r7, #0]
  406752:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406756:	603b      	str	r3, [r7, #0]
  406758:	683b      	ldr	r3, [r7, #0]
  40675a:	f023 0302 	bic.w	r3, r3, #2
  40675e:	603b      	str	r3, [r7, #0]
  406760:	4a09      	ldr	r2, [pc, #36]	; (406788 <udd_ctrl_out_received+0x23c>)
  406762:	683b      	ldr	r3, [r7, #0]
  406764:	6313      	str	r3, [r2, #48]	; 0x30
  406766:	bf00      	nop
  406768:	4b07      	ldr	r3, [pc, #28]	; (406788 <udd_ctrl_out_received+0x23c>)
  40676a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40676c:	f003 0302 	and.w	r3, r3, #2
  406770:	2b00      	cmp	r3, #0
  406772:	d1f9      	bne.n	406768 <udd_ctrl_out_received+0x21c>
}
  406774:	3720      	adds	r7, #32
  406776:	46bd      	mov	sp, r7
  406778:	bd80      	pop	{r7, pc}
  40677a:	bf00      	nop
  40677c:	20008835 	.word	0x20008835
  406780:	00406851 	.word	0x00406851
  406784:	004067a1 	.word	0x004067a1
  406788:	40084000 	.word	0x40084000
  40678c:	00406165 	.word	0x00406165
  406790:	2000896c 	.word	0x2000896c
  406794:	20008838 	.word	0x20008838
  406798:	20008836 	.word	0x20008836
  40679c:	004067ed 	.word	0x004067ed

004067a0 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
  4067a0:	b480      	push	{r7}
  4067a2:	b083      	sub	sp, #12
  4067a4:	af00      	add	r7, sp, #0
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
  4067a6:	4b0f      	ldr	r3, [pc, #60]	; (4067e4 <udd_ctrl_stall_data+0x44>)
  4067a8:	2205      	movs	r2, #5
  4067aa:	701a      	strb	r2, [r3, #0]
	udd_enable_stall_handshake(0);
  4067ac:	4b0e      	ldr	r3, [pc, #56]	; (4067e8 <udd_ctrl_stall_data+0x48>)
  4067ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4067b0:	607b      	str	r3, [r7, #4]
  4067b2:	687b      	ldr	r3, [r7, #4]
  4067b4:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4067b8:	607b      	str	r3, [r7, #4]
  4067ba:	687b      	ldr	r3, [r7, #4]
  4067bc:	f043 0320 	orr.w	r3, r3, #32
  4067c0:	607b      	str	r3, [r7, #4]
  4067c2:	4a09      	ldr	r2, [pc, #36]	; (4067e8 <udd_ctrl_stall_data+0x48>)
  4067c4:	687b      	ldr	r3, [r7, #4]
  4067c6:	6313      	str	r3, [r2, #48]	; 0x30
  4067c8:	bf00      	nop
  4067ca:	4b07      	ldr	r3, [pc, #28]	; (4067e8 <udd_ctrl_stall_data+0x48>)
  4067cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4067ce:	f003 0320 	and.w	r3, r3, #32
  4067d2:	2b20      	cmp	r3, #32
  4067d4:	d1f9      	bne.n	4067ca <udd_ctrl_stall_data+0x2a>
}
  4067d6:	bf00      	nop
  4067d8:	370c      	adds	r7, #12
  4067da:	46bd      	mov	sp, r7
  4067dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4067e0:	4770      	bx	lr
  4067e2:	bf00      	nop
  4067e4:	20008835 	.word	0x20008835
  4067e8:	40084000 	.word	0x40084000

004067ec <udd_ctrl_send_zlp_in>:


static void udd_ctrl_send_zlp_in(void)
{
  4067ec:	b480      	push	{r7}
  4067ee:	b083      	sub	sp, #12
  4067f0:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
  4067f2:	4b0f      	ldr	r3, [pc, #60]	; (406830 <udd_ctrl_send_zlp_in+0x44>)
  4067f4:	2203      	movs	r2, #3
  4067f6:	701a      	strb	r2, [r3, #0]
	// Validate and send empty IN packet on control endpoint
	// Send ZLP on IN endpoint
	udd_set_transmit_ready(0);
  4067f8:	4b0e      	ldr	r3, [pc, #56]	; (406834 <udd_ctrl_send_zlp_in+0x48>)
  4067fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4067fc:	607b      	str	r3, [r7, #4]
  4067fe:	687b      	ldr	r3, [r7, #4]
  406800:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406804:	607b      	str	r3, [r7, #4]
  406806:	687b      	ldr	r3, [r7, #4]
  406808:	f043 0310 	orr.w	r3, r3, #16
  40680c:	607b      	str	r3, [r7, #4]
  40680e:	4a09      	ldr	r2, [pc, #36]	; (406834 <udd_ctrl_send_zlp_in+0x48>)
  406810:	687b      	ldr	r3, [r7, #4]
  406812:	6313      	str	r3, [r2, #48]	; 0x30
  406814:	bf00      	nop
  406816:	4b07      	ldr	r3, [pc, #28]	; (406834 <udd_ctrl_send_zlp_in+0x48>)
  406818:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40681a:	f003 0310 	and.w	r3, r3, #16
  40681e:	2b10      	cmp	r3, #16
  406820:	d1f9      	bne.n	406816 <udd_ctrl_send_zlp_in+0x2a>
}
  406822:	bf00      	nop
  406824:	370c      	adds	r7, #12
  406826:	46bd      	mov	sp, r7
  406828:	f85d 7b04 	ldr.w	r7, [sp], #4
  40682c:	4770      	bx	lr
  40682e:	bf00      	nop
  406830:	20008835 	.word	0x20008835
  406834:	40084000 	.word	0x40084000

00406838 <udd_ctrl_send_zlp_out>:


static void udd_ctrl_send_zlp_out(void)
{
  406838:	b480      	push	{r7}
  40683a:	af00      	add	r7, sp, #0
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
  40683c:	4b03      	ldr	r3, [pc, #12]	; (40684c <udd_ctrl_send_zlp_out+0x14>)
  40683e:	2204      	movs	r2, #4
  406840:	701a      	strb	r2, [r3, #0]
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free
}
  406842:	bf00      	nop
  406844:	46bd      	mov	sp, r7
  406846:	f85d 7b04 	ldr.w	r7, [sp], #4
  40684a:	4770      	bx	lr
  40684c:	20008835 	.word	0x20008835

00406850 <udd_ctrl_endofrequest>:


static void udd_ctrl_endofrequest(void)
{
  406850:	b580      	push	{r7, lr}
  406852:	af00      	add	r7, sp, #0
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
  406854:	4b04      	ldr	r3, [pc, #16]	; (406868 <udd_ctrl_endofrequest+0x18>)
  406856:	691b      	ldr	r3, [r3, #16]
  406858:	2b00      	cmp	r3, #0
  40685a:	d002      	beq.n	406862 <udd_ctrl_endofrequest+0x12>
		udd_g_ctrlreq.callback();
  40685c:	4b02      	ldr	r3, [pc, #8]	; (406868 <udd_ctrl_endofrequest+0x18>)
  40685e:	691b      	ldr	r3, [r3, #16]
  406860:	4798      	blx	r3
	}
}
  406862:	bf00      	nop
  406864:	bd80      	pop	{r7, pc}
  406866:	bf00      	nop
  406868:	2000896c 	.word	0x2000896c

0040686c <udd_ctrl_interrupt>:


static bool udd_ctrl_interrupt(void)
{
  40686c:	b580      	push	{r7, lr}
  40686e:	b082      	sub	sp, #8
  406870:	af00      	add	r7, sp, #0
	if (!Is_udd_endpoint_interrupt(0))
  406872:	4b24      	ldr	r3, [pc, #144]	; (406904 <udd_ctrl_interrupt+0x98>)
  406874:	69db      	ldr	r3, [r3, #28]
  406876:	f003 0301 	and.w	r3, r3, #1
  40687a:	2b00      	cmp	r3, #0
  40687c:	d101      	bne.n	406882 <udd_ctrl_interrupt+0x16>
		return false; // No interrupt events on control endpoint
  40687e:	2300      	movs	r3, #0
  406880:	e03b      	b.n	4068fa <udd_ctrl_interrupt+0x8e>

	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
  406882:	4b20      	ldr	r3, [pc, #128]	; (406904 <udd_ctrl_interrupt+0x98>)
  406884:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  406886:	f003 0304 	and.w	r3, r3, #4
  40688a:	2b00      	cmp	r3, #0
  40688c:	d003      	beq.n	406896 <udd_ctrl_interrupt+0x2a>
		// SETUP packet received
		udd_ctrl_setup_received();
  40688e:	4b1e      	ldr	r3, [pc, #120]	; (406908 <udd_ctrl_interrupt+0x9c>)
  406890:	4798      	blx	r3
		return true;
  406892:	2301      	movs	r3, #1
  406894:	e031      	b.n	4068fa <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_in_sent(0)) {
  406896:	4b1b      	ldr	r3, [pc, #108]	; (406904 <udd_ctrl_interrupt+0x98>)
  406898:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40689a:	f003 0301 	and.w	r3, r3, #1
  40689e:	2b00      	cmp	r3, #0
  4068a0:	d003      	beq.n	4068aa <udd_ctrl_interrupt+0x3e>
		// IN packet sent
		udd_ctrl_in_sent();
  4068a2:	4b1a      	ldr	r3, [pc, #104]	; (40690c <udd_ctrl_interrupt+0xa0>)
  4068a4:	4798      	blx	r3
		return true;
  4068a6:	2301      	movs	r3, #1
  4068a8:	e027      	b.n	4068fa <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_bank0_received(0)) {
  4068aa:	4b16      	ldr	r3, [pc, #88]	; (406904 <udd_ctrl_interrupt+0x98>)
  4068ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4068ae:	f003 0302 	and.w	r3, r3, #2
  4068b2:	2b00      	cmp	r3, #0
  4068b4:	d003      	beq.n	4068be <udd_ctrl_interrupt+0x52>
		// OUT packet received
		udd_ctrl_out_received();
  4068b6:	4b16      	ldr	r3, [pc, #88]	; (406910 <udd_ctrl_interrupt+0xa4>)
  4068b8:	4798      	blx	r3
		return true;
  4068ba:	2301      	movs	r3, #1
  4068bc:	e01d      	b.n	4068fa <udd_ctrl_interrupt+0x8e>
	}
	if (Is_udd_stall(0)) {
  4068be:	4b11      	ldr	r3, [pc, #68]	; (406904 <udd_ctrl_interrupt+0x98>)
  4068c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4068c2:	f003 0308 	and.w	r3, r3, #8
  4068c6:	2b00      	cmp	r3, #0
  4068c8:	d016      	beq.n	4068f8 <udd_ctrl_interrupt+0x8c>
		// STALLed
		udd_ack_stall(0);
  4068ca:	4b0e      	ldr	r3, [pc, #56]	; (406904 <udd_ctrl_interrupt+0x98>)
  4068cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4068ce:	607b      	str	r3, [r7, #4]
  4068d0:	687b      	ldr	r3, [r7, #4]
  4068d2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4068d6:	607b      	str	r3, [r7, #4]
  4068d8:	687b      	ldr	r3, [r7, #4]
  4068da:	f023 0308 	bic.w	r3, r3, #8
  4068de:	607b      	str	r3, [r7, #4]
  4068e0:	4a08      	ldr	r2, [pc, #32]	; (406904 <udd_ctrl_interrupt+0x98>)
  4068e2:	687b      	ldr	r3, [r7, #4]
  4068e4:	6313      	str	r3, [r2, #48]	; 0x30
  4068e6:	bf00      	nop
  4068e8:	4b06      	ldr	r3, [pc, #24]	; (406904 <udd_ctrl_interrupt+0x98>)
  4068ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4068ec:	f003 0308 	and.w	r3, r3, #8
  4068f0:	2b00      	cmp	r3, #0
  4068f2:	d1f9      	bne.n	4068e8 <udd_ctrl_interrupt+0x7c>
		return true;
  4068f4:	2301      	movs	r3, #1
  4068f6:	e000      	b.n	4068fa <udd_ctrl_interrupt+0x8e>
	}
	return false;
  4068f8:	2300      	movs	r3, #0
}
  4068fa:	4618      	mov	r0, r3
  4068fc:	3708      	adds	r7, #8
  4068fe:	46bd      	mov	sp, r7
  406900:	bd80      	pop	{r7, pc}
  406902:	bf00      	nop
  406904:	40084000 	.word	0x40084000
  406908:	00406195 	.word	0x00406195
  40690c:	00406355 	.word	0x00406355
  406910:	0040654d 	.word	0x0040654d

00406914 <udd_ep_job_table_reset>:
//--- INTERNAL ROUTINES TO MANAGED THE BULK/INTERRUPT/ISOCHRONOUS ENDPOINTS

#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_job_table_reset(void)
{
  406914:	b480      	push	{r7}
  406916:	b083      	sub	sp, #12
  406918:	af00      	add	r7, sp, #0
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  40691a:	2300      	movs	r3, #0
  40691c:	71fb      	strb	r3, [r7, #7]
  40691e:	e043      	b.n	4069a8 <udd_ep_job_table_reset+0x94>
		udd_ep_job[i].bank = 0;
  406920:	79fa      	ldrb	r2, [r7, #7]
  406922:	4926      	ldr	r1, [pc, #152]	; (4069bc <udd_ep_job_table_reset+0xa8>)
  406924:	4613      	mov	r3, r2
  406926:	009b      	lsls	r3, r3, #2
  406928:	4413      	add	r3, r2
  40692a:	009b      	lsls	r3, r3, #2
  40692c:	440b      	add	r3, r1
  40692e:	f103 0210 	add.w	r2, r3, #16
  406932:	7853      	ldrb	r3, [r2, #1]
  406934:	f36f 0383 	bfc	r3, #2, #2
  406938:	7053      	strb	r3, [r2, #1]
		udd_ep_job[i].busy = false;
  40693a:	79fa      	ldrb	r2, [r7, #7]
  40693c:	491f      	ldr	r1, [pc, #124]	; (4069bc <udd_ep_job_table_reset+0xa8>)
  40693e:	4613      	mov	r3, r2
  406940:	009b      	lsls	r3, r3, #2
  406942:	4413      	add	r3, r2
  406944:	009b      	lsls	r3, r3, #2
  406946:	440b      	add	r3, r1
  406948:	f103 0210 	add.w	r2, r3, #16
  40694c:	7853      	ldrb	r3, [r2, #1]
  40694e:	f36f 1304 	bfc	r3, #4, #1
  406952:	7053      	strb	r3, [r2, #1]
		udd_ep_job[i].b_stall_requested = false;
  406954:	79fa      	ldrb	r2, [r7, #7]
  406956:	4919      	ldr	r1, [pc, #100]	; (4069bc <udd_ep_job_table_reset+0xa8>)
  406958:	4613      	mov	r3, r2
  40695a:	009b      	lsls	r3, r3, #2
  40695c:	4413      	add	r3, r2
  40695e:	009b      	lsls	r3, r3, #2
  406960:	440b      	add	r3, r1
  406962:	f103 0210 	add.w	r2, r3, #16
  406966:	7853      	ldrb	r3, [r2, #1]
  406968:	f36f 1345 	bfc	r3, #5, #1
  40696c:	7053      	strb	r3, [r2, #1]
		udd_ep_job[i].b_shortpacket = false;
  40696e:	79fa      	ldrb	r2, [r7, #7]
  406970:	4912      	ldr	r1, [pc, #72]	; (4069bc <udd_ep_job_table_reset+0xa8>)
  406972:	4613      	mov	r3, r2
  406974:	009b      	lsls	r3, r3, #2
  406976:	4413      	add	r3, r2
  406978:	009b      	lsls	r3, r3, #2
  40697a:	440b      	add	r3, r1
  40697c:	f103 0210 	add.w	r2, r3, #16
  406980:	7853      	ldrb	r3, [r2, #1]
  406982:	f36f 1386 	bfc	r3, #6, #1
  406986:	7053      	strb	r3, [r2, #1]
		udd_ep_job[i].b_buf_end = false;
  406988:	79fa      	ldrb	r2, [r7, #7]
  40698a:	490c      	ldr	r1, [pc, #48]	; (4069bc <udd_ep_job_table_reset+0xa8>)
  40698c:	4613      	mov	r3, r2
  40698e:	009b      	lsls	r3, r3, #2
  406990:	4413      	add	r3, r2
  406992:	009b      	lsls	r3, r3, #2
  406994:	440b      	add	r3, r1
  406996:	f103 0210 	add.w	r2, r3, #16
  40699a:	7853      	ldrb	r3, [r2, #1]
  40699c:	f36f 13c7 	bfc	r3, #7, #1
  4069a0:	7053      	strb	r3, [r2, #1]
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  4069a2:	79fb      	ldrb	r3, [r7, #7]
  4069a4:	3301      	adds	r3, #1
  4069a6:	71fb      	strb	r3, [r7, #7]
  4069a8:	79fb      	ldrb	r3, [r7, #7]
  4069aa:	2b02      	cmp	r3, #2
  4069ac:	d9b8      	bls.n	406920 <udd_ep_job_table_reset+0xc>
	}
}
  4069ae:	bf00      	nop
  4069b0:	370c      	adds	r7, #12
  4069b2:	46bd      	mov	sp, r7
  4069b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4069b8:	4770      	bx	lr
  4069ba:	bf00      	nop
  4069bc:	2000883c 	.word	0x2000883c

004069c0 <udd_ep_job_table_kill>:


static void udd_ep_job_table_kill(void)
{
  4069c0:	b580      	push	{r7, lr}
  4069c2:	b082      	sub	sp, #8
  4069c4:	af00      	add	r7, sp, #0
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  4069c6:	2300      	movs	r3, #0
  4069c8:	71fb      	strb	r3, [r7, #7]
  4069ca:	e010      	b.n	4069ee <udd_ep_job_table_kill+0x2e>
		udd_ep_finish_job(&udd_ep_job[i], UDD_EP_TRANSFER_ABORT, i + 1);
  4069cc:	79fa      	ldrb	r2, [r7, #7]
  4069ce:	4613      	mov	r3, r2
  4069d0:	009b      	lsls	r3, r3, #2
  4069d2:	4413      	add	r3, r2
  4069d4:	009b      	lsls	r3, r3, #2
  4069d6:	4a09      	ldr	r2, [pc, #36]	; (4069fc <udd_ep_job_table_kill+0x3c>)
  4069d8:	1898      	adds	r0, r3, r2
  4069da:	79fb      	ldrb	r3, [r7, #7]
  4069dc:	3301      	adds	r3, #1
  4069de:	b2db      	uxtb	r3, r3
  4069e0:	461a      	mov	r2, r3
  4069e2:	2101      	movs	r1, #1
  4069e4:	4b06      	ldr	r3, [pc, #24]	; (406a00 <udd_ep_job_table_kill+0x40>)
  4069e6:	4798      	blx	r3
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
  4069e8:	79fb      	ldrb	r3, [r7, #7]
  4069ea:	3301      	adds	r3, #1
  4069ec:	71fb      	strb	r3, [r7, #7]
  4069ee:	79fb      	ldrb	r3, [r7, #7]
  4069f0:	2b02      	cmp	r3, #2
  4069f2:	d9eb      	bls.n	4069cc <udd_ep_job_table_kill+0xc>
	}
}
  4069f4:	bf00      	nop
  4069f6:	3708      	adds	r7, #8
  4069f8:	46bd      	mov	sp, r7
  4069fa:	bd80      	pop	{r7, pc}
  4069fc:	2000883c 	.word	0x2000883c
  406a00:	00406a41 	.word	0x00406a41

00406a04 <udd_ep_abort_job>:


static void udd_ep_abort_job(udd_ep_id_t ep)
{
  406a04:	b580      	push	{r7, lr}
  406a06:	b082      	sub	sp, #8
  406a08:	af00      	add	r7, sp, #0
  406a0a:	4603      	mov	r3, r0
  406a0c:	71fb      	strb	r3, [r7, #7]
	ep &= USB_EP_ADDR_MASK;
  406a0e:	79fb      	ldrb	r3, [r7, #7]
  406a10:	f003 030f 	and.w	r3, r3, #15
  406a14:	71fb      	strb	r3, [r7, #7]

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], UDD_EP_TRANSFER_ABORT, ep);
  406a16:	79fb      	ldrb	r3, [r7, #7]
  406a18:	1e5a      	subs	r2, r3, #1
  406a1a:	4613      	mov	r3, r2
  406a1c:	009b      	lsls	r3, r3, #2
  406a1e:	4413      	add	r3, r2
  406a20:	009b      	lsls	r3, r3, #2
  406a22:	4a05      	ldr	r2, [pc, #20]	; (406a38 <udd_ep_abort_job+0x34>)
  406a24:	4413      	add	r3, r2
  406a26:	79fa      	ldrb	r2, [r7, #7]
  406a28:	2101      	movs	r1, #1
  406a2a:	4618      	mov	r0, r3
  406a2c:	4b03      	ldr	r3, [pc, #12]	; (406a3c <udd_ep_abort_job+0x38>)
  406a2e:	4798      	blx	r3
}
  406a30:	bf00      	nop
  406a32:	3708      	adds	r7, #8
  406a34:	46bd      	mov	sp, r7
  406a36:	bd80      	pop	{r7, pc}
  406a38:	2000883c 	.word	0x2000883c
  406a3c:	00406a41 	.word	0x00406a41

00406a40 <udd_ep_finish_job>:


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, int status,
		uint8_t ep_num)
{
  406a40:	b580      	push	{r7, lr}
  406a42:	b084      	sub	sp, #16
  406a44:	af00      	add	r7, sp, #0
  406a46:	60f8      	str	r0, [r7, #12]
  406a48:	60b9      	str	r1, [r7, #8]
  406a4a:	4613      	mov	r3, r2
  406a4c:	71fb      	strb	r3, [r7, #7]
	if (ptr_job->busy == false) {
  406a4e:	68fb      	ldr	r3, [r7, #12]
  406a50:	7c5b      	ldrb	r3, [r3, #17]
  406a52:	f003 0310 	and.w	r3, r3, #16
  406a56:	b2db      	uxtb	r3, r3
  406a58:	2b00      	cmp	r3, #0
  406a5a:	d023      	beq.n	406aa4 <udd_ep_finish_job+0x64>
		return; // No on-going job
	}
	ptr_job->busy = false;
  406a5c:	68fa      	ldr	r2, [r7, #12]
  406a5e:	7c53      	ldrb	r3, [r2, #17]
  406a60:	f36f 1304 	bfc	r3, #4, #1
  406a64:	7453      	strb	r3, [r2, #17]
	if (NULL == ptr_job->call_trans) {
  406a66:	68fb      	ldr	r3, [r7, #12]
  406a68:	681b      	ldr	r3, [r3, #0]
  406a6a:	2b00      	cmp	r3, #0
  406a6c:	d01c      	beq.n	406aa8 <udd_ep_finish_job+0x68>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_type_in(ep_num)) {
  406a6e:	4a10      	ldr	r2, [pc, #64]	; (406ab0 <udd_ep_finish_job+0x70>)
  406a70:	79fb      	ldrb	r3, [r7, #7]
  406a72:	330c      	adds	r3, #12
  406a74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406a78:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  406a7c:	2b00      	cmp	r3, #0
  406a7e:	d003      	beq.n	406a88 <udd_ep_finish_job+0x48>
		ep_num |= USB_EP_DIR_IN;
  406a80:	79fb      	ldrb	r3, [r7, #7]
  406a82:	f063 037f 	orn	r3, r3, #127	; 0x7f
  406a86:	71fb      	strb	r3, [r7, #7]
	}	
	ptr_job->call_trans((status == UDD_EP_TRANSFER_ABORT) ?
  406a88:	68fb      	ldr	r3, [r7, #12]
  406a8a:	681b      	ldr	r3, [r3, #0]
  406a8c:	68ba      	ldr	r2, [r7, #8]
  406a8e:	2a01      	cmp	r2, #1
  406a90:	bf0c      	ite	eq
  406a92:	2201      	moveq	r2, #1
  406a94:	2200      	movne	r2, #0
  406a96:	b2d2      	uxtb	r2, r2
  406a98:	4610      	mov	r0, r2
  406a9a:	68fa      	ldr	r2, [r7, #12]
  406a9c:	6891      	ldr	r1, [r2, #8]
  406a9e:	79fa      	ldrb	r2, [r7, #7]
  406aa0:	4798      	blx	r3
  406aa2:	e002      	b.n	406aaa <udd_ep_finish_job+0x6a>
		return; // No on-going job
  406aa4:	bf00      	nop
  406aa6:	e000      	b.n	406aaa <udd_ep_finish_job+0x6a>
		return; // No callback linked to job
  406aa8:	bf00      	nop
		UDD_EP_TRANSFER_ABORT : UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}
  406aaa:	3710      	adds	r7, #16
  406aac:	46bd      	mov	sp, r7
  406aae:	bd80      	pop	{r7, pc}
  406ab0:	40084000 	.word	0x40084000

00406ab4 <udd_ep_ack_out_received>:


static void udd_ep_ack_out_received(udd_ep_id_t ep)
{
  406ab4:	b480      	push	{r7}
  406ab6:	b087      	sub	sp, #28
  406ab8:	af00      	add	r7, sp, #0
  406aba:	4603      	mov	r3, r0
  406abc:	71fb      	strb	r3, [r7, #7]
	bool bank0_received, bank1_received;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  406abe:	79fb      	ldrb	r3, [r7, #7]
  406ac0:	1e5a      	subs	r2, r3, #1
  406ac2:	4613      	mov	r3, r2
  406ac4:	009b      	lsls	r3, r3, #2
  406ac6:	4413      	add	r3, r2
  406ac8:	009b      	lsls	r3, r3, #2
  406aca:	4a45      	ldr	r2, [pc, #276]	; (406be0 <udd_ep_ack_out_received+0x12c>)
  406acc:	4413      	add	r3, r2
  406ace:	617b      	str	r3, [r7, #20]

	bank0_received = Is_udd_bank0_received(ep);
  406ad0:	4a44      	ldr	r2, [pc, #272]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406ad2:	79fb      	ldrb	r3, [r7, #7]
  406ad4:	330c      	adds	r3, #12
  406ad6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406ada:	f003 0302 	and.w	r3, r3, #2
  406ade:	2b00      	cmp	r3, #0
  406ae0:	bf14      	ite	ne
  406ae2:	2301      	movne	r3, #1
  406ae4:	2300      	moveq	r3, #0
  406ae6:	74fb      	strb	r3, [r7, #19]
	bank1_received = Is_udd_bank1_received(ep);
  406ae8:	4a3e      	ldr	r2, [pc, #248]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406aea:	79fb      	ldrb	r3, [r7, #7]
  406aec:	330c      	adds	r3, #12
  406aee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406af2:	f003 0340 	and.w	r3, r3, #64	; 0x40
  406af6:	2b00      	cmp	r3, #0
  406af8:	bf14      	ite	ne
  406afa:	2301      	movne	r3, #1
  406afc:	2300      	moveq	r3, #0
  406afe:	74bb      	strb	r3, [r7, #18]

	if (bank0_received && bank1_received) {
  406b00:	7cfb      	ldrb	r3, [r7, #19]
  406b02:	2b00      	cmp	r3, #0
  406b04:	d002      	beq.n	406b0c <udd_ep_ack_out_received+0x58>
  406b06:	7cbb      	ldrb	r3, [r7, #18]
  406b08:	2b00      	cmp	r3, #0
  406b0a:	d10e      	bne.n	406b2a <udd_ep_ack_out_received+0x76>
		// The only way is to use ptr_job->bank
	} else if (bank0_received) {
  406b0c:	7cfb      	ldrb	r3, [r7, #19]
  406b0e:	2b00      	cmp	r3, #0
  406b10:	d005      	beq.n	406b1e <udd_ep_ack_out_received+0x6a>
		// Must be bank0
		ptr_job->bank = 0;
  406b12:	697a      	ldr	r2, [r7, #20]
  406b14:	7c53      	ldrb	r3, [r2, #17]
  406b16:	f36f 0383 	bfc	r3, #2, #2
  406b1a:	7453      	strb	r3, [r2, #17]
  406b1c:	e005      	b.n	406b2a <udd_ep_ack_out_received+0x76>
	} else {
		// Must be bank1
		ptr_job->bank = 1;
  406b1e:	697a      	ldr	r2, [r7, #20]
  406b20:	7c53      	ldrb	r3, [r2, #17]
  406b22:	2101      	movs	r1, #1
  406b24:	f361 0383 	bfi	r3, r1, #2, #2
  406b28:	7453      	strb	r3, [r2, #17]
	}
	if (ptr_job->bank == 0) {
  406b2a:	697b      	ldr	r3, [r7, #20]
  406b2c:	7c5b      	ldrb	r3, [r3, #17]
  406b2e:	f003 030c 	and.w	r3, r3, #12
  406b32:	b2db      	uxtb	r3, r3
  406b34:	2b00      	cmp	r3, #0
  406b36:	d12a      	bne.n	406b8e <udd_ep_ack_out_received+0xda>
		udd_ack_bank0_received(ep);
  406b38:	4a2a      	ldr	r2, [pc, #168]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406b3a:	79fb      	ldrb	r3, [r7, #7]
  406b3c:	330c      	adds	r3, #12
  406b3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406b42:	60fb      	str	r3, [r7, #12]
  406b44:	68fb      	ldr	r3, [r7, #12]
  406b46:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406b4a:	60fb      	str	r3, [r7, #12]
  406b4c:	68fb      	ldr	r3, [r7, #12]
  406b4e:	f023 0302 	bic.w	r3, r3, #2
  406b52:	60fb      	str	r3, [r7, #12]
  406b54:	4923      	ldr	r1, [pc, #140]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406b56:	79fb      	ldrb	r3, [r7, #7]
  406b58:	68fa      	ldr	r2, [r7, #12]
  406b5a:	330c      	adds	r3, #12
  406b5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406b60:	bf00      	nop
  406b62:	4a20      	ldr	r2, [pc, #128]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406b64:	79fb      	ldrb	r3, [r7, #7]
  406b66:	330c      	adds	r3, #12
  406b68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406b6c:	f003 0302 	and.w	r3, r3, #2
  406b70:	2b00      	cmp	r3, #0
  406b72:	d1f6      	bne.n	406b62 <udd_ep_ack_out_received+0xae>
		if (udd_get_endpoint_bank_max_nbr(ep) > 1) {
  406b74:	79fb      	ldrb	r3, [r7, #7]
  406b76:	2b00      	cmp	r3, #0
  406b78:	d02c      	beq.n	406bd4 <udd_ep_ack_out_received+0x120>
  406b7a:	79fb      	ldrb	r3, [r7, #7]
  406b7c:	2b03      	cmp	r3, #3
  406b7e:	d029      	beq.n	406bd4 <udd_ep_ack_out_received+0x120>
			ptr_job->bank = 1;
  406b80:	697a      	ldr	r2, [r7, #20]
  406b82:	7c53      	ldrb	r3, [r2, #17]
  406b84:	2101      	movs	r1, #1
  406b86:	f361 0383 	bfi	r3, r1, #2, #2
  406b8a:	7453      	strb	r3, [r2, #17]
		}
	} else {
		udd_ack_bank1_received(ep);
		ptr_job->bank = 0;
	}
}
  406b8c:	e022      	b.n	406bd4 <udd_ep_ack_out_received+0x120>
		udd_ack_bank1_received(ep);
  406b8e:	4a15      	ldr	r2, [pc, #84]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406b90:	79fb      	ldrb	r3, [r7, #7]
  406b92:	330c      	adds	r3, #12
  406b94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406b98:	60bb      	str	r3, [r7, #8]
  406b9a:	68bb      	ldr	r3, [r7, #8]
  406b9c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406ba0:	60bb      	str	r3, [r7, #8]
  406ba2:	68bb      	ldr	r3, [r7, #8]
  406ba4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  406ba8:	60bb      	str	r3, [r7, #8]
  406baa:	490e      	ldr	r1, [pc, #56]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406bac:	79fb      	ldrb	r3, [r7, #7]
  406bae:	68ba      	ldr	r2, [r7, #8]
  406bb0:	330c      	adds	r3, #12
  406bb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406bb6:	bf00      	nop
  406bb8:	4a0a      	ldr	r2, [pc, #40]	; (406be4 <udd_ep_ack_out_received+0x130>)
  406bba:	79fb      	ldrb	r3, [r7, #7]
  406bbc:	330c      	adds	r3, #12
  406bbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406bc2:	f003 0340 	and.w	r3, r3, #64	; 0x40
  406bc6:	2b00      	cmp	r3, #0
  406bc8:	d1f6      	bne.n	406bb8 <udd_ep_ack_out_received+0x104>
		ptr_job->bank = 0;
  406bca:	697a      	ldr	r2, [r7, #20]
  406bcc:	7c53      	ldrb	r3, [r2, #17]
  406bce:	f36f 0383 	bfc	r3, #2, #2
  406bd2:	7453      	strb	r3, [r2, #17]
}
  406bd4:	bf00      	nop
  406bd6:	371c      	adds	r7, #28
  406bd8:	46bd      	mov	sp, r7
  406bda:	f85d 7b04 	ldr.w	r7, [sp], #4
  406bde:	4770      	bx	lr
  406be0:	2000883c 	.word	0x2000883c
  406be4:	40084000 	.word	0x40084000

00406be8 <udd_ep_write_fifo>:


static bool udd_ep_write_fifo(udd_ep_id_t ep)
{
  406be8:	b480      	push	{r7}
  406bea:	b089      	sub	sp, #36	; 0x24
  406bec:	af00      	add	r7, sp, #0
  406bee:	4603      	mov	r3, r0
  406bf0:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  406bf2:	79fb      	ldrb	r3, [r7, #7]
  406bf4:	1e5a      	subs	r2, r3, #1
  406bf6:	4613      	mov	r3, r2
  406bf8:	009b      	lsls	r3, r3, #2
  406bfa:	4413      	add	r3, r2
  406bfc:	009b      	lsls	r3, r3, #2
  406bfe:	4a55      	ldr	r2, [pc, #340]	; (406d54 <udd_ep_write_fifo+0x16c>)
  406c00:	4413      	add	r3, r2
  406c02:	613b      	str	r3, [r7, #16]
	uint8_t *ptr_src = &ptr_job->buf[ptr_job->buf_cnt];
  406c04:	693b      	ldr	r3, [r7, #16]
  406c06:	685a      	ldr	r2, [r3, #4]
  406c08:	693b      	ldr	r3, [r7, #16]
  406c0a:	68db      	ldr	r3, [r3, #12]
  406c0c:	4413      	add	r3, r2
  406c0e:	61fb      	str	r3, [r7, #28]
	uint32_t nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
  406c10:	693b      	ldr	r3, [r7, #16]
  406c12:	689a      	ldr	r2, [r3, #8]
  406c14:	693b      	ldr	r3, [r7, #16]
  406c16:	68db      	ldr	r3, [r3, #12]
  406c18:	1ad3      	subs	r3, r2, r3
  406c1a:	60fb      	str	r3, [r7, #12]
	uint32_t pkt_size = ptr_job->size;
  406c1c:	693b      	ldr	r3, [r7, #16]
  406c1e:	8a1b      	ldrh	r3, [r3, #16]
  406c20:	f3c3 0309 	ubfx	r3, r3, #0, #10
  406c24:	b29b      	uxth	r3, r3
  406c26:	61bb      	str	r3, [r7, #24]
	bool is_short_pkt = false;
  406c28:	2300      	movs	r3, #0
  406c2a:	75fb      	strb	r3, [r7, #23]

	// Packet size
	if (nb_remain < pkt_size) {
  406c2c:	68fa      	ldr	r2, [r7, #12]
  406c2e:	69bb      	ldr	r3, [r7, #24]
  406c30:	429a      	cmp	r2, r3
  406c32:	d203      	bcs.n	406c3c <udd_ep_write_fifo+0x54>
		pkt_size = nb_remain;
  406c34:	68fb      	ldr	r3, [r7, #12]
  406c36:	61bb      	str	r3, [r7, #24]
		is_short_pkt = true;
  406c38:	2301      	movs	r3, #1
  406c3a:	75fb      	strb	r3, [r7, #23]
	}

	// Modify job information
	ptr_job->buf_cnt += pkt_size;
  406c3c:	693b      	ldr	r3, [r7, #16]
  406c3e:	68da      	ldr	r2, [r3, #12]
  406c40:	69bb      	ldr	r3, [r7, #24]
  406c42:	441a      	add	r2, r3
  406c44:	693b      	ldr	r3, [r7, #16]
  406c46:	60da      	str	r2, [r3, #12]

	// Speed block data transfer to FIFO (DPRAM)
	for (; pkt_size >= 8; pkt_size -= 8) {
  406c48:	e05a      	b.n	406d00 <udd_ep_write_fifo+0x118>
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406c4a:	4843      	ldr	r0, [pc, #268]	; (406d58 <udd_ep_write_fifo+0x170>)
  406c4c:	79fa      	ldrb	r2, [r7, #7]
  406c4e:	69fb      	ldr	r3, [r7, #28]
  406c50:	1c59      	adds	r1, r3, #1
  406c52:	61f9      	str	r1, [r7, #28]
  406c54:	781b      	ldrb	r3, [r3, #0]
  406c56:	4619      	mov	r1, r3
  406c58:	f102 0314 	add.w	r3, r2, #20
  406c5c:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406c60:	483d      	ldr	r0, [pc, #244]	; (406d58 <udd_ep_write_fifo+0x170>)
  406c62:	79fa      	ldrb	r2, [r7, #7]
  406c64:	69fb      	ldr	r3, [r7, #28]
  406c66:	1c59      	adds	r1, r3, #1
  406c68:	61f9      	str	r1, [r7, #28]
  406c6a:	781b      	ldrb	r3, [r3, #0]
  406c6c:	4619      	mov	r1, r3
  406c6e:	f102 0314 	add.w	r3, r2, #20
  406c72:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406c76:	4838      	ldr	r0, [pc, #224]	; (406d58 <udd_ep_write_fifo+0x170>)
  406c78:	79fa      	ldrb	r2, [r7, #7]
  406c7a:	69fb      	ldr	r3, [r7, #28]
  406c7c:	1c59      	adds	r1, r3, #1
  406c7e:	61f9      	str	r1, [r7, #28]
  406c80:	781b      	ldrb	r3, [r3, #0]
  406c82:	4619      	mov	r1, r3
  406c84:	f102 0314 	add.w	r3, r2, #20
  406c88:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406c8c:	4832      	ldr	r0, [pc, #200]	; (406d58 <udd_ep_write_fifo+0x170>)
  406c8e:	79fa      	ldrb	r2, [r7, #7]
  406c90:	69fb      	ldr	r3, [r7, #28]
  406c92:	1c59      	adds	r1, r3, #1
  406c94:	61f9      	str	r1, [r7, #28]
  406c96:	781b      	ldrb	r3, [r3, #0]
  406c98:	4619      	mov	r1, r3
  406c9a:	f102 0314 	add.w	r3, r2, #20
  406c9e:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406ca2:	482d      	ldr	r0, [pc, #180]	; (406d58 <udd_ep_write_fifo+0x170>)
  406ca4:	79fa      	ldrb	r2, [r7, #7]
  406ca6:	69fb      	ldr	r3, [r7, #28]
  406ca8:	1c59      	adds	r1, r3, #1
  406caa:	61f9      	str	r1, [r7, #28]
  406cac:	781b      	ldrb	r3, [r3, #0]
  406cae:	4619      	mov	r1, r3
  406cb0:	f102 0314 	add.w	r3, r2, #20
  406cb4:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406cb8:	4827      	ldr	r0, [pc, #156]	; (406d58 <udd_ep_write_fifo+0x170>)
  406cba:	79fa      	ldrb	r2, [r7, #7]
  406cbc:	69fb      	ldr	r3, [r7, #28]
  406cbe:	1c59      	adds	r1, r3, #1
  406cc0:	61f9      	str	r1, [r7, #28]
  406cc2:	781b      	ldrb	r3, [r3, #0]
  406cc4:	4619      	mov	r1, r3
  406cc6:	f102 0314 	add.w	r3, r2, #20
  406cca:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406cce:	4822      	ldr	r0, [pc, #136]	; (406d58 <udd_ep_write_fifo+0x170>)
  406cd0:	79fa      	ldrb	r2, [r7, #7]
  406cd2:	69fb      	ldr	r3, [r7, #28]
  406cd4:	1c59      	adds	r1, r3, #1
  406cd6:	61f9      	str	r1, [r7, #28]
  406cd8:	781b      	ldrb	r3, [r3, #0]
  406cda:	4619      	mov	r1, r3
  406cdc:	f102 0314 	add.w	r3, r2, #20
  406ce0:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406ce4:	481c      	ldr	r0, [pc, #112]	; (406d58 <udd_ep_write_fifo+0x170>)
  406ce6:	79fa      	ldrb	r2, [r7, #7]
  406ce8:	69fb      	ldr	r3, [r7, #28]
  406cea:	1c59      	adds	r1, r3, #1
  406cec:	61f9      	str	r1, [r7, #28]
  406cee:	781b      	ldrb	r3, [r3, #0]
  406cf0:	4619      	mov	r1, r3
  406cf2:	f102 0314 	add.w	r3, r2, #20
  406cf6:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for (; pkt_size >= 8; pkt_size -= 8) {
  406cfa:	69bb      	ldr	r3, [r7, #24]
  406cfc:	3b08      	subs	r3, #8
  406cfe:	61bb      	str	r3, [r7, #24]
  406d00:	69bb      	ldr	r3, [r7, #24]
  406d02:	2b07      	cmp	r3, #7
  406d04:	d8a1      	bhi.n	406c4a <udd_ep_write_fifo+0x62>
	}
	// Normal speed data transfer to FIFO (DPRAM)
	for (; pkt_size; pkt_size--) {
  406d06:	e00d      	b.n	406d24 <udd_ep_write_fifo+0x13c>
		udd_endpoint_fifo_write(ep, *ptr_src++);
  406d08:	4813      	ldr	r0, [pc, #76]	; (406d58 <udd_ep_write_fifo+0x170>)
  406d0a:	79fa      	ldrb	r2, [r7, #7]
  406d0c:	69fb      	ldr	r3, [r7, #28]
  406d0e:	1c59      	adds	r1, r3, #1
  406d10:	61f9      	str	r1, [r7, #28]
  406d12:	781b      	ldrb	r3, [r3, #0]
  406d14:	4619      	mov	r1, r3
  406d16:	f102 0314 	add.w	r3, r2, #20
  406d1a:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for (; pkt_size; pkt_size--) {
  406d1e:	69bb      	ldr	r3, [r7, #24]
  406d20:	3b01      	subs	r3, #1
  406d22:	61bb      	str	r3, [r7, #24]
  406d24:	69bb      	ldr	r3, [r7, #24]
  406d26:	2b00      	cmp	r3, #0
  406d28:	d1ee      	bne.n	406d08 <udd_ep_write_fifo+0x120>
	}

	// Add to buffered banks
	ptr_job->bank++;
  406d2a:	693b      	ldr	r3, [r7, #16]
  406d2c:	7c5b      	ldrb	r3, [r3, #17]
  406d2e:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406d32:	b2db      	uxtb	r3, r3
  406d34:	3301      	adds	r3, #1
  406d36:	f003 0303 	and.w	r3, r3, #3
  406d3a:	b2d9      	uxtb	r1, r3
  406d3c:	693a      	ldr	r2, [r7, #16]
  406d3e:	7c53      	ldrb	r3, [r2, #17]
  406d40:	f361 0383 	bfi	r3, r1, #2, #2
  406d44:	7453      	strb	r3, [r2, #17]
	return is_short_pkt;
  406d46:	7dfb      	ldrb	r3, [r7, #23]
}
  406d48:	4618      	mov	r0, r3
  406d4a:	3724      	adds	r7, #36	; 0x24
  406d4c:	46bd      	mov	sp, r7
  406d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406d52:	4770      	bx	lr
  406d54:	2000883c 	.word	0x2000883c
  406d58:	40084000 	.word	0x40084000

00406d5c <udd_ep_in_sent>:


static bool udd_ep_in_sent(udd_ep_id_t ep, bool b_tx)
{
  406d5c:	b580      	push	{r7, lr}
  406d5e:	b086      	sub	sp, #24
  406d60:	af00      	add	r7, sp, #0
  406d62:	4603      	mov	r3, r0
  406d64:	460a      	mov	r2, r1
  406d66:	71fb      	strb	r3, [r7, #7]
  406d68:	4613      	mov	r3, r2
  406d6a:	71bb      	strb	r3, [r7, #6]
	bool b_shortpacket;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  406d6c:	79fb      	ldrb	r3, [r7, #7]
  406d6e:	1e5a      	subs	r2, r3, #1
  406d70:	4613      	mov	r3, r2
  406d72:	009b      	lsls	r3, r3, #2
  406d74:	4413      	add	r3, r2
  406d76:	009b      	lsls	r3, r3, #2
  406d78:	4a36      	ldr	r2, [pc, #216]	; (406e54 <udd_ep_in_sent+0xf8>)
  406d7a:	4413      	add	r3, r2
  406d7c:	617b      	str	r3, [r7, #20]

	// All banks are full
	if (ptr_job->bank >= udd_get_endpoint_bank_max_nbr(ep)) {
  406d7e:	697b      	ldr	r3, [r7, #20]
  406d80:	7c5b      	ldrb	r3, [r3, #17]
  406d82:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406d86:	b2db      	uxtb	r3, r3
  406d88:	461a      	mov	r2, r3
  406d8a:	79fb      	ldrb	r3, [r7, #7]
  406d8c:	2b00      	cmp	r3, #0
  406d8e:	d002      	beq.n	406d96 <udd_ep_in_sent+0x3a>
  406d90:	79fb      	ldrb	r3, [r7, #7]
  406d92:	2b03      	cmp	r3, #3
  406d94:	d101      	bne.n	406d9a <udd_ep_in_sent+0x3e>
  406d96:	2301      	movs	r3, #1
  406d98:	e000      	b.n	406d9c <udd_ep_in_sent+0x40>
  406d9a:	2302      	movs	r3, #2
  406d9c:	429a      	cmp	r2, r3
  406d9e:	db01      	blt.n	406da4 <udd_ep_in_sent+0x48>
		return true; // Data pending
  406da0:	2301      	movs	r3, #1
  406da2:	e052      	b.n	406e4a <udd_ep_in_sent+0xee>
	}

	// No more data in buffer
	if (ptr_job->buf_cnt >= ptr_job->buf_size && !ptr_job->b_shortpacket) {
  406da4:	697b      	ldr	r3, [r7, #20]
  406da6:	68da      	ldr	r2, [r3, #12]
  406da8:	697b      	ldr	r3, [r7, #20]
  406daa:	689b      	ldr	r3, [r3, #8]
  406dac:	429a      	cmp	r2, r3
  406dae:	d308      	bcc.n	406dc2 <udd_ep_in_sent+0x66>
  406db0:	697b      	ldr	r3, [r7, #20]
  406db2:	7c5b      	ldrb	r3, [r3, #17]
  406db4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  406db8:	b2db      	uxtb	r3, r3
  406dba:	2b00      	cmp	r3, #0
  406dbc:	d101      	bne.n	406dc2 <udd_ep_in_sent+0x66>
		return false;
  406dbe:	2300      	movs	r3, #0
  406dc0:	e043      	b.n	406e4a <udd_ep_in_sent+0xee>
	}

	// Fill FIFO
	b_shortpacket = udd_ep_write_fifo(ep);
  406dc2:	79fb      	ldrb	r3, [r7, #7]
  406dc4:	4618      	mov	r0, r3
  406dc6:	4b24      	ldr	r3, [pc, #144]	; (406e58 <udd_ep_in_sent+0xfc>)
  406dc8:	4798      	blx	r3
  406dca:	4603      	mov	r3, r0
  406dcc:	74fb      	strb	r3, [r7, #19]

	// Data is ready to send
	if (b_tx) {
  406dce:	79bb      	ldrb	r3, [r7, #6]
  406dd0:	2b00      	cmp	r3, #0
  406dd2:	d01d      	beq.n	406e10 <udd_ep_in_sent+0xb4>
		udd_set_transmit_ready(ep);
  406dd4:	4a21      	ldr	r2, [pc, #132]	; (406e5c <udd_ep_in_sent+0x100>)
  406dd6:	79fb      	ldrb	r3, [r7, #7]
  406dd8:	330c      	adds	r3, #12
  406dda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406dde:	60fb      	str	r3, [r7, #12]
  406de0:	68fb      	ldr	r3, [r7, #12]
  406de2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  406de6:	60fb      	str	r3, [r7, #12]
  406de8:	68fb      	ldr	r3, [r7, #12]
  406dea:	f043 0310 	orr.w	r3, r3, #16
  406dee:	60fb      	str	r3, [r7, #12]
  406df0:	491a      	ldr	r1, [pc, #104]	; (406e5c <udd_ep_in_sent+0x100>)
  406df2:	79fb      	ldrb	r3, [r7, #7]
  406df4:	68fa      	ldr	r2, [r7, #12]
  406df6:	330c      	adds	r3, #12
  406df8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  406dfc:	bf00      	nop
  406dfe:	4a17      	ldr	r2, [pc, #92]	; (406e5c <udd_ep_in_sent+0x100>)
  406e00:	79fb      	ldrb	r3, [r7, #7]
  406e02:	330c      	adds	r3, #12
  406e04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406e08:	f003 0310 	and.w	r3, r3, #16
  406e0c:	2b10      	cmp	r3, #16
  406e0e:	d1f6      	bne.n	406dfe <udd_ep_in_sent+0xa2>
	}
	// Short PKT? no need to send it again.
	if (b_shortpacket) {
  406e10:	7cfb      	ldrb	r3, [r7, #19]
  406e12:	2b00      	cmp	r3, #0
  406e14:	d004      	beq.n	406e20 <udd_ep_in_sent+0xc4>
		ptr_job->b_shortpacket = false;
  406e16:	697a      	ldr	r2, [r7, #20]
  406e18:	7c53      	ldrb	r3, [r2, #17]
  406e1a:	f36f 1386 	bfc	r3, #6, #1
  406e1e:	7453      	strb	r3, [r2, #17]
	}
	// All transfer done, including ZLP, Finish Job
	if ((ptr_job->buf_cnt >= ptr_job->buf_size)
  406e20:	697b      	ldr	r3, [r7, #20]
  406e22:	68da      	ldr	r2, [r3, #12]
  406e24:	697b      	ldr	r3, [r7, #20]
  406e26:	689b      	ldr	r3, [r3, #8]
  406e28:	429a      	cmp	r2, r3
  406e2a:	d30d      	bcc.n	406e48 <udd_ep_in_sent+0xec>
			&& (!ptr_job->b_shortpacket)) {
  406e2c:	697b      	ldr	r3, [r7, #20]
  406e2e:	7c5b      	ldrb	r3, [r3, #17]
  406e30:	f003 0340 	and.w	r3, r3, #64	; 0x40
  406e34:	b2db      	uxtb	r3, r3
  406e36:	2b00      	cmp	r3, #0
  406e38:	d106      	bne.n	406e48 <udd_ep_in_sent+0xec>
		ptr_job->b_buf_end = true;
  406e3a:	697a      	ldr	r2, [r7, #20]
  406e3c:	7c53      	ldrb	r3, [r2, #17]
  406e3e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  406e42:	7453      	strb	r3, [r2, #17]
		return false;
  406e44:	2300      	movs	r3, #0
  406e46:	e000      	b.n	406e4a <udd_ep_in_sent+0xee>
	}
	return true; // Pending
  406e48:	2301      	movs	r3, #1
}
  406e4a:	4618      	mov	r0, r3
  406e4c:	3718      	adds	r7, #24
  406e4e:	46bd      	mov	sp, r7
  406e50:	bd80      	pop	{r7, pc}
  406e52:	bf00      	nop
  406e54:	2000883c 	.word	0x2000883c
  406e58:	00406be9 	.word	0x00406be9
  406e5c:	40084000 	.word	0x40084000

00406e60 <udd_ep_out_received>:


static void udd_ep_out_received(udd_ep_id_t ep)
{
  406e60:	b580      	push	{r7, lr}
  406e62:	b08a      	sub	sp, #40	; 0x28
  406e64:	af00      	add	r7, sp, #0
  406e66:	4603      	mov	r3, r0
  406e68:	71fb      	strb	r3, [r7, #7]
	udd_ep_job_t *ptr_job = &udd_ep_job[ep - 1];
  406e6a:	79fb      	ldrb	r3, [r7, #7]
  406e6c:	1e5a      	subs	r2, r3, #1
  406e6e:	4613      	mov	r3, r2
  406e70:	009b      	lsls	r3, r3, #2
  406e72:	4413      	add	r3, r2
  406e74:	009b      	lsls	r3, r3, #2
  406e76:	4a3a      	ldr	r2, [pc, #232]	; (406f60 <udd_ep_out_received+0x100>)
  406e78:	4413      	add	r3, r2
  406e7a:	617b      	str	r3, [r7, #20]
	uint32_t nb_data = 0, i;
  406e7c:	2300      	movs	r3, #0
  406e7e:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t nb_remain = ptr_job->buf_size - ptr_job->buf_cnt;
  406e80:	697b      	ldr	r3, [r7, #20]
  406e82:	689a      	ldr	r2, [r3, #8]
  406e84:	697b      	ldr	r3, [r7, #20]
  406e86:	68db      	ldr	r3, [r3, #12]
  406e88:	1ad3      	subs	r3, r2, r3
  406e8a:	613b      	str	r3, [r7, #16]
	uint32_t pkt_size = ptr_job->size;
  406e8c:	697b      	ldr	r3, [r7, #20]
  406e8e:	8a1b      	ldrh	r3, [r3, #16]
  406e90:	f3c3 0309 	ubfx	r3, r3, #0, #10
  406e94:	b29b      	uxth	r3, r3
  406e96:	60fb      	str	r3, [r7, #12]
	uint8_t *ptr_dst = &ptr_job->buf[ptr_job->buf_cnt];
  406e98:	697b      	ldr	r3, [r7, #20]
  406e9a:	685a      	ldr	r2, [r3, #4]
  406e9c:	697b      	ldr	r3, [r7, #20]
  406e9e:	68db      	ldr	r3, [r3, #12]
  406ea0:	4413      	add	r3, r2
  406ea2:	61fb      	str	r3, [r7, #28]
	bool b_full = false, b_short;
  406ea4:	2300      	movs	r3, #0
  406ea6:	76fb      	strb	r3, [r7, #27]

	// Read byte count
	nb_data = udd_byte_count(ep);
  406ea8:	4a2e      	ldr	r2, [pc, #184]	; (406f64 <udd_ep_out_received+0x104>)
  406eaa:	79fb      	ldrb	r3, [r7, #7]
  406eac:	330c      	adds	r3, #12
  406eae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406eb2:	0c1b      	lsrs	r3, r3, #16
  406eb4:	f3c3 030a 	ubfx	r3, r3, #0, #11
  406eb8:	627b      	str	r3, [r7, #36]	; 0x24
	b_short = (nb_data < pkt_size);
  406eba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406ebc:	68fb      	ldr	r3, [r7, #12]
  406ebe:	429a      	cmp	r2, r3
  406ec0:	bf34      	ite	cc
  406ec2:	2301      	movcc	r3, #1
  406ec4:	2300      	movcs	r3, #0
  406ec6:	72fb      	strb	r3, [r7, #11]

	// Copy data if there is
	if (nb_data > 0) {
  406ec8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406eca:	2b00      	cmp	r3, #0
  406ecc:	d021      	beq.n	406f12 <udd_ep_out_received+0xb2>
		if (nb_data >= nb_remain) {
  406ece:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406ed0:	693b      	ldr	r3, [r7, #16]
  406ed2:	429a      	cmp	r2, r3
  406ed4:	d303      	bcc.n	406ede <udd_ep_out_received+0x7e>
			nb_data = nb_remain;
  406ed6:	693b      	ldr	r3, [r7, #16]
  406ed8:	627b      	str	r3, [r7, #36]	; 0x24
			b_full = true;
  406eda:	2301      	movs	r3, #1
  406edc:	76fb      	strb	r3, [r7, #27]
		}
		// Modify job information
		ptr_job->buf_cnt += nb_data;
  406ede:	697b      	ldr	r3, [r7, #20]
  406ee0:	68da      	ldr	r2, [r3, #12]
  406ee2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406ee4:	441a      	add	r2, r3
  406ee6:	697b      	ldr	r3, [r7, #20]
  406ee8:	60da      	str	r2, [r3, #12]

		// Copy FIFO (DPRAM) to buffer
		for (i = 0; i < nb_data; i++) {
  406eea:	2300      	movs	r3, #0
  406eec:	623b      	str	r3, [r7, #32]
  406eee:	e00c      	b.n	406f0a <udd_ep_out_received+0xaa>
			*ptr_dst++ = udd_endpoint_fifo_read(ep);
  406ef0:	69fb      	ldr	r3, [r7, #28]
  406ef2:	1c5a      	adds	r2, r3, #1
  406ef4:	61fa      	str	r2, [r7, #28]
  406ef6:	491b      	ldr	r1, [pc, #108]	; (406f64 <udd_ep_out_received+0x104>)
  406ef8:	79fa      	ldrb	r2, [r7, #7]
  406efa:	3214      	adds	r2, #20
  406efc:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  406f00:	b2d2      	uxtb	r2, r2
  406f02:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < nb_data; i++) {
  406f04:	6a3b      	ldr	r3, [r7, #32]
  406f06:	3301      	adds	r3, #1
  406f08:	623b      	str	r3, [r7, #32]
  406f0a:	6a3a      	ldr	r2, [r7, #32]
  406f0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406f0e:	429a      	cmp	r2, r3
  406f10:	d3ee      	bcc.n	406ef0 <udd_ep_out_received+0x90>
		}
	}
	// Clear FIFO Status
	udd_ep_ack_out_received(ep);
  406f12:	79fb      	ldrb	r3, [r7, #7]
  406f14:	4618      	mov	r0, r3
  406f16:	4b14      	ldr	r3, [pc, #80]	; (406f68 <udd_ep_out_received+0x108>)
  406f18:	4798      	blx	r3
	// Finish job on error or short packet
	if ((b_full || b_short) &&
  406f1a:	7efb      	ldrb	r3, [r7, #27]
  406f1c:	2b00      	cmp	r3, #0
  406f1e:	d102      	bne.n	406f26 <udd_ep_out_received+0xc6>
  406f20:	7afb      	ldrb	r3, [r7, #11]
  406f22:	2b00      	cmp	r3, #0
  406f24:	d018      	beq.n	406f58 <udd_ep_out_received+0xf8>
			!Is_udd_endpoint_stall_requested(ep)) {
  406f26:	4a0f      	ldr	r2, [pc, #60]	; (406f64 <udd_ep_out_received+0x104>)
  406f28:	79fb      	ldrb	r3, [r7, #7]
  406f2a:	330c      	adds	r3, #12
  406f2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406f30:	f003 0320 	and.w	r3, r3, #32
	if ((b_full || b_short) &&
  406f34:	2b00      	cmp	r3, #0
  406f36:	d10f      	bne.n	406f58 <udd_ep_out_received+0xf8>
		udd_disable_endpoint_interrupt(ep);
  406f38:	4a0a      	ldr	r2, [pc, #40]	; (406f64 <udd_ep_out_received+0x104>)
  406f3a:	79fb      	ldrb	r3, [r7, #7]
  406f3c:	2101      	movs	r1, #1
  406f3e:	fa01 f303 	lsl.w	r3, r1, r3
  406f42:	6153      	str	r3, [r2, #20]
		ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  406f44:	697b      	ldr	r3, [r7, #20]
  406f46:	68da      	ldr	r2, [r3, #12]
  406f48:	697b      	ldr	r3, [r7, #20]
  406f4a:	609a      	str	r2, [r3, #8]
		udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  406f4c:	79fb      	ldrb	r3, [r7, #7]
  406f4e:	461a      	mov	r2, r3
  406f50:	2100      	movs	r1, #0
  406f52:	6978      	ldr	r0, [r7, #20]
  406f54:	4b05      	ldr	r3, [pc, #20]	; (406f6c <udd_ep_out_received+0x10c>)
  406f56:	4798      	blx	r3
	}
}
  406f58:	bf00      	nop
  406f5a:	3728      	adds	r7, #40	; 0x28
  406f5c:	46bd      	mov	sp, r7
  406f5e:	bd80      	pop	{r7, pc}
  406f60:	2000883c 	.word	0x2000883c
  406f64:	40084000 	.word	0x40084000
  406f68:	00406ab5 	.word	0x00406ab5
  406f6c:	00406a41 	.word	0x00406a41

00406f70 <udd_ep_interrupt>:


static bool udd_ep_interrupt(void)
{
  406f70:	b580      	push	{r7, lr}
  406f72:	b08e      	sub	sp, #56	; 0x38
  406f74:	af00      	add	r7, sp, #0
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
  406f76:	2301      	movs	r3, #1
  406f78:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  406f7c:	e260      	b.n	407440 <udd_ep_interrupt+0x4d0>
		// Check RXRDY and TXEMPTY event for none DMA endpoints
		if (!Is_udd_endpoint_interrupt_enabled(ep)) {
  406f7e:	4b9e      	ldr	r3, [pc, #632]	; (4071f8 <udd_ep_interrupt+0x288>)
  406f80:	699a      	ldr	r2, [r3, #24]
  406f82:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406f86:	2101      	movs	r1, #1
  406f88:	fa01 f303 	lsl.w	r3, r1, r3
  406f8c:	4013      	ands	r3, r2
  406f8e:	2b00      	cmp	r3, #0
  406f90:	f000 8250 	beq.w	407434 <udd_ep_interrupt+0x4c4>
			continue;
		}

		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
  406f94:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406f98:	1e5a      	subs	r2, r3, #1
  406f9a:	4613      	mov	r3, r2
  406f9c:	009b      	lsls	r3, r3, #2
  406f9e:	4413      	add	r3, r2
  406fa0:	009b      	lsls	r3, r3, #2
  406fa2:	4a96      	ldr	r2, [pc, #600]	; (4071fc <udd_ep_interrupt+0x28c>)
  406fa4:	4413      	add	r3, r2
  406fa6:	633b      	str	r3, [r7, #48]	; 0x30

		// RXOUT: Full packet received
		if (Is_udd_any_bank_received(ep)) {
  406fa8:	4a93      	ldr	r2, [pc, #588]	; (4071f8 <udd_ep_interrupt+0x288>)
  406faa:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406fae:	330c      	adds	r3, #12
  406fb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406fb4:	f003 0342 	and.w	r3, r3, #66	; 0x42
  406fb8:	2b00      	cmp	r3, #0
  406fba:	d006      	beq.n	406fca <udd_ep_interrupt+0x5a>
			udd_ep_out_received(ep);
  406fbc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406fc0:	4618      	mov	r0, r3
  406fc2:	4b8f      	ldr	r3, [pc, #572]	; (407200 <udd_ep_interrupt+0x290>)
  406fc4:	4798      	blx	r3
			return true;
  406fc6:	2301      	movs	r3, #1
  406fc8:	e240      	b.n	40744c <udd_ep_interrupt+0x4dc>
		}
		// TXIN: packet sent
		if (Is_udd_in_sent(ep)) {
  406fca:	4a8b      	ldr	r2, [pc, #556]	; (4071f8 <udd_ep_interrupt+0x288>)
  406fcc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  406fd0:	330c      	adds	r3, #12
  406fd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  406fd6:	f003 0301 	and.w	r3, r3, #1
  406fda:	2b00      	cmp	r3, #0
  406fdc:	f000 81ec 	beq.w	4073b8 <udd_ep_interrupt+0x448>

			ptr_job->bank--;
  406fe0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406fe2:	7c5b      	ldrb	r3, [r3, #17]
  406fe4:	f3c3 0381 	ubfx	r3, r3, #2, #2
  406fe8:	b2db      	uxtb	r3, r3
  406fea:	3303      	adds	r3, #3
  406fec:	f003 0303 	and.w	r3, r3, #3
  406ff0:	b2d9      	uxtb	r1, r3
  406ff2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  406ff4:	7c53      	ldrb	r3, [r2, #17]
  406ff6:	f361 0383 	bfi	r3, r1, #2, #2
  406ffa:	7453      	strb	r3, [r2, #17]
			// Stall when all banks free
			if (ptr_job->b_stall_requested) {
  406ffc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406ffe:	7c5b      	ldrb	r3, [r3, #17]
  407000:	f003 0320 	and.w	r3, r3, #32
  407004:	b2db      	uxtb	r3, r3
  407006:	2b00      	cmp	r3, #0
  407008:	f000 8093 	beq.w	407132 <udd_ep_interrupt+0x1c2>
				if (ptr_job->bank) {
  40700c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40700e:	7c5b      	ldrb	r3, [r3, #17]
  407010:	f003 030c 	and.w	r3, r3, #12
  407014:	b2db      	uxtb	r3, r3
  407016:	2b00      	cmp	r3, #0
  407018:	d042      	beq.n	4070a0 <udd_ep_interrupt+0x130>
					// Send remaining
					udd_set_transmit_ready(ep);
  40701a:	4a77      	ldr	r2, [pc, #476]	; (4071f8 <udd_ep_interrupt+0x288>)
  40701c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407020:	330c      	adds	r3, #12
  407022:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407026:	62bb      	str	r3, [r7, #40]	; 0x28
  407028:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40702a:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40702e:	62bb      	str	r3, [r7, #40]	; 0x28
  407030:	6abb      	ldr	r3, [r7, #40]	; 0x28
  407032:	f043 0310 	orr.w	r3, r3, #16
  407036:	62bb      	str	r3, [r7, #40]	; 0x28
  407038:	496f      	ldr	r1, [pc, #444]	; (4071f8 <udd_ep_interrupt+0x288>)
  40703a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40703e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  407040:	330c      	adds	r3, #12
  407042:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  407046:	bf00      	nop
  407048:	4a6b      	ldr	r2, [pc, #428]	; (4071f8 <udd_ep_interrupt+0x288>)
  40704a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40704e:	330c      	adds	r3, #12
  407050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407054:	f003 0310 	and.w	r3, r3, #16
  407058:	2b10      	cmp	r3, #16
  40705a:	d1f5      	bne.n	407048 <udd_ep_interrupt+0xd8>
					udd_ack_in_sent(ep);
  40705c:	4a66      	ldr	r2, [pc, #408]	; (4071f8 <udd_ep_interrupt+0x288>)
  40705e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407062:	330c      	adds	r3, #12
  407064:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407068:	627b      	str	r3, [r7, #36]	; 0x24
  40706a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40706c:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  407070:	627b      	str	r3, [r7, #36]	; 0x24
  407072:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407074:	f023 0301 	bic.w	r3, r3, #1
  407078:	627b      	str	r3, [r7, #36]	; 0x24
  40707a:	495f      	ldr	r1, [pc, #380]	; (4071f8 <udd_ep_interrupt+0x288>)
  40707c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407080:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407082:	330c      	adds	r3, #12
  407084:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  407088:	bf00      	nop
  40708a:	4a5b      	ldr	r2, [pc, #364]	; (4071f8 <udd_ep_interrupt+0x288>)
  40708c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407090:	330c      	adds	r3, #12
  407092:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407096:	f003 0301 	and.w	r3, r3, #1
  40709a:	2b00      	cmp	r3, #0
  40709c:	d1f5      	bne.n	40708a <udd_ep_interrupt+0x11a>
  40709e:	e046      	b.n	40712e <udd_ep_interrupt+0x1be>
				} else {
					// Ack last packet
					udd_ack_in_sent(ep);
  4070a0:	4a55      	ldr	r2, [pc, #340]	; (4071f8 <udd_ep_interrupt+0x288>)
  4070a2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4070a6:	330c      	adds	r3, #12
  4070a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4070ac:	623b      	str	r3, [r7, #32]
  4070ae:	6a3b      	ldr	r3, [r7, #32]
  4070b0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4070b4:	623b      	str	r3, [r7, #32]
  4070b6:	6a3b      	ldr	r3, [r7, #32]
  4070b8:	f023 0301 	bic.w	r3, r3, #1
  4070bc:	623b      	str	r3, [r7, #32]
  4070be:	494e      	ldr	r1, [pc, #312]	; (4071f8 <udd_ep_interrupt+0x288>)
  4070c0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4070c4:	6a3a      	ldr	r2, [r7, #32]
  4070c6:	330c      	adds	r3, #12
  4070c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4070cc:	bf00      	nop
  4070ce:	4a4a      	ldr	r2, [pc, #296]	; (4071f8 <udd_ep_interrupt+0x288>)
  4070d0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4070d4:	330c      	adds	r3, #12
  4070d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4070da:	f003 0301 	and.w	r3, r3, #1
  4070de:	2b00      	cmp	r3, #0
  4070e0:	d1f5      	bne.n	4070ce <udd_ep_interrupt+0x15e>
					// Enable stall
					udd_enable_stall_handshake(ep);
  4070e2:	4a45      	ldr	r2, [pc, #276]	; (4071f8 <udd_ep_interrupt+0x288>)
  4070e4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4070e8:	330c      	adds	r3, #12
  4070ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4070ee:	61fb      	str	r3, [r7, #28]
  4070f0:	69fb      	ldr	r3, [r7, #28]
  4070f2:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4070f6:	61fb      	str	r3, [r7, #28]
  4070f8:	69fb      	ldr	r3, [r7, #28]
  4070fa:	f043 0320 	orr.w	r3, r3, #32
  4070fe:	61fb      	str	r3, [r7, #28]
  407100:	493d      	ldr	r1, [pc, #244]	; (4071f8 <udd_ep_interrupt+0x288>)
  407102:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407106:	69fa      	ldr	r2, [r7, #28]
  407108:	330c      	adds	r3, #12
  40710a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40710e:	bf00      	nop
  407110:	4a39      	ldr	r2, [pc, #228]	; (4071f8 <udd_ep_interrupt+0x288>)
  407112:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407116:	330c      	adds	r3, #12
  407118:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40711c:	f003 0320 	and.w	r3, r3, #32
  407120:	2b20      	cmp	r3, #32
  407122:	d1f5      	bne.n	407110 <udd_ep_interrupt+0x1a0>
					// Halt executed
					ptr_job->b_stall_requested = false;
  407124:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  407126:	7c53      	ldrb	r3, [r2, #17]
  407128:	f36f 1345 	bfc	r3, #5, #1
  40712c:	7453      	strb	r3, [r2, #17]
				}
				return true;
  40712e:	2301      	movs	r3, #1
  407130:	e18c      	b.n	40744c <udd_ep_interrupt+0x4dc>
			}
			// Finish Job when buffer end
			if (ptr_job->b_buf_end) {
  407132:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  407134:	7c5b      	ldrb	r3, [r3, #17]
  407136:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40713a:	b2db      	uxtb	r3, r3
  40713c:	2b00      	cmp	r3, #0
  40713e:	d016      	beq.n	40716e <udd_ep_interrupt+0x1fe>
				ptr_job->b_buf_end = false;
  407140:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  407142:	7c53      	ldrb	r3, [r2, #17]
  407144:	f36f 13c7 	bfc	r3, #7, #1
  407148:	7453      	strb	r3, [r2, #17]
				ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  40714a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40714c:	68da      	ldr	r2, [r3, #12]
  40714e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  407150:	609a      	str	r2, [r3, #8]
                udd_disable_endpoint_interrupt(ep);
  407152:	4a29      	ldr	r2, [pc, #164]	; (4071f8 <udd_ep_interrupt+0x288>)
  407154:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407158:	2101      	movs	r1, #1
  40715a:	fa01 f303 	lsl.w	r3, r1, r3
  40715e:	6153      	str	r3, [r2, #20]
                udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  407160:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407164:	461a      	mov	r2, r3
  407166:	2100      	movs	r1, #0
  407168:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40716a:	4b26      	ldr	r3, [pc, #152]	; (407204 <udd_ep_interrupt+0x294>)
  40716c:	4798      	blx	r3
			}
			if (ptr_job->buf_cnt >= ptr_job->buf_size &&
  40716e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  407170:	68da      	ldr	r2, [r3, #12]
  407172:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  407174:	689b      	ldr	r3, [r3, #8]
  407176:	429a      	cmp	r2, r3
  407178:	d34a      	bcc.n	407210 <udd_ep_interrupt+0x2a0>
					!ptr_job->b_shortpacket &&
  40717a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40717c:	7c5b      	ldrb	r3, [r3, #17]
  40717e:	f003 0340 	and.w	r3, r3, #64	; 0x40
  407182:	b2db      	uxtb	r3, r3
			if (ptr_job->buf_cnt >= ptr_job->buf_size &&
  407184:	2b00      	cmp	r3, #0
  407186:	d143      	bne.n	407210 <udd_ep_interrupt+0x2a0>
					ptr_job->bank == 0) {
  407188:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40718a:	7c5b      	ldrb	r3, [r3, #17]
  40718c:	f003 030c 	and.w	r3, r3, #12
  407190:	b2db      	uxtb	r3, r3
					!ptr_job->b_shortpacket &&
  407192:	2b00      	cmp	r3, #0
  407194:	d13c      	bne.n	407210 <udd_ep_interrupt+0x2a0>
				// All transfer done, including ZLP
				irqflags_t flags = cpu_irq_save();
  407196:	4b1c      	ldr	r3, [pc, #112]	; (407208 <udd_ep_interrupt+0x298>)
  407198:	4798      	blx	r3
  40719a:	62f8      	str	r0, [r7, #44]	; 0x2c
				udd_disable_endpoint_interrupt(ep);
  40719c:	4a16      	ldr	r2, [pc, #88]	; (4071f8 <udd_ep_interrupt+0x288>)
  40719e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4071a2:	2101      	movs	r1, #1
  4071a4:	fa01 f303 	lsl.w	r3, r1, r3
  4071a8:	6153      	str	r3, [r2, #20]
				cpu_irq_restore(flags);
  4071aa:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  4071ac:	4b17      	ldr	r3, [pc, #92]	; (40720c <udd_ep_interrupt+0x29c>)
  4071ae:	4798      	blx	r3
				// Ack last packet
				udd_ack_in_sent(ep);
  4071b0:	4a11      	ldr	r2, [pc, #68]	; (4071f8 <udd_ep_interrupt+0x288>)
  4071b2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4071b6:	330c      	adds	r3, #12
  4071b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4071bc:	61bb      	str	r3, [r7, #24]
  4071be:	69bb      	ldr	r3, [r7, #24]
  4071c0:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4071c4:	61bb      	str	r3, [r7, #24]
  4071c6:	69bb      	ldr	r3, [r7, #24]
  4071c8:	f023 0301 	bic.w	r3, r3, #1
  4071cc:	61bb      	str	r3, [r7, #24]
  4071ce:	490a      	ldr	r1, [pc, #40]	; (4071f8 <udd_ep_interrupt+0x288>)
  4071d0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4071d4:	69ba      	ldr	r2, [r7, #24]
  4071d6:	330c      	adds	r3, #12
  4071d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4071dc:	bf00      	nop
  4071de:	4a06      	ldr	r2, [pc, #24]	; (4071f8 <udd_ep_interrupt+0x288>)
  4071e0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4071e4:	330c      	adds	r3, #12
  4071e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4071ea:	f003 0301 	and.w	r3, r3, #1
  4071ee:	2b00      	cmp	r3, #0
  4071f0:	d1f5      	bne.n	4071de <udd_ep_interrupt+0x26e>
				return true;
  4071f2:	2301      	movs	r3, #1
  4071f4:	e12a      	b.n	40744c <udd_ep_interrupt+0x4dc>
  4071f6:	bf00      	nop
  4071f8:	40084000 	.word	0x40084000
  4071fc:	2000883c 	.word	0x2000883c
  407200:	00406e61 	.word	0x00406e61
  407204:	00406a41 	.word	0x00406a41
  407208:	00405375 	.word	0x00405375
  40720c:	004053cd 	.word	0x004053cd
			} else if (udd_get_endpoint_bank_max_nbr(ep) > 1
  407210:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407214:	2b00      	cmp	r3, #0
  407216:	d053      	beq.n	4072c0 <udd_ep_interrupt+0x350>
  407218:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40721c:	2b03      	cmp	r3, #3
  40721e:	d04f      	beq.n	4072c0 <udd_ep_interrupt+0x350>
					&& ptr_job->bank > 0) {
  407220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  407222:	7c5b      	ldrb	r3, [r3, #17]
  407224:	f3c3 0381 	ubfx	r3, r3, #2, #2
  407228:	b2db      	uxtb	r3, r3
  40722a:	2b00      	cmp	r3, #0
  40722c:	dd48      	ble.n	4072c0 <udd_ep_interrupt+0x350>
				// Already banks buffered, transmit while loading
				udd_set_transmit_ready(ep);
  40722e:	4a89      	ldr	r2, [pc, #548]	; (407454 <udd_ep_interrupt+0x4e4>)
  407230:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407234:	330c      	adds	r3, #12
  407236:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40723a:	617b      	str	r3, [r7, #20]
  40723c:	697b      	ldr	r3, [r7, #20]
  40723e:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  407242:	617b      	str	r3, [r7, #20]
  407244:	697b      	ldr	r3, [r7, #20]
  407246:	f043 0310 	orr.w	r3, r3, #16
  40724a:	617b      	str	r3, [r7, #20]
  40724c:	4981      	ldr	r1, [pc, #516]	; (407454 <udd_ep_interrupt+0x4e4>)
  40724e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407252:	697a      	ldr	r2, [r7, #20]
  407254:	330c      	adds	r3, #12
  407256:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40725a:	bf00      	nop
  40725c:	4a7d      	ldr	r2, [pc, #500]	; (407454 <udd_ep_interrupt+0x4e4>)
  40725e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407262:	330c      	adds	r3, #12
  407264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407268:	f003 0310 	and.w	r3, r3, #16
  40726c:	2b10      	cmp	r3, #16
  40726e:	d1f5      	bne.n	40725c <udd_ep_interrupt+0x2ec>
				udd_ack_in_sent(ep);
  407270:	4a78      	ldr	r2, [pc, #480]	; (407454 <udd_ep_interrupt+0x4e4>)
  407272:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407276:	330c      	adds	r3, #12
  407278:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40727c:	613b      	str	r3, [r7, #16]
  40727e:	693b      	ldr	r3, [r7, #16]
  407280:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  407284:	613b      	str	r3, [r7, #16]
  407286:	693b      	ldr	r3, [r7, #16]
  407288:	f023 0301 	bic.w	r3, r3, #1
  40728c:	613b      	str	r3, [r7, #16]
  40728e:	4971      	ldr	r1, [pc, #452]	; (407454 <udd_ep_interrupt+0x4e4>)
  407290:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407294:	693a      	ldr	r2, [r7, #16]
  407296:	330c      	adds	r3, #12
  407298:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40729c:	bf00      	nop
  40729e:	4a6d      	ldr	r2, [pc, #436]	; (407454 <udd_ep_interrupt+0x4e4>)
  4072a0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4072a4:	330c      	adds	r3, #12
  4072a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4072aa:	f003 0301 	and.w	r3, r3, #1
  4072ae:	2b00      	cmp	r3, #0
  4072b0:	d1f5      	bne.n	40729e <udd_ep_interrupt+0x32e>
				udd_ep_in_sent(ep, false);
  4072b2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4072b6:	2100      	movs	r1, #0
  4072b8:	4618      	mov	r0, r3
  4072ba:	4b67      	ldr	r3, [pc, #412]	; (407458 <udd_ep_interrupt+0x4e8>)
  4072bc:	4798      	blx	r3
  4072be:	e079      	b.n	4073b4 <udd_ep_interrupt+0x444>
			} else if (udd_get_endpoint_bank_max_nbr(ep) > 1) {
  4072c0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4072c4:	2b00      	cmp	r3, #0
  4072c6:	d04e      	beq.n	407366 <udd_ep_interrupt+0x3f6>
  4072c8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4072cc:	2b03      	cmp	r3, #3
  4072ce:	d04a      	beq.n	407366 <udd_ep_interrupt+0x3f6>
				// Still bank free, load and transmit
				if (!udd_ep_in_sent(ep, true)) {
  4072d0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4072d4:	2101      	movs	r1, #1
  4072d6:	4618      	mov	r0, r3
  4072d8:	4b5f      	ldr	r3, [pc, #380]	; (407458 <udd_ep_interrupt+0x4e8>)
  4072da:	4798      	blx	r3
  4072dc:	4603      	mov	r3, r0
  4072de:	f083 0301 	eor.w	r3, r3, #1
  4072e2:	b2db      	uxtb	r3, r3
  4072e4:	2b00      	cmp	r3, #0
  4072e6:	d016      	beq.n	407316 <udd_ep_interrupt+0x3a6>
					ptr_job->b_buf_end = false;
  4072e8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  4072ea:	7c53      	ldrb	r3, [r2, #17]
  4072ec:	f36f 13c7 	bfc	r3, #7, #1
  4072f0:	7453      	strb	r3, [r2, #17]
					ptr_job->buf_size = ptr_job->buf_cnt; // buf_size is passed to callback as XFR count
  4072f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4072f4:	68da      	ldr	r2, [r3, #12]
  4072f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4072f8:	609a      	str	r2, [r3, #8]
                    udd_disable_endpoint_interrupt(ep);
  4072fa:	4a56      	ldr	r2, [pc, #344]	; (407454 <udd_ep_interrupt+0x4e4>)
  4072fc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407300:	2101      	movs	r1, #1
  407302:	fa01 f303 	lsl.w	r3, r1, r3
  407306:	6153      	str	r3, [r2, #20]
                    udd_ep_finish_job(ptr_job, UDD_EP_TRANSFER_OK, ep);
  407308:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40730c:	461a      	mov	r2, r3
  40730e:	2100      	movs	r1, #0
  407310:	6b38      	ldr	r0, [r7, #48]	; 0x30
  407312:	4b52      	ldr	r3, [pc, #328]	; (40745c <udd_ep_interrupt+0x4ec>)
  407314:	4798      	blx	r3
				}
				udd_ack_in_sent(ep);
  407316:	4a4f      	ldr	r2, [pc, #316]	; (407454 <udd_ep_interrupt+0x4e4>)
  407318:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40731c:	330c      	adds	r3, #12
  40731e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407322:	60fb      	str	r3, [r7, #12]
  407324:	68fb      	ldr	r3, [r7, #12]
  407326:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  40732a:	60fb      	str	r3, [r7, #12]
  40732c:	68fb      	ldr	r3, [r7, #12]
  40732e:	f023 0301 	bic.w	r3, r3, #1
  407332:	60fb      	str	r3, [r7, #12]
  407334:	4947      	ldr	r1, [pc, #284]	; (407454 <udd_ep_interrupt+0x4e4>)
  407336:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40733a:	68fa      	ldr	r2, [r7, #12]
  40733c:	330c      	adds	r3, #12
  40733e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  407342:	bf00      	nop
  407344:	4a43      	ldr	r2, [pc, #268]	; (407454 <udd_ep_interrupt+0x4e4>)
  407346:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40734a:	330c      	adds	r3, #12
  40734c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407350:	f003 0301 	and.w	r3, r3, #1
  407354:	2b00      	cmp	r3, #0
  407356:	d1f5      	bne.n	407344 <udd_ep_interrupt+0x3d4>
				udd_ep_in_sent(ep, false);
  407358:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40735c:	2100      	movs	r1, #0
  40735e:	4618      	mov	r0, r3
  407360:	4b3d      	ldr	r3, [pc, #244]	; (407458 <udd_ep_interrupt+0x4e8>)
  407362:	4798      	blx	r3
  407364:	e026      	b.n	4073b4 <udd_ep_interrupt+0x444>
			} else {
				// Single bank transfer, ack when ready
				udd_ep_in_sent(ep, true);
  407366:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40736a:	2101      	movs	r1, #1
  40736c:	4618      	mov	r0, r3
  40736e:	4b3a      	ldr	r3, [pc, #232]	; (407458 <udd_ep_interrupt+0x4e8>)
  407370:	4798      	blx	r3
				udd_ack_in_sent(ep);
  407372:	4a38      	ldr	r2, [pc, #224]	; (407454 <udd_ep_interrupt+0x4e4>)
  407374:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407378:	330c      	adds	r3, #12
  40737a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40737e:	60bb      	str	r3, [r7, #8]
  407380:	68bb      	ldr	r3, [r7, #8]
  407382:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  407386:	60bb      	str	r3, [r7, #8]
  407388:	68bb      	ldr	r3, [r7, #8]
  40738a:	f023 0301 	bic.w	r3, r3, #1
  40738e:	60bb      	str	r3, [r7, #8]
  407390:	4930      	ldr	r1, [pc, #192]	; (407454 <udd_ep_interrupt+0x4e4>)
  407392:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407396:	68ba      	ldr	r2, [r7, #8]
  407398:	330c      	adds	r3, #12
  40739a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  40739e:	bf00      	nop
  4073a0:	4a2c      	ldr	r2, [pc, #176]	; (407454 <udd_ep_interrupt+0x4e4>)
  4073a2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4073a6:	330c      	adds	r3, #12
  4073a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4073ac:	f003 0301 	and.w	r3, r3, #1
  4073b0:	2b00      	cmp	r3, #0
  4073b2:	d1f5      	bne.n	4073a0 <udd_ep_interrupt+0x430>
			}
			return true;
  4073b4:	2301      	movs	r3, #1
  4073b6:	e049      	b.n	40744c <udd_ep_interrupt+0x4dc>
		}
		// Stall sent/CRC error
		if (Is_udd_stall(ep)) {
  4073b8:	4a26      	ldr	r2, [pc, #152]	; (407454 <udd_ep_interrupt+0x4e4>)
  4073ba:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4073be:	330c      	adds	r3, #12
  4073c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4073c4:	f003 0308 	and.w	r3, r3, #8
  4073c8:	2b00      	cmp	r3, #0
  4073ca:	d034      	beq.n	407436 <udd_ep_interrupt+0x4c6>
			udd_ack_stall(ep);
  4073cc:	4a21      	ldr	r2, [pc, #132]	; (407454 <udd_ep_interrupt+0x4e4>)
  4073ce:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4073d2:	330c      	adds	r3, #12
  4073d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4073d8:	607b      	str	r3, [r7, #4]
  4073da:	687b      	ldr	r3, [r7, #4]
  4073dc:	f043 034f 	orr.w	r3, r3, #79	; 0x4f
  4073e0:	607b      	str	r3, [r7, #4]
  4073e2:	687b      	ldr	r3, [r7, #4]
  4073e4:	f023 0308 	bic.w	r3, r3, #8
  4073e8:	607b      	str	r3, [r7, #4]
  4073ea:	491a      	ldr	r1, [pc, #104]	; (407454 <udd_ep_interrupt+0x4e4>)
  4073ec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  4073f0:	687a      	ldr	r2, [r7, #4]
  4073f2:	330c      	adds	r3, #12
  4073f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  4073f8:	bf00      	nop
  4073fa:	4a16      	ldr	r2, [pc, #88]	; (407454 <udd_ep_interrupt+0x4e4>)
  4073fc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407400:	330c      	adds	r3, #12
  407402:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  407406:	f003 0308 	and.w	r3, r3, #8
  40740a:	2b00      	cmp	r3, #0
  40740c:	d1f5      	bne.n	4073fa <udd_ep_interrupt+0x48a>
			if (udd_get_endpoint_type(ep) == UDP_CSR_EPTYPE_ISO_OUT ||
  40740e:	4a11      	ldr	r2, [pc, #68]	; (407454 <udd_ep_interrupt+0x4e4>)
  407410:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407414:	330c      	adds	r3, #12
  407416:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40741a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  40741e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  407422:	d005      	beq.n	407430 <udd_ep_interrupt+0x4c0>
				udd_get_endpoint_type(ep) == UDP_CSR_EPTYPE_ISO_IN) {
  407424:	4a0b      	ldr	r2, [pc, #44]	; (407454 <udd_ep_interrupt+0x4e4>)
  407426:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40742a:	330c      	adds	r3, #12
  40742c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
			}
			return true;
  407430:	2301      	movs	r3, #1
  407432:	e00b      	b.n	40744c <udd_ep_interrupt+0x4dc>
			continue;
  407434:	bf00      	nop
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
  407436:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40743a:	3301      	adds	r3, #1
  40743c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  407440:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  407444:	2b03      	cmp	r3, #3
  407446:	f67f ad9a 	bls.w	406f7e <udd_ep_interrupt+0xe>
		}
	}
	return false;
  40744a:	2300      	movs	r3, #0
}
  40744c:	4618      	mov	r0, r3
  40744e:	3738      	adds	r7, #56	; 0x38
  407450:	46bd      	mov	sp, r7
  407452:	bd80      	pop	{r7, pc}
  407454:	40084000 	.word	0x40084000
  407458:	00406d5d 	.word	0x00406d5d
  40745c:	00406a41 	.word	0x00406a41

00407460 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  407460:	b480      	push	{r7}
  407462:	b085      	sub	sp, #20
  407464:	af00      	add	r7, sp, #0
  407466:	60f8      	str	r0, [r7, #12]
  407468:	60b9      	str	r1, [r7, #8]
  40746a:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40746c:	687b      	ldr	r3, [r7, #4]
  40746e:	2b00      	cmp	r3, #0
  407470:	d003      	beq.n	40747a <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  407472:	68fb      	ldr	r3, [r7, #12]
  407474:	68ba      	ldr	r2, [r7, #8]
  407476:	665a      	str	r2, [r3, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
	}
}
  407478:	e002      	b.n	407480 <pio_pull_up+0x20>
		p_pio->PIO_PUDR = ul_mask;
  40747a:	68fb      	ldr	r3, [r7, #12]
  40747c:	68ba      	ldr	r2, [r7, #8]
  40747e:	661a      	str	r2, [r3, #96]	; 0x60
}
  407480:	bf00      	nop
  407482:	3714      	adds	r7, #20
  407484:	46bd      	mov	sp, r7
  407486:	f85d 7b04 	ldr.w	r7, [sp], #4
  40748a:	4770      	bx	lr

0040748c <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  40748c:	b580      	push	{r7, lr}
  40748e:	b084      	sub	sp, #16
  407490:	af00      	add	r7, sp, #0
  407492:	60f8      	str	r0, [r7, #12]
  407494:	60b9      	str	r1, [r7, #8]
  407496:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  407498:	68b9      	ldr	r1, [r7, #8]
  40749a:	68f8      	ldr	r0, [r7, #12]
  40749c:	4b19      	ldr	r3, [pc, #100]	; (407504 <pio_set_input+0x78>)
  40749e:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  4074a0:	687b      	ldr	r3, [r7, #4]
  4074a2:	f003 0301 	and.w	r3, r3, #1
  4074a6:	461a      	mov	r2, r3
  4074a8:	68b9      	ldr	r1, [r7, #8]
  4074aa:	68f8      	ldr	r0, [r7, #12]
  4074ac:	4b16      	ldr	r3, [pc, #88]	; (407508 <pio_set_input+0x7c>)
  4074ae:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4074b0:	687b      	ldr	r3, [r7, #4]
  4074b2:	f003 030a 	and.w	r3, r3, #10
  4074b6:	2b00      	cmp	r3, #0
  4074b8:	d003      	beq.n	4074c2 <pio_set_input+0x36>
		p_pio->PIO_IFER = ul_mask;
  4074ba:	68fb      	ldr	r3, [r7, #12]
  4074bc:	68ba      	ldr	r2, [r7, #8]
  4074be:	621a      	str	r2, [r3, #32]
  4074c0:	e002      	b.n	4074c8 <pio_set_input+0x3c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  4074c2:	68fb      	ldr	r3, [r7, #12]
  4074c4:	68ba      	ldr	r2, [r7, #8]
  4074c6:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  4074c8:	687b      	ldr	r3, [r7, #4]
  4074ca:	f003 0302 	and.w	r3, r3, #2
  4074ce:	2b00      	cmp	r3, #0
  4074d0:	d004      	beq.n	4074dc <pio_set_input+0x50>
		p_pio->PIO_IFSCDR = ul_mask;
  4074d2:	68fb      	ldr	r3, [r7, #12]
  4074d4:	68ba      	ldr	r2, [r7, #8]
  4074d6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  4074da:	e008      	b.n	4074ee <pio_set_input+0x62>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  4074dc:	687b      	ldr	r3, [r7, #4]
  4074de:	f003 0308 	and.w	r3, r3, #8
  4074e2:	2b00      	cmp	r3, #0
  4074e4:	d003      	beq.n	4074ee <pio_set_input+0x62>
			p_pio->PIO_IFSCER = ul_mask;
  4074e6:	68fb      	ldr	r3, [r7, #12]
  4074e8:	68ba      	ldr	r2, [r7, #8]
  4074ea:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  4074ee:	68fb      	ldr	r3, [r7, #12]
  4074f0:	68ba      	ldr	r2, [r7, #8]
  4074f2:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  4074f4:	68fb      	ldr	r3, [r7, #12]
  4074f6:	68ba      	ldr	r2, [r7, #8]
  4074f8:	601a      	str	r2, [r3, #0]
}
  4074fa:	bf00      	nop
  4074fc:	3710      	adds	r7, #16
  4074fe:	46bd      	mov	sp, r7
  407500:	bd80      	pop	{r7, pc}
  407502:	bf00      	nop
  407504:	00407595 	.word	0x00407595
  407508:	00407461 	.word	0x00407461

0040750c <pio_configure_interrupt>:
 * \param ul_mask Interrupt source bit map.
 * \param ul_attr Interrupt source attributes.
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
  40750c:	b480      	push	{r7}
  40750e:	b085      	sub	sp, #20
  407510:	af00      	add	r7, sp, #0
  407512:	60f8      	str	r0, [r7, #12]
  407514:	60b9      	str	r1, [r7, #8]
  407516:	607a      	str	r2, [r7, #4]
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  407518:	687b      	ldr	r3, [r7, #4]
  40751a:	f003 0310 	and.w	r3, r3, #16
  40751e:	2b00      	cmp	r3, #0
  407520:	d020      	beq.n	407564 <pio_configure_interrupt+0x58>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  407522:	68fb      	ldr	r3, [r7, #12]
  407524:	68ba      	ldr	r2, [r7, #8]
  407526:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  40752a:	687b      	ldr	r3, [r7, #4]
  40752c:	f003 0320 	and.w	r3, r3, #32
  407530:	2b00      	cmp	r3, #0
  407532:	d004      	beq.n	40753e <pio_configure_interrupt+0x32>
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  407534:	68fb      	ldr	r3, [r7, #12]
  407536:	68ba      	ldr	r2, [r7, #8]
  407538:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  40753c:	e003      	b.n	407546 <pio_configure_interrupt+0x3a>
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  40753e:	68fb      	ldr	r3, [r7, #12]
  407540:	68ba      	ldr	r2, [r7, #8]
  407542:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  407546:	687b      	ldr	r3, [r7, #4]
  407548:	f003 0340 	and.w	r3, r3, #64	; 0x40
  40754c:	2b00      	cmp	r3, #0
  40754e:	d004      	beq.n	40755a <pio_configure_interrupt+0x4e>
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  407550:	68fb      	ldr	r3, [r7, #12]
  407552:	68ba      	ldr	r2, [r7, #8]
  407554:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
	}
}
  407558:	e008      	b.n	40756c <pio_configure_interrupt+0x60>
			p_pio->PIO_LSR = ul_mask;
  40755a:	68fb      	ldr	r3, [r7, #12]
  40755c:	68ba      	ldr	r2, [r7, #8]
  40755e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
  407562:	e003      	b.n	40756c <pio_configure_interrupt+0x60>
		p_pio->PIO_AIMDR = ul_mask;
  407564:	68fb      	ldr	r3, [r7, #12]
  407566:	68ba      	ldr	r2, [r7, #8]
  407568:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  40756c:	bf00      	nop
  40756e:	3714      	adds	r7, #20
  407570:	46bd      	mov	sp, r7
  407572:	f85d 7b04 	ldr.w	r7, [sp], #4
  407576:	4770      	bx	lr

00407578 <pio_enable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  407578:	b480      	push	{r7}
  40757a:	b083      	sub	sp, #12
  40757c:	af00      	add	r7, sp, #0
  40757e:	6078      	str	r0, [r7, #4]
  407580:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IER = ul_mask;
  407582:	687b      	ldr	r3, [r7, #4]
  407584:	683a      	ldr	r2, [r7, #0]
  407586:	641a      	str	r2, [r3, #64]	; 0x40
}
  407588:	bf00      	nop
  40758a:	370c      	adds	r7, #12
  40758c:	46bd      	mov	sp, r7
  40758e:	f85d 7b04 	ldr.w	r7, [sp], #4
  407592:	4770      	bx	lr

00407594 <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  407594:	b480      	push	{r7}
  407596:	b083      	sub	sp, #12
  407598:	af00      	add	r7, sp, #0
  40759a:	6078      	str	r0, [r7, #4]
  40759c:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  40759e:	687b      	ldr	r3, [r7, #4]
  4075a0:	683a      	ldr	r2, [r7, #0]
  4075a2:	645a      	str	r2, [r3, #68]	; 0x44
}
  4075a4:	bf00      	nop
  4075a6:	370c      	adds	r7, #12
  4075a8:	46bd      	mov	sp, r7
  4075aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4075ae:	4770      	bx	lr

004075b0 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  4075b0:	b480      	push	{r7}
  4075b2:	b083      	sub	sp, #12
  4075b4:	af00      	add	r7, sp, #0
  4075b6:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  4075b8:	687b      	ldr	r3, [r7, #4]
  4075ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  4075bc:	4618      	mov	r0, r3
  4075be:	370c      	adds	r7, #12
  4075c0:	46bd      	mov	sp, r7
  4075c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4075c6:	4770      	bx	lr

004075c8 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  4075c8:	b480      	push	{r7}
  4075ca:	b083      	sub	sp, #12
  4075cc:	af00      	add	r7, sp, #0
  4075ce:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  4075d0:	687b      	ldr	r3, [r7, #4]
  4075d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  4075d4:	4618      	mov	r0, r3
  4075d6:	370c      	adds	r7, #12
  4075d8:	46bd      	mov	sp, r7
  4075da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4075de:	4770      	bx	lr

004075e0 <osc_enable>:
{
  4075e0:	b580      	push	{r7, lr}
  4075e2:	b082      	sub	sp, #8
  4075e4:	af00      	add	r7, sp, #0
  4075e6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4075e8:	687b      	ldr	r3, [r7, #4]
  4075ea:	2b07      	cmp	r3, #7
  4075ec:	d831      	bhi.n	407652 <osc_enable+0x72>
  4075ee:	a201      	add	r2, pc, #4	; (adr r2, 4075f4 <osc_enable+0x14>)
  4075f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4075f4:	00407651 	.word	0x00407651
  4075f8:	00407615 	.word	0x00407615
  4075fc:	0040761d 	.word	0x0040761d
  407600:	00407625 	.word	0x00407625
  407604:	0040762d 	.word	0x0040762d
  407608:	00407635 	.word	0x00407635
  40760c:	0040763d 	.word	0x0040763d
  407610:	00407647 	.word	0x00407647
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  407614:	2000      	movs	r0, #0
  407616:	4b11      	ldr	r3, [pc, #68]	; (40765c <osc_enable+0x7c>)
  407618:	4798      	blx	r3
		break;
  40761a:	e01a      	b.n	407652 <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  40761c:	2001      	movs	r0, #1
  40761e:	4b0f      	ldr	r3, [pc, #60]	; (40765c <osc_enable+0x7c>)
  407620:	4798      	blx	r3
		break;
  407622:	e016      	b.n	407652 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  407624:	2000      	movs	r0, #0
  407626:	4b0e      	ldr	r3, [pc, #56]	; (407660 <osc_enable+0x80>)
  407628:	4798      	blx	r3
		break;
  40762a:	e012      	b.n	407652 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  40762c:	2010      	movs	r0, #16
  40762e:	4b0c      	ldr	r3, [pc, #48]	; (407660 <osc_enable+0x80>)
  407630:	4798      	blx	r3
		break;
  407632:	e00e      	b.n	407652 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  407634:	2020      	movs	r0, #32
  407636:	4b0a      	ldr	r3, [pc, #40]	; (407660 <osc_enable+0x80>)
  407638:	4798      	blx	r3
		break;
  40763a:	e00a      	b.n	407652 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  40763c:	213e      	movs	r1, #62	; 0x3e
  40763e:	2000      	movs	r0, #0
  407640:	4b08      	ldr	r3, [pc, #32]	; (407664 <osc_enable+0x84>)
  407642:	4798      	blx	r3
		break;
  407644:	e005      	b.n	407652 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  407646:	213e      	movs	r1, #62	; 0x3e
  407648:	2001      	movs	r0, #1
  40764a:	4b06      	ldr	r3, [pc, #24]	; (407664 <osc_enable+0x84>)
  40764c:	4798      	blx	r3
		break;
  40764e:	e000      	b.n	407652 <osc_enable+0x72>
		break;
  407650:	bf00      	nop
}
  407652:	bf00      	nop
  407654:	3708      	adds	r7, #8
  407656:	46bd      	mov	sp, r7
  407658:	bd80      	pop	{r7, pc}
  40765a:	bf00      	nop
  40765c:	00408095 	.word	0x00408095
  407660:	00408101 	.word	0x00408101
  407664:	00408171 	.word	0x00408171

00407668 <osc_is_ready>:
{
  407668:	b580      	push	{r7, lr}
  40766a:	b082      	sub	sp, #8
  40766c:	af00      	add	r7, sp, #0
  40766e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  407670:	687b      	ldr	r3, [r7, #4]
  407672:	2b07      	cmp	r3, #7
  407674:	d826      	bhi.n	4076c4 <osc_is_ready+0x5c>
  407676:	a201      	add	r2, pc, #4	; (adr r2, 40767c <osc_is_ready+0x14>)
  407678:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40767c:	0040769d 	.word	0x0040769d
  407680:	004076a1 	.word	0x004076a1
  407684:	004076a1 	.word	0x004076a1
  407688:	004076b3 	.word	0x004076b3
  40768c:	004076b3 	.word	0x004076b3
  407690:	004076b3 	.word	0x004076b3
  407694:	004076b3 	.word	0x004076b3
  407698:	004076b3 	.word	0x004076b3
		return 1;
  40769c:	2301      	movs	r3, #1
  40769e:	e012      	b.n	4076c6 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  4076a0:	4b0b      	ldr	r3, [pc, #44]	; (4076d0 <osc_is_ready+0x68>)
  4076a2:	4798      	blx	r3
  4076a4:	4603      	mov	r3, r0
  4076a6:	2b00      	cmp	r3, #0
  4076a8:	bf14      	ite	ne
  4076aa:	2301      	movne	r3, #1
  4076ac:	2300      	moveq	r3, #0
  4076ae:	b2db      	uxtb	r3, r3
  4076b0:	e009      	b.n	4076c6 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  4076b2:	4b08      	ldr	r3, [pc, #32]	; (4076d4 <osc_is_ready+0x6c>)
  4076b4:	4798      	blx	r3
  4076b6:	4603      	mov	r3, r0
  4076b8:	2b00      	cmp	r3, #0
  4076ba:	bf14      	ite	ne
  4076bc:	2301      	movne	r3, #1
  4076be:	2300      	moveq	r3, #0
  4076c0:	b2db      	uxtb	r3, r3
  4076c2:	e000      	b.n	4076c6 <osc_is_ready+0x5e>
	return 0;
  4076c4:	2300      	movs	r3, #0
}
  4076c6:	4618      	mov	r0, r3
  4076c8:	3708      	adds	r7, #8
  4076ca:	46bd      	mov	sp, r7
  4076cc:	bd80      	pop	{r7, pc}
  4076ce:	bf00      	nop
  4076d0:	004080cd 	.word	0x004080cd
  4076d4:	004081e9 	.word	0x004081e9

004076d8 <osc_get_rate>:
{
  4076d8:	b480      	push	{r7}
  4076da:	b083      	sub	sp, #12
  4076dc:	af00      	add	r7, sp, #0
  4076de:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4076e0:	687b      	ldr	r3, [r7, #4]
  4076e2:	2b07      	cmp	r3, #7
  4076e4:	d825      	bhi.n	407732 <osc_get_rate+0x5a>
  4076e6:	a201      	add	r2, pc, #4	; (adr r2, 4076ec <osc_get_rate+0x14>)
  4076e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4076ec:	0040770d 	.word	0x0040770d
  4076f0:	00407713 	.word	0x00407713
  4076f4:	00407719 	.word	0x00407719
  4076f8:	0040771f 	.word	0x0040771f
  4076fc:	00407723 	.word	0x00407723
  407700:	00407727 	.word	0x00407727
  407704:	0040772b 	.word	0x0040772b
  407708:	0040772f 	.word	0x0040772f
		return OSC_SLCK_32K_RC_HZ;
  40770c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  407710:	e010      	b.n	407734 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  407712:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  407716:	e00d      	b.n	407734 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  407718:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40771c:	e00a      	b.n	407734 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40771e:	4b08      	ldr	r3, [pc, #32]	; (407740 <osc_get_rate+0x68>)
  407720:	e008      	b.n	407734 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  407722:	4b08      	ldr	r3, [pc, #32]	; (407744 <osc_get_rate+0x6c>)
  407724:	e006      	b.n	407734 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  407726:	4b08      	ldr	r3, [pc, #32]	; (407748 <osc_get_rate+0x70>)
  407728:	e004      	b.n	407734 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  40772a:	4b07      	ldr	r3, [pc, #28]	; (407748 <osc_get_rate+0x70>)
  40772c:	e002      	b.n	407734 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40772e:	4b06      	ldr	r3, [pc, #24]	; (407748 <osc_get_rate+0x70>)
  407730:	e000      	b.n	407734 <osc_get_rate+0x5c>
	return 0;
  407732:	2300      	movs	r3, #0
}
  407734:	4618      	mov	r0, r3
  407736:	370c      	adds	r7, #12
  407738:	46bd      	mov	sp, r7
  40773a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40773e:	4770      	bx	lr
  407740:	003d0900 	.word	0x003d0900
  407744:	007a1200 	.word	0x007a1200
  407748:	00b71b00 	.word	0x00b71b00

0040774c <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  40774c:	b580      	push	{r7, lr}
  40774e:	b082      	sub	sp, #8
  407750:	af00      	add	r7, sp, #0
  407752:	4603      	mov	r3, r0
  407754:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  407756:	bf00      	nop
  407758:	79fb      	ldrb	r3, [r7, #7]
  40775a:	4618      	mov	r0, r3
  40775c:	4b05      	ldr	r3, [pc, #20]	; (407774 <osc_wait_ready+0x28>)
  40775e:	4798      	blx	r3
  407760:	4603      	mov	r3, r0
  407762:	f083 0301 	eor.w	r3, r3, #1
  407766:	b2db      	uxtb	r3, r3
  407768:	2b00      	cmp	r3, #0
  40776a:	d1f5      	bne.n	407758 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  40776c:	bf00      	nop
  40776e:	3708      	adds	r7, #8
  407770:	46bd      	mov	sp, r7
  407772:	bd80      	pop	{r7, pc}
  407774:	00407669 	.word	0x00407669

00407778 <pll_config_init>:
 * hardware mul+1 is hidden in this implementation. Use mul as mul effective
 * value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  407778:	b580      	push	{r7, lr}
  40777a:	b086      	sub	sp, #24
  40777c:	af00      	add	r7, sp, #0
  40777e:	60f8      	str	r0, [r7, #12]
  407780:	607a      	str	r2, [r7, #4]
  407782:	603b      	str	r3, [r7, #0]
  407784:	460b      	mov	r3, r1
  407786:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  407788:	7afb      	ldrb	r3, [r7, #11]
  40778a:	4618      	mov	r0, r3
  40778c:	4b0d      	ldr	r3, [pc, #52]	; (4077c4 <pll_config_init+0x4c>)
  40778e:	4798      	blx	r3
  407790:	4602      	mov	r2, r0
  407792:	687b      	ldr	r3, [r7, #4]
  407794:	fbb2 f3f3 	udiv	r3, r2, r3
  407798:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);

	vco_hz *= ul_mul;
  40779a:	697b      	ldr	r3, [r7, #20]
  40779c:	683a      	ldr	r2, [r7, #0]
  40779e:	fb02 f303 	mul.w	r3, r2, r3
  4077a2:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | \
  4077a4:	683b      	ldr	r3, [r7, #0]
  4077a6:	3b01      	subs	r3, #1
  4077a8:	041a      	lsls	r2, r3, #16
  4077aa:	4b07      	ldr	r3, [pc, #28]	; (4077c8 <pll_config_init+0x50>)
  4077ac:	4013      	ands	r3, r2
  4077ae:	687a      	ldr	r2, [r7, #4]
  4077b0:	b2d2      	uxtb	r2, r2
  4077b2:	4313      	orrs	r3, r2
  4077b4:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  4077b8:	68fb      	ldr	r3, [r7, #12]
  4077ba:	601a      	str	r2, [r3, #0]
			CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
}
  4077bc:	bf00      	nop
  4077be:	3718      	adds	r7, #24
  4077c0:	46bd      	mov	sp, r7
  4077c2:	bd80      	pop	{r7, pc}
  4077c4:	004076d9 	.word	0x004076d9
  4077c8:	07ff0000 	.word	0x07ff0000

004077cc <pll_enable>:
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  4077cc:	b580      	push	{r7, lr}
  4077ce:	b082      	sub	sp, #8
  4077d0:	af00      	add	r7, sp, #0
  4077d2:	6078      	str	r0, [r7, #4]
  4077d4:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  4077d6:	683b      	ldr	r3, [r7, #0]
  4077d8:	2b00      	cmp	r3, #0
  4077da:	d107      	bne.n	4077ec <pll_enable+0x20>
		pmc_disable_pllack(); // Always stop PLL first!
  4077dc:	4b05      	ldr	r3, [pc, #20]	; (4077f4 <pll_enable+0x28>)
  4077de:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4077e0:	4a05      	ldr	r2, [pc, #20]	; (4077f8 <pll_enable+0x2c>)
  4077e2:	687b      	ldr	r3, [r7, #4]
  4077e4:	681b      	ldr	r3, [r3, #0]
  4077e6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  4077ea:	6293      	str	r3, [r2, #40]	; 0x28
	}
}
  4077ec:	bf00      	nop
  4077ee:	3708      	adds	r7, #8
  4077f0:	46bd      	mov	sp, r7
  4077f2:	bd80      	pop	{r7, pc}
  4077f4:	00408205 	.word	0x00408205
  4077f8:	400e0400 	.word	0x400e0400

004077fc <pll_is_locked>:
		pmc_disable_pllack();
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  4077fc:	b580      	push	{r7, lr}
  4077fe:	b082      	sub	sp, #8
  407800:	af00      	add	r7, sp, #0
  407802:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  407804:	4b03      	ldr	r3, [pc, #12]	; (407814 <pll_is_locked+0x18>)
  407806:	4798      	blx	r3
  407808:	4603      	mov	r3, r0
}
  40780a:	4618      	mov	r0, r3
  40780c:	3708      	adds	r7, #8
  40780e:	46bd      	mov	sp, r7
  407810:	bd80      	pop	{r7, pc}
  407812:	bf00      	nop
  407814:	00408221 	.word	0x00408221

00407818 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  407818:	b580      	push	{r7, lr}
  40781a:	b082      	sub	sp, #8
  40781c:	af00      	add	r7, sp, #0
  40781e:	4603      	mov	r3, r0
  407820:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  407822:	79fb      	ldrb	r3, [r7, #7]
  407824:	3b03      	subs	r3, #3
  407826:	2b04      	cmp	r3, #4
  407828:	d808      	bhi.n	40783c <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  40782a:	79fb      	ldrb	r3, [r7, #7]
  40782c:	4618      	mov	r0, r3
  40782e:	4b06      	ldr	r3, [pc, #24]	; (407848 <pll_enable_source+0x30>)
  407830:	4798      	blx	r3
		osc_wait_ready(e_src);
  407832:	79fb      	ldrb	r3, [r7, #7]
  407834:	4618      	mov	r0, r3
  407836:	4b05      	ldr	r3, [pc, #20]	; (40784c <pll_enable_source+0x34>)
  407838:	4798      	blx	r3
		break;
  40783a:	e000      	b.n	40783e <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  40783c:	bf00      	nop
	}
}
  40783e:	bf00      	nop
  407840:	3708      	adds	r7, #8
  407842:	46bd      	mov	sp, r7
  407844:	bd80      	pop	{r7, pc}
  407846:	bf00      	nop
  407848:	004075e1 	.word	0x004075e1
  40784c:	0040774d 	.word	0x0040774d

00407850 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  407850:	b580      	push	{r7, lr}
  407852:	b082      	sub	sp, #8
  407854:	af00      	add	r7, sp, #0
  407856:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  407858:	bf00      	nop
  40785a:	6878      	ldr	r0, [r7, #4]
  40785c:	4b04      	ldr	r3, [pc, #16]	; (407870 <pll_wait_for_lock+0x20>)
  40785e:	4798      	blx	r3
  407860:	4603      	mov	r3, r0
  407862:	2b00      	cmp	r3, #0
  407864:	d0f9      	beq.n	40785a <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  407866:	2300      	movs	r3, #0
}
  407868:	4618      	mov	r0, r3
  40786a:	3708      	adds	r7, #8
  40786c:	46bd      	mov	sp, r7
  40786e:	bd80      	pop	{r7, pc}
  407870:	004077fd 	.word	0x004077fd

00407874 <sysclk_get_main_hz>:
{
  407874:	b580      	push	{r7, lr}
  407876:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  407878:	2006      	movs	r0, #6
  40787a:	4b03      	ldr	r3, [pc, #12]	; (407888 <sysclk_get_main_hz+0x14>)
  40787c:	4798      	blx	r3
  40787e:	4603      	mov	r3, r0
  407880:	011b      	lsls	r3, r3, #4
}
  407882:	4618      	mov	r0, r3
  407884:	bd80      	pop	{r7, pc}
  407886:	bf00      	nop
  407888:	004076d9 	.word	0x004076d9

0040788c <sysclk_get_cpu_hz>:
{
  40788c:	b580      	push	{r7, lr}
  40788e:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  407890:	4b02      	ldr	r3, [pc, #8]	; (40789c <sysclk_get_cpu_hz+0x10>)
  407892:	4798      	blx	r3
  407894:	4603      	mov	r3, r0
  407896:	085b      	lsrs	r3, r3, #1
}
  407898:	4618      	mov	r0, r3
  40789a:	bd80      	pop	{r7, pc}
  40789c:	00407875 	.word	0x00407875

004078a0 <sysclk_enable_usb>:
 *
 * \param pll_id Source of the USB clock.
 * \param div Actual clock divisor. Must be superior to 0.
 */
void sysclk_enable_usb(void)
{
  4078a0:	b590      	push	{r4, r7, lr}
  4078a2:	b083      	sub	sp, #12
  4078a4:	af00      	add	r7, sp, #0

#ifdef CONFIG_PLL0_SOURCE
	if (CONFIG_USBCLK_SOURCE == USBCLK_SRC_PLL0) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  4078a6:	2006      	movs	r0, #6
  4078a8:	4b0c      	ldr	r3, [pc, #48]	; (4078dc <sysclk_enable_usb+0x3c>)
  4078aa:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  4078ac:	1d38      	adds	r0, r7, #4
  4078ae:	2310      	movs	r3, #16
  4078b0:	2201      	movs	r2, #1
  4078b2:	2106      	movs	r1, #6
  4078b4:	4c0a      	ldr	r4, [pc, #40]	; (4078e0 <sysclk_enable_usb+0x40>)
  4078b6:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  4078b8:	1d3b      	adds	r3, r7, #4
  4078ba:	2100      	movs	r1, #0
  4078bc:	4618      	mov	r0, r3
  4078be:	4b09      	ldr	r3, [pc, #36]	; (4078e4 <sysclk_enable_usb+0x44>)
  4078c0:	4798      	blx	r3
		pll_wait_for_lock(0);
  4078c2:	2000      	movs	r0, #0
  4078c4:	4b08      	ldr	r3, [pc, #32]	; (4078e8 <sysclk_enable_usb+0x48>)
  4078c6:	4798      	blx	r3
		pmc_switch_udpck_to_pllack(CONFIG_USBCLK_DIV - 1);
  4078c8:	2003      	movs	r0, #3
  4078ca:	4b08      	ldr	r3, [pc, #32]	; (4078ec <sysclk_enable_usb+0x4c>)
  4078cc:	4798      	blx	r3
		pmc_enable_udpck();
  4078ce:	4b08      	ldr	r3, [pc, #32]	; (4078f0 <sysclk_enable_usb+0x50>)
  4078d0:	4798      	blx	r3
		return;
  4078d2:	bf00      	nop
	}
#endif
}
  4078d4:	370c      	adds	r7, #12
  4078d6:	46bd      	mov	sp, r7
  4078d8:	bd90      	pop	{r4, r7, pc}
  4078da:	bf00      	nop
  4078dc:	00407819 	.word	0x00407819
  4078e0:	00407779 	.word	0x00407779
  4078e4:	004077cd 	.word	0x004077cd
  4078e8:	00407851 	.word	0x00407851
  4078ec:	00408345 	.word	0x00408345
  4078f0:	00408369 	.word	0x00408369

004078f4 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  4078f4:	b590      	push	{r4, r7, lr}
  4078f6:	b083      	sub	sp, #12
  4078f8:	af00      	add	r7, sp, #0
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  4078fa:	4811      	ldr	r0, [pc, #68]	; (407940 <sysclk_init+0x4c>)
  4078fc:	4b11      	ldr	r3, [pc, #68]	; (407944 <sysclk_init+0x50>)
  4078fe:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  407900:	2006      	movs	r0, #6
  407902:	4b11      	ldr	r3, [pc, #68]	; (407948 <sysclk_init+0x54>)
  407904:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  407906:	1d38      	adds	r0, r7, #4
  407908:	2310      	movs	r3, #16
  40790a:	2201      	movs	r2, #1
  40790c:	2106      	movs	r1, #6
  40790e:	4c0f      	ldr	r4, [pc, #60]	; (40794c <sysclk_init+0x58>)
  407910:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  407912:	1d3b      	adds	r3, r7, #4
  407914:	2100      	movs	r1, #0
  407916:	4618      	mov	r0, r3
  407918:	4b0d      	ldr	r3, [pc, #52]	; (407950 <sysclk_init+0x5c>)
  40791a:	4798      	blx	r3
		pll_wait_for_lock(0);
  40791c:	2000      	movs	r0, #0
  40791e:	4b0d      	ldr	r3, [pc, #52]	; (407954 <sysclk_init+0x60>)
  407920:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  407922:	2010      	movs	r0, #16
  407924:	4b0c      	ldr	r3, [pc, #48]	; (407958 <sysclk_init+0x64>)
  407926:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  407928:	4b0c      	ldr	r3, [pc, #48]	; (40795c <sysclk_init+0x68>)
  40792a:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40792c:	4b0c      	ldr	r3, [pc, #48]	; (407960 <sysclk_init+0x6c>)
  40792e:	4798      	blx	r3
  407930:	4603      	mov	r3, r0
  407932:	4618      	mov	r0, r3
  407934:	4b03      	ldr	r3, [pc, #12]	; (407944 <sysclk_init+0x50>)
  407936:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  407938:	bf00      	nop
  40793a:	370c      	adds	r7, #12
  40793c:	46bd      	mov	sp, r7
  40793e:	bd90      	pop	{r4, r7, pc}
  407940:	07270e00 	.word	0x07270e00
  407944:	00408685 	.word	0x00408685
  407948:	00407819 	.word	0x00407819
  40794c:	00407779 	.word	0x00407779
  407950:	004077cd 	.word	0x004077cd
  407954:	00407851 	.word	0x00407851
  407958:	00408011 	.word	0x00408011
  40795c:	0040851d 	.word	0x0040851d
  407960:	0040788d 	.word	0x0040788d

00407964 <NVIC_EnableIRQ>:
{
  407964:	b480      	push	{r7}
  407966:	b083      	sub	sp, #12
  407968:	af00      	add	r7, sp, #0
  40796a:	4603      	mov	r3, r0
  40796c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  40796e:	4909      	ldr	r1, [pc, #36]	; (407994 <NVIC_EnableIRQ+0x30>)
  407970:	f997 3007 	ldrsb.w	r3, [r7, #7]
  407974:	095b      	lsrs	r3, r3, #5
  407976:	79fa      	ldrb	r2, [r7, #7]
  407978:	f002 021f 	and.w	r2, r2, #31
  40797c:	2001      	movs	r0, #1
  40797e:	fa00 f202 	lsl.w	r2, r0, r2
  407982:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  407986:	bf00      	nop
  407988:	370c      	adds	r7, #12
  40798a:	46bd      	mov	sp, r7
  40798c:	f85d 7b04 	ldr.w	r7, [sp], #4
  407990:	4770      	bx	lr
  407992:	bf00      	nop
  407994:	e000e100 	.word	0xe000e100

00407998 <sysclk_enable_peripheral_clock>:
{
  407998:	b580      	push	{r7, lr}
  40799a:	b082      	sub	sp, #8
  40799c:	af00      	add	r7, sp, #0
  40799e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4079a0:	6878      	ldr	r0, [r7, #4]
  4079a2:	4b03      	ldr	r3, [pc, #12]	; (4079b0 <sysclk_enable_peripheral_clock+0x18>)
  4079a4:	4798      	blx	r3
}
  4079a6:	bf00      	nop
  4079a8:	3708      	adds	r7, #8
  4079aa:	46bd      	mov	sp, r7
  4079ac:	bd80      	pop	{r7, pc}
  4079ae:	bf00      	nop
  4079b0:	0040823d 	.word	0x0040823d

004079b4 <ioport_init>:
{
  4079b4:	b580      	push	{r7, lr}
  4079b6:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  4079b8:	2009      	movs	r0, #9
  4079ba:	4b08      	ldr	r3, [pc, #32]	; (4079dc <ioport_init+0x28>)
  4079bc:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  4079be:	200a      	movs	r0, #10
  4079c0:	4b06      	ldr	r3, [pc, #24]	; (4079dc <ioport_init+0x28>)
  4079c2:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOC);
  4079c4:	200b      	movs	r0, #11
  4079c6:	4b05      	ldr	r3, [pc, #20]	; (4079dc <ioport_init+0x28>)
  4079c8:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOD);
  4079ca:	200c      	movs	r0, #12
  4079cc:	4b03      	ldr	r3, [pc, #12]	; (4079dc <ioport_init+0x28>)
  4079ce:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOE);
  4079d0:	200d      	movs	r0, #13
  4079d2:	4b02      	ldr	r3, [pc, #8]	; (4079dc <ioport_init+0x28>)
  4079d4:	4798      	blx	r3
}
  4079d6:	bf00      	nop
  4079d8:	bd80      	pop	{r7, pc}
  4079da:	bf00      	nop
  4079dc:	00407999 	.word	0x00407999

004079e0 <ioport_disable_pin>:
{
  4079e0:	b480      	push	{r7}
  4079e2:	b089      	sub	sp, #36	; 0x24
  4079e4:	af00      	add	r7, sp, #0
  4079e6:	6078      	str	r0, [r7, #4]
  4079e8:	687b      	ldr	r3, [r7, #4]
  4079ea:	61fb      	str	r3, [r7, #28]
  4079ec:	69fb      	ldr	r3, [r7, #28]
  4079ee:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  4079f0:	69bb      	ldr	r3, [r7, #24]
  4079f2:	095a      	lsrs	r2, r3, #5
  4079f4:	69fb      	ldr	r3, [r7, #28]
  4079f6:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  4079f8:	697b      	ldr	r3, [r7, #20]
  4079fa:	f003 031f 	and.w	r3, r3, #31
  4079fe:	2101      	movs	r1, #1
  407a00:	fa01 f303 	lsl.w	r3, r1, r3
  407a04:	613a      	str	r2, [r7, #16]
  407a06:	60fb      	str	r3, [r7, #12]
  407a08:	693b      	ldr	r3, [r7, #16]
  407a0a:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407a0c:	68bb      	ldr	r3, [r7, #8]
  407a0e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407a12:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407a16:	025b      	lsls	r3, r3, #9
  407a18:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  407a1a:	68fb      	ldr	r3, [r7, #12]
  407a1c:	6053      	str	r3, [r2, #4]
}
  407a1e:	bf00      	nop
  407a20:	3724      	adds	r7, #36	; 0x24
  407a22:	46bd      	mov	sp, r7
  407a24:	f85d 7b04 	ldr.w	r7, [sp], #4
  407a28:	4770      	bx	lr

00407a2a <ioport_disable_port>:
{
  407a2a:	b480      	push	{r7}
  407a2c:	b087      	sub	sp, #28
  407a2e:	af00      	add	r7, sp, #0
  407a30:	6078      	str	r0, [r7, #4]
  407a32:	6039      	str	r1, [r7, #0]
  407a34:	687b      	ldr	r3, [r7, #4]
  407a36:	617b      	str	r3, [r7, #20]
  407a38:	683b      	ldr	r3, [r7, #0]
  407a3a:	613b      	str	r3, [r7, #16]
  407a3c:	697b      	ldr	r3, [r7, #20]
  407a3e:	60fb      	str	r3, [r7, #12]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407a40:	68fb      	ldr	r3, [r7, #12]
  407a42:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407a46:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407a4a:	025b      	lsls	r3, r3, #9
  407a4c:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  407a4e:	693b      	ldr	r3, [r7, #16]
  407a50:	6053      	str	r3, [r2, #4]
}
  407a52:	bf00      	nop
  407a54:	371c      	adds	r7, #28
  407a56:	46bd      	mov	sp, r7
  407a58:	f85d 7b04 	ldr.w	r7, [sp], #4
  407a5c:	4770      	bx	lr

00407a5e <ioport_set_port_mode>:
{
  407a5e:	b480      	push	{r7}
  407a60:	b08b      	sub	sp, #44	; 0x2c
  407a62:	af00      	add	r7, sp, #0
  407a64:	60f8      	str	r0, [r7, #12]
  407a66:	60b9      	str	r1, [r7, #8]
  407a68:	607a      	str	r2, [r7, #4]
  407a6a:	68fb      	ldr	r3, [r7, #12]
  407a6c:	627b      	str	r3, [r7, #36]	; 0x24
  407a6e:	68bb      	ldr	r3, [r7, #8]
  407a70:	623b      	str	r3, [r7, #32]
  407a72:	687b      	ldr	r3, [r7, #4]
  407a74:	61fb      	str	r3, [r7, #28]
  407a76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407a78:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407a7a:	69bb      	ldr	r3, [r7, #24]
  407a7c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407a80:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407a84:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  407a86:	617b      	str	r3, [r7, #20]
	if (mode & IOPORT_MODE_PULLUP) {
  407a88:	69fb      	ldr	r3, [r7, #28]
  407a8a:	f003 0308 	and.w	r3, r3, #8
  407a8e:	2b00      	cmp	r3, #0
  407a90:	d003      	beq.n	407a9a <ioport_set_port_mode+0x3c>
		base->PIO_PUER = mask;
  407a92:	697b      	ldr	r3, [r7, #20]
  407a94:	6a3a      	ldr	r2, [r7, #32]
  407a96:	665a      	str	r2, [r3, #100]	; 0x64
  407a98:	e002      	b.n	407aa0 <ioport_set_port_mode+0x42>
		base->PIO_PUDR = mask;
  407a9a:	697b      	ldr	r3, [r7, #20]
  407a9c:	6a3a      	ldr	r2, [r7, #32]
  407a9e:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  407aa0:	69fb      	ldr	r3, [r7, #28]
  407aa2:	f003 0310 	and.w	r3, r3, #16
  407aa6:	2b00      	cmp	r3, #0
  407aa8:	d004      	beq.n	407ab4 <ioport_set_port_mode+0x56>
		base->PIO_PPDER = mask;
  407aaa:	697b      	ldr	r3, [r7, #20]
  407aac:	6a3a      	ldr	r2, [r7, #32]
  407aae:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  407ab2:	e003      	b.n	407abc <ioport_set_port_mode+0x5e>
		base->PIO_PPDDR = mask;
  407ab4:	697b      	ldr	r3, [r7, #20]
  407ab6:	6a3a      	ldr	r2, [r7, #32]
  407ab8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  407abc:	69fb      	ldr	r3, [r7, #28]
  407abe:	f003 0320 	and.w	r3, r3, #32
  407ac2:	2b00      	cmp	r3, #0
  407ac4:	d003      	beq.n	407ace <ioport_set_port_mode+0x70>
		base->PIO_MDER = mask;
  407ac6:	697b      	ldr	r3, [r7, #20]
  407ac8:	6a3a      	ldr	r2, [r7, #32]
  407aca:	651a      	str	r2, [r3, #80]	; 0x50
  407acc:	e002      	b.n	407ad4 <ioport_set_port_mode+0x76>
		base->PIO_MDDR = mask;
  407ace:	697b      	ldr	r3, [r7, #20]
  407ad0:	6a3a      	ldr	r2, [r7, #32]
  407ad2:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  407ad4:	69fb      	ldr	r3, [r7, #28]
  407ad6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  407ada:	2b00      	cmp	r3, #0
  407adc:	d003      	beq.n	407ae6 <ioport_set_port_mode+0x88>
		base->PIO_IFER = mask;
  407ade:	697b      	ldr	r3, [r7, #20]
  407ae0:	6a3a      	ldr	r2, [r7, #32]
  407ae2:	621a      	str	r2, [r3, #32]
  407ae4:	e002      	b.n	407aec <ioport_set_port_mode+0x8e>
		base->PIO_IFDR = mask;
  407ae6:	697b      	ldr	r3, [r7, #20]
  407ae8:	6a3a      	ldr	r2, [r7, #32]
  407aea:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  407aec:	69fb      	ldr	r3, [r7, #28]
  407aee:	f003 0380 	and.w	r3, r3, #128	; 0x80
  407af2:	2b00      	cmp	r3, #0
  407af4:	d004      	beq.n	407b00 <ioport_set_port_mode+0xa2>
		base->PIO_IFSCER = mask;
  407af6:	697b      	ldr	r3, [r7, #20]
  407af8:	6a3a      	ldr	r2, [r7, #32]
  407afa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  407afe:	e003      	b.n	407b08 <ioport_set_port_mode+0xaa>
		base->PIO_IFSCDR = mask;
  407b00:	697b      	ldr	r3, [r7, #20]
  407b02:	6a3a      	ldr	r2, [r7, #32]
  407b04:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  407b08:	69fb      	ldr	r3, [r7, #28]
  407b0a:	f003 0301 	and.w	r3, r3, #1
  407b0e:	2b00      	cmp	r3, #0
  407b10:	d006      	beq.n	407b20 <ioport_set_port_mode+0xc2>
		base->PIO_ABCDSR[0] |= mask;
  407b12:	697b      	ldr	r3, [r7, #20]
  407b14:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  407b16:	6a3b      	ldr	r3, [r7, #32]
  407b18:	431a      	orrs	r2, r3
  407b1a:	697b      	ldr	r3, [r7, #20]
  407b1c:	671a      	str	r2, [r3, #112]	; 0x70
  407b1e:	e006      	b.n	407b2e <ioport_set_port_mode+0xd0>
		base->PIO_ABCDSR[0] &= ~mask;
  407b20:	697b      	ldr	r3, [r7, #20]
  407b22:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  407b24:	6a3b      	ldr	r3, [r7, #32]
  407b26:	43db      	mvns	r3, r3
  407b28:	401a      	ands	r2, r3
  407b2a:	697b      	ldr	r3, [r7, #20]
  407b2c:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  407b2e:	69fb      	ldr	r3, [r7, #28]
  407b30:	f003 0302 	and.w	r3, r3, #2
  407b34:	2b00      	cmp	r3, #0
  407b36:	d006      	beq.n	407b46 <ioport_set_port_mode+0xe8>
		base->PIO_ABCDSR[1] |= mask;
  407b38:	697b      	ldr	r3, [r7, #20]
  407b3a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  407b3c:	6a3b      	ldr	r3, [r7, #32]
  407b3e:	431a      	orrs	r2, r3
  407b40:	697b      	ldr	r3, [r7, #20]
  407b42:	675a      	str	r2, [r3, #116]	; 0x74
}
  407b44:	e006      	b.n	407b54 <ioport_set_port_mode+0xf6>
		base->PIO_ABCDSR[1] &= ~mask;
  407b46:	697b      	ldr	r3, [r7, #20]
  407b48:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  407b4a:	6a3b      	ldr	r3, [r7, #32]
  407b4c:	43db      	mvns	r3, r3
  407b4e:	401a      	ands	r2, r3
  407b50:	697b      	ldr	r3, [r7, #20]
  407b52:	675a      	str	r2, [r3, #116]	; 0x74
  407b54:	bf00      	nop
  407b56:	372c      	adds	r7, #44	; 0x2c
  407b58:	46bd      	mov	sp, r7
  407b5a:	f85d 7b04 	ldr.w	r7, [sp], #4
  407b5e:	4770      	bx	lr

00407b60 <ioport_set_pin_mode>:
{
  407b60:	b480      	push	{r7}
  407b62:	b08d      	sub	sp, #52	; 0x34
  407b64:	af00      	add	r7, sp, #0
  407b66:	6078      	str	r0, [r7, #4]
  407b68:	6039      	str	r1, [r7, #0]
  407b6a:	687b      	ldr	r3, [r7, #4]
  407b6c:	62fb      	str	r3, [r7, #44]	; 0x2c
  407b6e:	683b      	ldr	r3, [r7, #0]
  407b70:	62bb      	str	r3, [r7, #40]	; 0x28
  407b72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407b74:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  407b76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407b78:	095a      	lsrs	r2, r3, #5
  407b7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407b7c:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  407b7e:	6a3b      	ldr	r3, [r7, #32]
  407b80:	f003 031f 	and.w	r3, r3, #31
  407b84:	2101      	movs	r1, #1
  407b86:	fa01 f303 	lsl.w	r3, r1, r3
  407b8a:	61fa      	str	r2, [r7, #28]
  407b8c:	61bb      	str	r3, [r7, #24]
  407b8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  407b90:	617b      	str	r3, [r7, #20]
  407b92:	69fb      	ldr	r3, [r7, #28]
  407b94:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407b96:	693b      	ldr	r3, [r7, #16]
  407b98:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407b9c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407ba0:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  407ba2:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  407ba4:	697b      	ldr	r3, [r7, #20]
  407ba6:	f003 0308 	and.w	r3, r3, #8
  407baa:	2b00      	cmp	r3, #0
  407bac:	d003      	beq.n	407bb6 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  407bae:	68fb      	ldr	r3, [r7, #12]
  407bb0:	69ba      	ldr	r2, [r7, #24]
  407bb2:	665a      	str	r2, [r3, #100]	; 0x64
  407bb4:	e002      	b.n	407bbc <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  407bb6:	68fb      	ldr	r3, [r7, #12]
  407bb8:	69ba      	ldr	r2, [r7, #24]
  407bba:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  407bbc:	697b      	ldr	r3, [r7, #20]
  407bbe:	f003 0310 	and.w	r3, r3, #16
  407bc2:	2b00      	cmp	r3, #0
  407bc4:	d004      	beq.n	407bd0 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  407bc6:	68fb      	ldr	r3, [r7, #12]
  407bc8:	69ba      	ldr	r2, [r7, #24]
  407bca:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  407bce:	e003      	b.n	407bd8 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  407bd0:	68fb      	ldr	r3, [r7, #12]
  407bd2:	69ba      	ldr	r2, [r7, #24]
  407bd4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  407bd8:	697b      	ldr	r3, [r7, #20]
  407bda:	f003 0320 	and.w	r3, r3, #32
  407bde:	2b00      	cmp	r3, #0
  407be0:	d003      	beq.n	407bea <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  407be2:	68fb      	ldr	r3, [r7, #12]
  407be4:	69ba      	ldr	r2, [r7, #24]
  407be6:	651a      	str	r2, [r3, #80]	; 0x50
  407be8:	e002      	b.n	407bf0 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  407bea:	68fb      	ldr	r3, [r7, #12]
  407bec:	69ba      	ldr	r2, [r7, #24]
  407bee:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  407bf0:	697b      	ldr	r3, [r7, #20]
  407bf2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  407bf6:	2b00      	cmp	r3, #0
  407bf8:	d003      	beq.n	407c02 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  407bfa:	68fb      	ldr	r3, [r7, #12]
  407bfc:	69ba      	ldr	r2, [r7, #24]
  407bfe:	621a      	str	r2, [r3, #32]
  407c00:	e002      	b.n	407c08 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  407c02:	68fb      	ldr	r3, [r7, #12]
  407c04:	69ba      	ldr	r2, [r7, #24]
  407c06:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  407c08:	697b      	ldr	r3, [r7, #20]
  407c0a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  407c0e:	2b00      	cmp	r3, #0
  407c10:	d004      	beq.n	407c1c <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  407c12:	68fb      	ldr	r3, [r7, #12]
  407c14:	69ba      	ldr	r2, [r7, #24]
  407c16:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  407c1a:	e003      	b.n	407c24 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  407c1c:	68fb      	ldr	r3, [r7, #12]
  407c1e:	69ba      	ldr	r2, [r7, #24]
  407c20:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  407c24:	697b      	ldr	r3, [r7, #20]
  407c26:	f003 0301 	and.w	r3, r3, #1
  407c2a:	2b00      	cmp	r3, #0
  407c2c:	d006      	beq.n	407c3c <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  407c2e:	68fb      	ldr	r3, [r7, #12]
  407c30:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  407c32:	69bb      	ldr	r3, [r7, #24]
  407c34:	431a      	orrs	r2, r3
  407c36:	68fb      	ldr	r3, [r7, #12]
  407c38:	671a      	str	r2, [r3, #112]	; 0x70
  407c3a:	e006      	b.n	407c4a <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  407c3c:	68fb      	ldr	r3, [r7, #12]
  407c3e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  407c40:	69bb      	ldr	r3, [r7, #24]
  407c42:	43db      	mvns	r3, r3
  407c44:	401a      	ands	r2, r3
  407c46:	68fb      	ldr	r3, [r7, #12]
  407c48:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  407c4a:	697b      	ldr	r3, [r7, #20]
  407c4c:	f003 0302 	and.w	r3, r3, #2
  407c50:	2b00      	cmp	r3, #0
  407c52:	d006      	beq.n	407c62 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  407c54:	68fb      	ldr	r3, [r7, #12]
  407c56:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  407c58:	69bb      	ldr	r3, [r7, #24]
  407c5a:	431a      	orrs	r2, r3
  407c5c:	68fb      	ldr	r3, [r7, #12]
  407c5e:	675a      	str	r2, [r3, #116]	; 0x74
}
  407c60:	e006      	b.n	407c70 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  407c62:	68fb      	ldr	r3, [r7, #12]
  407c64:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  407c66:	69bb      	ldr	r3, [r7, #24]
  407c68:	43db      	mvns	r3, r3
  407c6a:	401a      	ands	r2, r3
  407c6c:	68fb      	ldr	r3, [r7, #12]
  407c6e:	675a      	str	r2, [r3, #116]	; 0x74
  407c70:	bf00      	nop
  407c72:	3734      	adds	r7, #52	; 0x34
  407c74:	46bd      	mov	sp, r7
  407c76:	f85d 7b04 	ldr.w	r7, [sp], #4
  407c7a:	4770      	bx	lr

00407c7c <ioport_set_pin_dir>:
{
  407c7c:	b480      	push	{r7}
  407c7e:	b08d      	sub	sp, #52	; 0x34
  407c80:	af00      	add	r7, sp, #0
  407c82:	6078      	str	r0, [r7, #4]
  407c84:	460b      	mov	r3, r1
  407c86:	70fb      	strb	r3, [r7, #3]
  407c88:	687b      	ldr	r3, [r7, #4]
  407c8a:	62fb      	str	r3, [r7, #44]	; 0x2c
  407c8c:	78fb      	ldrb	r3, [r7, #3]
  407c8e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  407c92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407c94:	627b      	str	r3, [r7, #36]	; 0x24
  407c96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407c98:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  407c9a:	6a3b      	ldr	r3, [r7, #32]
  407c9c:	095b      	lsrs	r3, r3, #5
  407c9e:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407ca0:	69fb      	ldr	r3, [r7, #28]
  407ca2:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407ca6:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407caa:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  407cac:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  407cae:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  407cb2:	2b01      	cmp	r3, #1
  407cb4:	d109      	bne.n	407cca <ioport_set_pin_dir+0x4e>
  407cb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407cb8:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  407cba:	697b      	ldr	r3, [r7, #20]
  407cbc:	f003 031f 	and.w	r3, r3, #31
  407cc0:	2201      	movs	r2, #1
  407cc2:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  407cc4:	69bb      	ldr	r3, [r7, #24]
  407cc6:	611a      	str	r2, [r3, #16]
  407cc8:	e00c      	b.n	407ce4 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  407cca:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  407cce:	2b00      	cmp	r3, #0
  407cd0:	d108      	bne.n	407ce4 <ioport_set_pin_dir+0x68>
  407cd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407cd4:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  407cd6:	693b      	ldr	r3, [r7, #16]
  407cd8:	f003 031f 	and.w	r3, r3, #31
  407cdc:	2201      	movs	r2, #1
  407cde:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  407ce0:	69bb      	ldr	r3, [r7, #24]
  407ce2:	615a      	str	r2, [r3, #20]
  407ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407ce6:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  407ce8:	68fb      	ldr	r3, [r7, #12]
  407cea:	f003 031f 	and.w	r3, r3, #31
  407cee:	2201      	movs	r2, #1
  407cf0:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  407cf2:	69bb      	ldr	r3, [r7, #24]
  407cf4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  407cf8:	bf00      	nop
  407cfa:	3734      	adds	r7, #52	; 0x34
  407cfc:	46bd      	mov	sp, r7
  407cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
  407d02:	4770      	bx	lr

00407d04 <ioport_set_pin_level>:
{
  407d04:	b480      	push	{r7}
  407d06:	b08b      	sub	sp, #44	; 0x2c
  407d08:	af00      	add	r7, sp, #0
  407d0a:	6078      	str	r0, [r7, #4]
  407d0c:	460b      	mov	r3, r1
  407d0e:	70fb      	strb	r3, [r7, #3]
  407d10:	687b      	ldr	r3, [r7, #4]
  407d12:	627b      	str	r3, [r7, #36]	; 0x24
  407d14:	78fb      	ldrb	r3, [r7, #3]
  407d16:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  407d1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407d1c:	61fb      	str	r3, [r7, #28]
  407d1e:	69fb      	ldr	r3, [r7, #28]
  407d20:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  407d22:	69bb      	ldr	r3, [r7, #24]
  407d24:	095b      	lsrs	r3, r3, #5
  407d26:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  407d28:	697b      	ldr	r3, [r7, #20]
  407d2a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  407d2e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  407d32:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  407d34:	613b      	str	r3, [r7, #16]
	if (level) {
  407d36:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  407d3a:	2b00      	cmp	r3, #0
  407d3c:	d009      	beq.n	407d52 <ioport_set_pin_level+0x4e>
  407d3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407d40:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  407d42:	68fb      	ldr	r3, [r7, #12]
  407d44:	f003 031f 	and.w	r3, r3, #31
  407d48:	2201      	movs	r2, #1
  407d4a:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  407d4c:	693b      	ldr	r3, [r7, #16]
  407d4e:	631a      	str	r2, [r3, #48]	; 0x30
}
  407d50:	e008      	b.n	407d64 <ioport_set_pin_level+0x60>
  407d52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407d54:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  407d56:	68bb      	ldr	r3, [r7, #8]
  407d58:	f003 031f 	and.w	r3, r3, #31
  407d5c:	2201      	movs	r2, #1
  407d5e:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  407d60:	693b      	ldr	r3, [r7, #16]
  407d62:	635a      	str	r2, [r3, #52]	; 0x34
  407d64:	bf00      	nop
  407d66:	372c      	adds	r7, #44	; 0x2c
  407d68:	46bd      	mov	sp, r7
  407d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  407d6e:	4770      	bx	lr

00407d70 <sleepmgr_init>:
{
  407d70:	b480      	push	{r7}
  407d72:	b083      	sub	sp, #12
  407d74:	af00      	add	r7, sp, #0
	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
  407d76:	2300      	movs	r3, #0
  407d78:	71fb      	strb	r3, [r7, #7]
  407d7a:	e006      	b.n	407d8a <sleepmgr_init+0x1a>
		sleepmgr_locks[i] = 0;
  407d7c:	79fb      	ldrb	r3, [r7, #7]
  407d7e:	4a09      	ldr	r2, [pc, #36]	; (407da4 <sleepmgr_init+0x34>)
  407d80:	2100      	movs	r1, #0
  407d82:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
  407d84:	79fb      	ldrb	r3, [r7, #7]
  407d86:	3301      	adds	r3, #1
  407d88:	71fb      	strb	r3, [r7, #7]
  407d8a:	79fb      	ldrb	r3, [r7, #7]
  407d8c:	2b04      	cmp	r3, #4
  407d8e:	d9f5      	bls.n	407d7c <sleepmgr_init+0xc>
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
  407d90:	4b04      	ldr	r3, [pc, #16]	; (407da4 <sleepmgr_init+0x34>)
  407d92:	2201      	movs	r2, #1
  407d94:	715a      	strb	r2, [r3, #5]
}
  407d96:	bf00      	nop
  407d98:	370c      	adds	r7, #12
  407d9a:	46bd      	mov	sp, r7
  407d9c:	f85d 7b04 	ldr.w	r7, [sp], #4
  407da0:	4770      	bx	lr
  407da2:	bf00      	nop
  407da4:	20008964 	.word	0x20008964

00407da8 <initalize_hsmci>:
		ioport_set_pin_mode(pin, mode);\
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)
	
void initalize_hsmci(void)
{
  407da8:	b580      	push	{r7, lr}
  407daa:	af00      	add	r7, sp, #0
	/* Configure HSMCI pins */
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  407dac:	2102      	movs	r1, #2
  407dae:	201c      	movs	r0, #28
  407db0:	4b18      	ldr	r3, [pc, #96]	; (407e14 <initalize_hsmci+0x6c>)
  407db2:	4798      	blx	r3
  407db4:	201c      	movs	r0, #28
  407db6:	4b18      	ldr	r3, [pc, #96]	; (407e18 <initalize_hsmci+0x70>)
  407db8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  407dba:	2102      	movs	r1, #2
  407dbc:	201d      	movs	r0, #29
  407dbe:	4b15      	ldr	r3, [pc, #84]	; (407e14 <initalize_hsmci+0x6c>)
  407dc0:	4798      	blx	r3
  407dc2:	201d      	movs	r0, #29
  407dc4:	4b14      	ldr	r3, [pc, #80]	; (407e18 <initalize_hsmci+0x70>)
  407dc6:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  407dc8:	2102      	movs	r1, #2
  407dca:	201e      	movs	r0, #30
  407dcc:	4b11      	ldr	r3, [pc, #68]	; (407e14 <initalize_hsmci+0x6c>)
  407dce:	4798      	blx	r3
  407dd0:	201e      	movs	r0, #30
  407dd2:	4b11      	ldr	r3, [pc, #68]	; (407e18 <initalize_hsmci+0x70>)
  407dd4:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  407dd6:	2102      	movs	r1, #2
  407dd8:	201f      	movs	r0, #31
  407dda:	4b0e      	ldr	r3, [pc, #56]	; (407e14 <initalize_hsmci+0x6c>)
  407ddc:	4798      	blx	r3
  407dde:	201f      	movs	r0, #31
  407de0:	4b0d      	ldr	r3, [pc, #52]	; (407e18 <initalize_hsmci+0x70>)
  407de2:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  407de4:	2102      	movs	r1, #2
  407de6:	201a      	movs	r0, #26
  407de8:	4b0a      	ldr	r3, [pc, #40]	; (407e14 <initalize_hsmci+0x6c>)
  407dea:	4798      	blx	r3
  407dec:	201a      	movs	r0, #26
  407dee:	4b0a      	ldr	r3, [pc, #40]	; (407e18 <initalize_hsmci+0x70>)
  407df0:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  407df2:	2102      	movs	r1, #2
  407df4:	201b      	movs	r0, #27
  407df6:	4b07      	ldr	r3, [pc, #28]	; (407e14 <initalize_hsmci+0x6c>)
  407df8:	4798      	blx	r3
  407dfa:	201b      	movs	r0, #27
  407dfc:	4b06      	ldr	r3, [pc, #24]	; (407e18 <initalize_hsmci+0x70>)
  407dfe:	4798      	blx	r3

	/* Configure SD/MMC card detect pin */
	ioport_set_pin_dir(SD_MMC_0_CD_GPIO, IOPORT_DIR_INPUT);
  407e00:	2100      	movs	r1, #0
  407e02:	2008      	movs	r0, #8
  407e04:	4b05      	ldr	r3, [pc, #20]	; (407e1c <initalize_hsmci+0x74>)
  407e06:	4798      	blx	r3
	ioport_set_pin_mode(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  407e08:	2108      	movs	r1, #8
  407e0a:	2008      	movs	r0, #8
  407e0c:	4b01      	ldr	r3, [pc, #4]	; (407e14 <initalize_hsmci+0x6c>)
  407e0e:	4798      	blx	r3
}
  407e10:	bf00      	nop
  407e12:	bd80      	pop	{r7, pc}
  407e14:	00407b61 	.word	0x00407b61
  407e18:	004079e1 	.word	0x004079e1
  407e1c:	00407c7d 	.word	0x00407c7d

00407e20 <initalize_can0>:

void initalize_can0(void)
{
  407e20:	b580      	push	{r7, lr}
  407e22:	af00      	add	r7, sp, #0
  	
	ioport_set_pin_dir(MSC_NEN, IOPORT_DIR_OUTPUT);
  407e24:	2101      	movs	r1, #1
  407e26:	2079      	movs	r0, #121	; 0x79
  407e28:	4b1a      	ldr	r3, [pc, #104]	; (407e94 <initalize_can0+0x74>)
  407e2a:	4798      	blx	r3
	ioport_set_pin_dir(MSC_NRM, IOPORT_DIR_OUTPUT);
  407e2c:	2101      	movs	r1, #1
  407e2e:	2079      	movs	r0, #121	; 0x79
  407e30:	4b18      	ldr	r3, [pc, #96]	; (407e94 <initalize_can0+0x74>)
  407e32:	4798      	blx	r3

	ioport_set_pin_dir(HSC_NEN, IOPORT_DIR_OUTPUT);
  407e34:	2101      	movs	r1, #1
  407e36:	2074      	movs	r0, #116	; 0x74
  407e38:	4b16      	ldr	r3, [pc, #88]	; (407e94 <initalize_can0+0x74>)
  407e3a:	4798      	blx	r3
	ioport_set_pin_dir(HSC_NRM, IOPORT_DIR_OUTPUT);
  407e3c:	2101      	movs	r1, #1
  407e3e:	200b      	movs	r0, #11
  407e40:	4b14      	ldr	r3, [pc, #80]	; (407e94 <initalize_can0+0x74>)
  407e42:	4798      	blx	r3

	ioport_set_pin_dir(SWC_MODE_1, IOPORT_DIR_OUTPUT);
  407e44:	2101      	movs	r1, #1
  407e46:	200d      	movs	r0, #13
  407e48:	4b12      	ldr	r3, [pc, #72]	; (407e94 <initalize_can0+0x74>)
  407e4a:	4798      	blx	r3
	ioport_set_pin_dir(SWC_MODE_2, IOPORT_DIR_OUTPUT);
  407e4c:	2101      	movs	r1, #1
  407e4e:	200e      	movs	r0, #14
  407e50:	4b10      	ldr	r3, [pc, #64]	; (407e94 <initalize_can0+0x74>)
  407e52:	4798      	blx	r3
	ioport_set_pin_dir(SWC_RX_EN, IOPORT_DIR_OUTPUT);
  407e54:	2101      	movs	r1, #1
  407e56:	2017      	movs	r0, #23
  407e58:	4b0e      	ldr	r3, [pc, #56]	; (407e94 <initalize_can0+0x74>)
  407e5a:	4798      	blx	r3
	
	ioport_set_pin_peripheral_mode(PIN_CAN0_RX_IDX, PIN_CAN0_RX_FLAGS);
  407e5c:	2100      	movs	r1, #0
  407e5e:	2023      	movs	r0, #35	; 0x23
  407e60:	4b0d      	ldr	r3, [pc, #52]	; (407e98 <initalize_can0+0x78>)
  407e62:	4798      	blx	r3
  407e64:	2023      	movs	r0, #35	; 0x23
  407e66:	4b0d      	ldr	r3, [pc, #52]	; (407e9c <initalize_can0+0x7c>)
  407e68:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_CAN0_TX_IDX, PIN_CAN0_TX_FLAGS);
  407e6a:	2100      	movs	r1, #0
  407e6c:	2022      	movs	r0, #34	; 0x22
  407e6e:	4b0a      	ldr	r3, [pc, #40]	; (407e98 <initalize_can0+0x78>)
  407e70:	4798      	blx	r3
  407e72:	2022      	movs	r0, #34	; 0x22
  407e74:	4b09      	ldr	r3, [pc, #36]	; (407e9c <initalize_can0+0x7c>)
  407e76:	4798      	blx	r3
	
	
	can_disable_interrupt(SYSTEM_CAN, CAN_DISABLE_ALL_INTERRUPT_MASK);
  407e78:	f04f 31ff 	mov.w	r1, #4294967295
  407e7c:	4808      	ldr	r0, [pc, #32]	; (407ea0 <initalize_can0+0x80>)
  407e7e:	4b09      	ldr	r3, [pc, #36]	; (407ea4 <initalize_can0+0x84>)
  407e80:	4798      	blx	r3
	can_reset_all_mailbox(SYSTEM_CAN);
  407e82:	4807      	ldr	r0, [pc, #28]	; (407ea0 <initalize_can0+0x80>)
  407e84:	4b08      	ldr	r3, [pc, #32]	; (407ea8 <initalize_can0+0x88>)
  407e86:	4798      	blx	r3
	NVIC_EnableIRQ(SYSTEM_CAN_IRQ);
  407e88:	2025      	movs	r0, #37	; 0x25
  407e8a:	4b08      	ldr	r3, [pc, #32]	; (407eac <initalize_can0+0x8c>)
  407e8c:	4798      	blx	r3
	
	
	
}
  407e8e:	bf00      	nop
  407e90:	bd80      	pop	{r7, pc}
  407e92:	bf00      	nop
  407e94:	00407c7d 	.word	0x00407c7d
  407e98:	00407b61 	.word	0x00407b61
  407e9c:	004079e1 	.word	0x004079e1
  407ea0:	40010000 	.word	0x40010000
  407ea4:	00400ead 	.word	0x00400ead
  407ea8:	0040122d 	.word	0x0040122d
  407eac:	00407965 	.word	0x00407965

00407eb0 <initalize_leds>:
void initalize_leds(void)
{
  407eb0:	b580      	push	{r7, lr}
  407eb2:	af00      	add	r7, sp, #0
	ioport_set_pin_dir(POWER_LED_RED, IOPORT_DIR_OUTPUT);
  407eb4:	2101      	movs	r1, #1
  407eb6:	2065      	movs	r0, #101	; 0x65
  407eb8:	4b23      	ldr	r3, [pc, #140]	; (407f48 <initalize_leds+0x98>)
  407eba:	4798      	blx	r3
	ioport_set_pin_dir(POWER_LED_GREEN, IOPORT_DIR_OUTPUT);
  407ebc:	2101      	movs	r1, #1
  407ebe:	2064      	movs	r0, #100	; 0x64
  407ec0:	4b21      	ldr	r3, [pc, #132]	; (407f48 <initalize_leds+0x98>)
  407ec2:	4798      	blx	r3
	ioport_set_pin_dir(POWER_LED_BLUE, IOPORT_DIR_OUTPUT);
  407ec4:	2101      	movs	r1, #1
  407ec6:	2063      	movs	r0, #99	; 0x63
  407ec8:	4b1f      	ldr	r3, [pc, #124]	; (407f48 <initalize_leds+0x98>)
  407eca:	4798      	blx	r3
	
	ioport_set_pin_dir(VEHICLE_LED_GREEN, IOPORT_DIR_OUTPUT);
  407ecc:	2101      	movs	r1, #1
  407ece:	2001      	movs	r0, #1
  407ed0:	4b1d      	ldr	r3, [pc, #116]	; (407f48 <initalize_leds+0x98>)
  407ed2:	4798      	blx	r3
	ioport_set_pin_dir(VEHICLE_LED_RED, IOPORT_DIR_OUTPUT);
  407ed4:	2101      	movs	r1, #1
  407ed6:	206b      	movs	r0, #107	; 0x6b
  407ed8:	4b1b      	ldr	r3, [pc, #108]	; (407f48 <initalize_leds+0x98>)
  407eda:	4798      	blx	r3
	ioport_set_pin_dir(VEHICLE_LED_BLUE, IOPORT_DIR_OUTPUT);
  407edc:	2101      	movs	r1, #1
  407ede:	206a      	movs	r0, #106	; 0x6a
  407ee0:	4b19      	ldr	r3, [pc, #100]	; (407f48 <initalize_leds+0x98>)
  407ee2:	4798      	blx	r3
	
	ioport_set_pin_dir(PC_LED_GREEN, IOPORT_DIR_OUTPUT);
  407ee4:	2101      	movs	r1, #1
  407ee6:	206f      	movs	r0, #111	; 0x6f
  407ee8:	4b17      	ldr	r3, [pc, #92]	; (407f48 <initalize_leds+0x98>)
  407eea:	4798      	blx	r3
	ioport_set_pin_dir(PC_LED_RED, IOPORT_DIR_OUTPUT);
  407eec:	2101      	movs	r1, #1
  407eee:	2000      	movs	r0, #0
  407ef0:	4b15      	ldr	r3, [pc, #84]	; (407f48 <initalize_leds+0x98>)
  407ef2:	4798      	blx	r3
	ioport_set_pin_dir(PC_LED_BLUE, IOPORT_DIR_OUTPUT);
  407ef4:	2101      	movs	r1, #1
  407ef6:	207d      	movs	r0, #125	; 0x7d
  407ef8:	4b13      	ldr	r3, [pc, #76]	; (407f48 <initalize_leds+0x98>)
  407efa:	4798      	blx	r3
	
	ioport_set_pin_level(POWER_LED_RED, IOPORT_PIN_LEVEL_LOW);
  407efc:	2100      	movs	r1, #0
  407efe:	2065      	movs	r0, #101	; 0x65
  407f00:	4b12      	ldr	r3, [pc, #72]	; (407f4c <initalize_leds+0x9c>)
  407f02:	4798      	blx	r3
	ioport_set_pin_level(POWER_LED_GREEN, IOPORT_PIN_LEVEL_HIGH);
  407f04:	2101      	movs	r1, #1
  407f06:	2064      	movs	r0, #100	; 0x64
  407f08:	4b10      	ldr	r3, [pc, #64]	; (407f4c <initalize_leds+0x9c>)
  407f0a:	4798      	blx	r3
	ioport_set_pin_level(POWER_LED_BLUE, IOPORT_PIN_LEVEL_HIGH);
  407f0c:	2101      	movs	r1, #1
  407f0e:	2063      	movs	r0, #99	; 0x63
  407f10:	4b0e      	ldr	r3, [pc, #56]	; (407f4c <initalize_leds+0x9c>)
  407f12:	4798      	blx	r3
	 
	ioport_set_pin_level(VEHICLE_LED_GREEN, IOPORT_PIN_LEVEL_HIGH);
  407f14:	2101      	movs	r1, #1
  407f16:	2001      	movs	r0, #1
  407f18:	4b0c      	ldr	r3, [pc, #48]	; (407f4c <initalize_leds+0x9c>)
  407f1a:	4798      	blx	r3
	ioport_set_pin_level(VEHICLE_LED_RED, IOPORT_PIN_LEVEL_HIGH);
  407f1c:	2101      	movs	r1, #1
  407f1e:	206b      	movs	r0, #107	; 0x6b
  407f20:	4b0a      	ldr	r3, [pc, #40]	; (407f4c <initalize_leds+0x9c>)
  407f22:	4798      	blx	r3
	ioport_set_pin_level(VEHICLE_LED_BLUE, IOPORT_PIN_LEVEL_HIGH);
  407f24:	2101      	movs	r1, #1
  407f26:	206a      	movs	r0, #106	; 0x6a
  407f28:	4b08      	ldr	r3, [pc, #32]	; (407f4c <initalize_leds+0x9c>)
  407f2a:	4798      	blx	r3
	 
	ioport_set_pin_level(PC_LED_GREEN, IOPORT_PIN_LEVEL_HIGH);
  407f2c:	2101      	movs	r1, #1
  407f2e:	206f      	movs	r0, #111	; 0x6f
  407f30:	4b06      	ldr	r3, [pc, #24]	; (407f4c <initalize_leds+0x9c>)
  407f32:	4798      	blx	r3
	ioport_set_pin_level(PC_LED_RED, IOPORT_PIN_LEVEL_HIGH);
  407f34:	2101      	movs	r1, #1
  407f36:	2000      	movs	r0, #0
  407f38:	4b04      	ldr	r3, [pc, #16]	; (407f4c <initalize_leds+0x9c>)
  407f3a:	4798      	blx	r3
	ioport_set_pin_level(PC_LED_BLUE, IOPORT_PIN_LEVEL_HIGH);
  407f3c:	2101      	movs	r1, #1
  407f3e:	207d      	movs	r0, #125	; 0x7d
  407f40:	4b02      	ldr	r3, [pc, #8]	; (407f4c <initalize_leds+0x9c>)
  407f42:	4798      	blx	r3
	
}
  407f44:	bf00      	nop
  407f46:	bd80      	pop	{r7, pc}
  407f48:	00407c7d 	.word	0x00407c7d
  407f4c:	00407d05 	.word	0x00407d05

00407f50 <initalize_j1850_vpw>:

void initalize_j1850_vpw(void)
{
  407f50:	b580      	push	{r7, lr}
  407f52:	af00      	add	r7, sp, #0
	ioport_set_pin_mode(J1850_P_TX, IOPORT_MODE_MUX_A);
  407f54:	2100      	movs	r1, #0
  407f56:	200f      	movs	r0, #15
  407f58:	4b05      	ldr	r3, [pc, #20]	; (407f70 <initalize_j1850_vpw+0x20>)
  407f5a:	4798      	blx	r3
	ioport_set_pin_dir(J1850_P_TX, IOPORT_DIR_OUTPUT);
  407f5c:	2101      	movs	r1, #1
  407f5e:	200f      	movs	r0, #15
  407f60:	4b04      	ldr	r3, [pc, #16]	; (407f74 <initalize_j1850_vpw+0x24>)
  407f62:	4798      	blx	r3
	ioport_set_pin_level(J1850_P_TX, IOPORT_PIN_LEVEL_LOW);
  407f64:	2100      	movs	r1, #0
  407f66:	200f      	movs	r0, #15
  407f68:	4b03      	ldr	r3, [pc, #12]	; (407f78 <initalize_j1850_vpw+0x28>)
  407f6a:	4798      	blx	r3
	
}
  407f6c:	bf00      	nop
  407f6e:	bd80      	pop	{r7, pc}
  407f70:	00407b61 	.word	0x00407b61
  407f74:	00407c7d 	.word	0x00407c7d
  407f78:	00407d05 	.word	0x00407d05

00407f7c <board_init>:

void board_init(void)
{
  407f7c:	b580      	push	{r7, lr}
  407f7e:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  407f80:	4b14      	ldr	r3, [pc, #80]	; (407fd4 <board_init+0x58>)
  407f82:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  407f86:	605a      	str	r2, [r3, #4]
#endif

	/* Initialize IOPORTs */
	ioport_init();
  407f88:	4b13      	ldr	r3, [pc, #76]	; (407fd8 <board_init+0x5c>)
  407f8a:	4798      	blx	r3
	
	ioport_set_port_peripheral_mode(PINS_UART0_PORT, PINS_UART0, PINS_UART0_FLAGS);
  407f8c:	2200      	movs	r2, #0
  407f8e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  407f92:	2000      	movs	r0, #0
  407f94:	4b11      	ldr	r3, [pc, #68]	; (407fdc <board_init+0x60>)
  407f96:	4798      	blx	r3
  407f98:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  407f9c:	2000      	movs	r0, #0
  407f9e:	4b10      	ldr	r3, [pc, #64]	; (407fe0 <board_init+0x64>)
  407fa0:	4798      	blx	r3
	InitalizeDebugConsole();
  407fa2:	4b10      	ldr	r3, [pc, #64]	; (407fe4 <board_init+0x68>)
  407fa4:	4798      	blx	r3
	initalize_leds();
  407fa6:	4b10      	ldr	r3, [pc, #64]	; (407fe8 <board_init+0x6c>)
  407fa8:	4798      	blx	r3
	ui_init();
  407faa:	4b10      	ldr	r3, [pc, #64]	; (407fec <board_init+0x70>)
  407fac:	4798      	blx	r3
	sleepmgr_init();
  407fae:	4b10      	ldr	r3, [pc, #64]	; (407ff0 <board_init+0x74>)
  407fb0:	4798      	blx	r3
	initalize_hsmci();
  407fb2:	4b10      	ldr	r3, [pc, #64]	; (407ff4 <board_init+0x78>)
  407fb4:	4798      	blx	r3
	
	initalize_j1850_vpw();
  407fb6:	4b10      	ldr	r3, [pc, #64]	; (407ff8 <board_init+0x7c>)
  407fb8:	4798      	blx	r3
	initalize_can0();
  407fba:	4b10      	ldr	r3, [pc, #64]	; (407ffc <board_init+0x80>)
  407fbc:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_EFC);
  407fbe:	2006      	movs	r0, #6
  407fc0:	4b0f      	ldr	r3, [pc, #60]	; (408000 <board_init+0x84>)
  407fc2:	4798      	blx	r3
	adcInit();
  407fc4:	4b0f      	ldr	r3, [pc, #60]	; (408004 <board_init+0x88>)
  407fc6:	4798      	blx	r3
	udc_start();
  407fc8:	4b0f      	ldr	r3, [pc, #60]	; (408008 <board_init+0x8c>)
  407fca:	4798      	blx	r3
	
	ui_power_good();
  407fcc:	4b0f      	ldr	r3, [pc, #60]	; (40800c <board_init+0x90>)
  407fce:	4798      	blx	r3
}
  407fd0:	bf00      	nop
  407fd2:	bd80      	pop	{r7, pc}
  407fd4:	400e1850 	.word	0x400e1850
  407fd8:	004079b5 	.word	0x004079b5
  407fdc:	00407a5f 	.word	0x00407a5f
  407fe0:	00407a2b 	.word	0x00407a2b
  407fe4:	0040133d 	.word	0x0040133d
  407fe8:	00407eb1 	.word	0x00407eb1
  407fec:	00401e89 	.word	0x00401e89
  407ff0:	00407d71 	.word	0x00407d71
  407ff4:	00407da9 	.word	0x00407da9
  407ff8:	00407f51 	.word	0x00407f51
  407ffc:	00407e21 	.word	0x00407e21
  408000:	00407999 	.word	0x00407999
  408004:	00400315 	.word	0x00400315
  408008:	004047d1 	.word	0x004047d1
  40800c:	00401f2d 	.word	0x00401f2d

00408010 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  408010:	b480      	push	{r7}
  408012:	b085      	sub	sp, #20
  408014:	af00      	add	r7, sp, #0
  408016:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  408018:	491d      	ldr	r1, [pc, #116]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  40801a:	4b1d      	ldr	r3, [pc, #116]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  40801c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40801e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  408022:	687b      	ldr	r3, [r7, #4]
  408024:	4313      	orrs	r3, r2
  408026:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  408028:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40802c:	60fb      	str	r3, [r7, #12]
  40802e:	e007      	b.n	408040 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  408030:	68fb      	ldr	r3, [r7, #12]
  408032:	2b00      	cmp	r3, #0
  408034:	d101      	bne.n	40803a <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  408036:	2301      	movs	r3, #1
  408038:	e023      	b.n	408082 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40803a:	68fb      	ldr	r3, [r7, #12]
  40803c:	3b01      	subs	r3, #1
  40803e:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  408040:	4b13      	ldr	r3, [pc, #76]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  408042:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  408044:	f003 0308 	and.w	r3, r3, #8
  408048:	2b00      	cmp	r3, #0
  40804a:	d0f1      	beq.n	408030 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40804c:	4a10      	ldr	r2, [pc, #64]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  40804e:	4b10      	ldr	r3, [pc, #64]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  408050:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  408052:	f023 0303 	bic.w	r3, r3, #3
  408056:	f043 0302 	orr.w	r3, r3, #2
  40805a:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40805c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  408060:	60fb      	str	r3, [r7, #12]
  408062:	e007      	b.n	408074 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  408064:	68fb      	ldr	r3, [r7, #12]
  408066:	2b00      	cmp	r3, #0
  408068:	d101      	bne.n	40806e <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  40806a:	2301      	movs	r3, #1
  40806c:	e009      	b.n	408082 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40806e:	68fb      	ldr	r3, [r7, #12]
  408070:	3b01      	subs	r3, #1
  408072:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  408074:	4b06      	ldr	r3, [pc, #24]	; (408090 <pmc_switch_mck_to_pllack+0x80>)
  408076:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  408078:	f003 0308 	and.w	r3, r3, #8
  40807c:	2b00      	cmp	r3, #0
  40807e:	d0f1      	beq.n	408064 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  408080:	2300      	movs	r3, #0
}
  408082:	4618      	mov	r0, r3
  408084:	3714      	adds	r7, #20
  408086:	46bd      	mov	sp, r7
  408088:	f85d 7b04 	ldr.w	r7, [sp], #4
  40808c:	4770      	bx	lr
  40808e:	bf00      	nop
  408090:	400e0400 	.word	0x400e0400

00408094 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  408094:	b480      	push	{r7}
  408096:	b083      	sub	sp, #12
  408098:	af00      	add	r7, sp, #0
  40809a:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  40809c:	687b      	ldr	r3, [r7, #4]
  40809e:	2b01      	cmp	r3, #1
  4080a0:	d107      	bne.n	4080b2 <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  4080a2:	4a08      	ldr	r2, [pc, #32]	; (4080c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4080a4:	4b07      	ldr	r3, [pc, #28]	; (4080c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4080a6:	689b      	ldr	r3, [r3, #8]
  4080a8:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  4080ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4080b0:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  4080b2:	4b04      	ldr	r3, [pc, #16]	; (4080c4 <pmc_switch_sclk_to_32kxtal+0x30>)
  4080b4:	4a04      	ldr	r2, [pc, #16]	; (4080c8 <pmc_switch_sclk_to_32kxtal+0x34>)
  4080b6:	601a      	str	r2, [r3, #0]
}
  4080b8:	bf00      	nop
  4080ba:	370c      	adds	r7, #12
  4080bc:	46bd      	mov	sp, r7
  4080be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4080c2:	4770      	bx	lr
  4080c4:	400e1810 	.word	0x400e1810
  4080c8:	a5000008 	.word	0xa5000008

004080cc <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4080cc:	b480      	push	{r7}
  4080ce:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4080d0:	4b09      	ldr	r3, [pc, #36]	; (4080f8 <pmc_osc_is_ready_32kxtal+0x2c>)
  4080d2:	695b      	ldr	r3, [r3, #20]
  4080d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4080d8:	2b00      	cmp	r3, #0
  4080da:	d007      	beq.n	4080ec <pmc_osc_is_ready_32kxtal+0x20>
  4080dc:	4b07      	ldr	r3, [pc, #28]	; (4080fc <pmc_osc_is_ready_32kxtal+0x30>)
  4080de:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4080e0:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4080e4:	2b00      	cmp	r3, #0
  4080e6:	d001      	beq.n	4080ec <pmc_osc_is_ready_32kxtal+0x20>
  4080e8:	2301      	movs	r3, #1
  4080ea:	e000      	b.n	4080ee <pmc_osc_is_ready_32kxtal+0x22>
  4080ec:	2300      	movs	r3, #0
}
  4080ee:	4618      	mov	r0, r3
  4080f0:	46bd      	mov	sp, r7
  4080f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4080f6:	4770      	bx	lr
  4080f8:	400e1810 	.word	0x400e1810
  4080fc:	400e0400 	.word	0x400e0400

00408100 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  408100:	b480      	push	{r7}
  408102:	b083      	sub	sp, #12
  408104:	af00      	add	r7, sp, #0
  408106:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  408108:	4a18      	ldr	r2, [pc, #96]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  40810a:	4b18      	ldr	r3, [pc, #96]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  40810c:	6a1b      	ldr	r3, [r3, #32]
  40810e:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  408112:	f043 0308 	orr.w	r3, r3, #8
  408116:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  408118:	bf00      	nop
  40811a:	4b14      	ldr	r3, [pc, #80]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  40811c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40811e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  408122:	2b00      	cmp	r3, #0
  408124:	d0f9      	beq.n	40811a <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  408126:	4911      	ldr	r1, [pc, #68]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  408128:	4b10      	ldr	r3, [pc, #64]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  40812a:	6a1b      	ldr	r3, [r3, #32]
  40812c:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  408130:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  408134:	687a      	ldr	r2, [r7, #4]
  408136:	4313      	orrs	r3, r2
  408138:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40813c:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  40813e:	bf00      	nop
  408140:	4b0a      	ldr	r3, [pc, #40]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  408142:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  408144:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  408148:	2b00      	cmp	r3, #0
  40814a:	d0f9      	beq.n	408140 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  40814c:	4a07      	ldr	r2, [pc, #28]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  40814e:	4b07      	ldr	r3, [pc, #28]	; (40816c <pmc_switch_mainck_to_fastrc+0x6c>)
  408150:	6a1b      	ldr	r3, [r3, #32]
  408152:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  408156:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40815a:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40815e:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  408160:	bf00      	nop
  408162:	370c      	adds	r7, #12
  408164:	46bd      	mov	sp, r7
  408166:	f85d 7b04 	ldr.w	r7, [sp], #4
  40816a:	4770      	bx	lr
  40816c:	400e0400 	.word	0x400e0400

00408170 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  408170:	b480      	push	{r7}
  408172:	b083      	sub	sp, #12
  408174:	af00      	add	r7, sp, #0
  408176:	6078      	str	r0, [r7, #4]
  408178:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40817a:	687b      	ldr	r3, [r7, #4]
  40817c:	2b00      	cmp	r3, #0
  40817e:	d008      	beq.n	408192 <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  408180:	4916      	ldr	r1, [pc, #88]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  408182:	4b16      	ldr	r3, [pc, #88]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  408184:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  408186:	4a16      	ldr	r2, [pc, #88]	; (4081e0 <pmc_switch_mainck_to_xtal+0x70>)
  408188:	401a      	ands	r2, r3
  40818a:	4b16      	ldr	r3, [pc, #88]	; (4081e4 <pmc_switch_mainck_to_xtal+0x74>)
  40818c:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40818e:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  408190:	e01e      	b.n	4081d0 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  408192:	4912      	ldr	r1, [pc, #72]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  408194:	4b11      	ldr	r3, [pc, #68]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  408196:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  408198:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40819c:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4081a0:	683a      	ldr	r2, [r7, #0]
  4081a2:	0212      	lsls	r2, r2, #8
  4081a4:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4081a6:	4313      	orrs	r3, r2
  4081a8:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4081ac:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4081b0:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4081b2:	bf00      	nop
  4081b4:	4b09      	ldr	r3, [pc, #36]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  4081b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4081b8:	f003 0301 	and.w	r3, r3, #1
  4081bc:	2b00      	cmp	r3, #0
  4081be:	d0f9      	beq.n	4081b4 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4081c0:	4a06      	ldr	r2, [pc, #24]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  4081c2:	4b06      	ldr	r3, [pc, #24]	; (4081dc <pmc_switch_mainck_to_xtal+0x6c>)
  4081c4:	6a1b      	ldr	r3, [r3, #32]
  4081c6:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4081ca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4081ce:	6213      	str	r3, [r2, #32]
}
  4081d0:	bf00      	nop
  4081d2:	370c      	adds	r7, #12
  4081d4:	46bd      	mov	sp, r7
  4081d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4081da:	4770      	bx	lr
  4081dc:	400e0400 	.word	0x400e0400
  4081e0:	fec8fffc 	.word	0xfec8fffc
  4081e4:	01370002 	.word	0x01370002

004081e8 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4081e8:	b480      	push	{r7}
  4081ea:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4081ec:	4b04      	ldr	r3, [pc, #16]	; (408200 <pmc_osc_is_ready_mainck+0x18>)
  4081ee:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4081f0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4081f4:	4618      	mov	r0, r3
  4081f6:	46bd      	mov	sp, r7
  4081f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4081fc:	4770      	bx	lr
  4081fe:	bf00      	nop
  408200:	400e0400 	.word	0x400e0400

00408204 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  408204:	b480      	push	{r7}
  408206:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  408208:	4b04      	ldr	r3, [pc, #16]	; (40821c <pmc_disable_pllack+0x18>)
  40820a:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40820e:	629a      	str	r2, [r3, #40]	; 0x28
#endif
}
  408210:	bf00      	nop
  408212:	46bd      	mov	sp, r7
  408214:	f85d 7b04 	ldr.w	r7, [sp], #4
  408218:	4770      	bx	lr
  40821a:	bf00      	nop
  40821c:	400e0400 	.word	0x400e0400

00408220 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  408220:	b480      	push	{r7}
  408222:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  408224:	4b04      	ldr	r3, [pc, #16]	; (408238 <pmc_is_locked_pllack+0x18>)
  408226:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  408228:	f003 0302 	and.w	r3, r3, #2
}
  40822c:	4618      	mov	r0, r3
  40822e:	46bd      	mov	sp, r7
  408230:	f85d 7b04 	ldr.w	r7, [sp], #4
  408234:	4770      	bx	lr
  408236:	bf00      	nop
  408238:	400e0400 	.word	0x400e0400

0040823c <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  40823c:	b480      	push	{r7}
  40823e:	b083      	sub	sp, #12
  408240:	af00      	add	r7, sp, #0
  408242:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  408244:	687b      	ldr	r3, [r7, #4]
  408246:	2b2f      	cmp	r3, #47	; 0x2f
  408248:	d901      	bls.n	40824e <pmc_enable_periph_clk+0x12>
		return 1;
  40824a:	2301      	movs	r3, #1
  40824c:	e02f      	b.n	4082ae <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  40824e:	687b      	ldr	r3, [r7, #4]
  408250:	2b1f      	cmp	r3, #31
  408252:	d813      	bhi.n	40827c <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  408254:	4b19      	ldr	r3, [pc, #100]	; (4082bc <pmc_enable_periph_clk+0x80>)
  408256:	699a      	ldr	r2, [r3, #24]
  408258:	2101      	movs	r1, #1
  40825a:	687b      	ldr	r3, [r7, #4]
  40825c:	fa01 f303 	lsl.w	r3, r1, r3
  408260:	401a      	ands	r2, r3
  408262:	2101      	movs	r1, #1
  408264:	687b      	ldr	r3, [r7, #4]
  408266:	fa01 f303 	lsl.w	r3, r1, r3
  40826a:	429a      	cmp	r2, r3
  40826c:	d01e      	beq.n	4082ac <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  40826e:	4a13      	ldr	r2, [pc, #76]	; (4082bc <pmc_enable_periph_clk+0x80>)
  408270:	2101      	movs	r1, #1
  408272:	687b      	ldr	r3, [r7, #4]
  408274:	fa01 f303 	lsl.w	r3, r1, r3
  408278:	6113      	str	r3, [r2, #16]
  40827a:	e017      	b.n	4082ac <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  40827c:	687b      	ldr	r3, [r7, #4]
  40827e:	3b20      	subs	r3, #32
  408280:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  408282:	4b0e      	ldr	r3, [pc, #56]	; (4082bc <pmc_enable_periph_clk+0x80>)
  408284:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  408288:	2101      	movs	r1, #1
  40828a:	687b      	ldr	r3, [r7, #4]
  40828c:	fa01 f303 	lsl.w	r3, r1, r3
  408290:	401a      	ands	r2, r3
  408292:	2101      	movs	r1, #1
  408294:	687b      	ldr	r3, [r7, #4]
  408296:	fa01 f303 	lsl.w	r3, r1, r3
  40829a:	429a      	cmp	r2, r3
  40829c:	d006      	beq.n	4082ac <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  40829e:	4a07      	ldr	r2, [pc, #28]	; (4082bc <pmc_enable_periph_clk+0x80>)
  4082a0:	2101      	movs	r1, #1
  4082a2:	687b      	ldr	r3, [r7, #4]
  4082a4:	fa01 f303 	lsl.w	r3, r1, r3
  4082a8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4082ac:	2300      	movs	r3, #0
}
  4082ae:	4618      	mov	r0, r3
  4082b0:	370c      	adds	r7, #12
  4082b2:	46bd      	mov	sp, r7
  4082b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4082b8:	4770      	bx	lr
  4082ba:	bf00      	nop
  4082bc:	400e0400 	.word	0x400e0400

004082c0 <pmc_disable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_disable_periph_clk(uint32_t ul_id)
{
  4082c0:	b480      	push	{r7}
  4082c2:	b083      	sub	sp, #12
  4082c4:	af00      	add	r7, sp, #0
  4082c6:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  4082c8:	687b      	ldr	r3, [r7, #4]
  4082ca:	2b2f      	cmp	r3, #47	; 0x2f
  4082cc:	d901      	bls.n	4082d2 <pmc_disable_periph_clk+0x12>
		return 1;
  4082ce:	2301      	movs	r3, #1
  4082d0:	e02f      	b.n	408332 <pmc_disable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  4082d2:	687b      	ldr	r3, [r7, #4]
  4082d4:	2b1f      	cmp	r3, #31
  4082d6:	d813      	bhi.n	408300 <pmc_disable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) == (1u << ul_id)) {
  4082d8:	4b19      	ldr	r3, [pc, #100]	; (408340 <pmc_disable_periph_clk+0x80>)
  4082da:	699a      	ldr	r2, [r3, #24]
  4082dc:	2101      	movs	r1, #1
  4082de:	687b      	ldr	r3, [r7, #4]
  4082e0:	fa01 f303 	lsl.w	r3, r1, r3
  4082e4:	401a      	ands	r2, r3
  4082e6:	2101      	movs	r1, #1
  4082e8:	687b      	ldr	r3, [r7, #4]
  4082ea:	fa01 f303 	lsl.w	r3, r1, r3
  4082ee:	429a      	cmp	r2, r3
  4082f0:	d11e      	bne.n	408330 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR0 = 1 << ul_id;
  4082f2:	4a13      	ldr	r2, [pc, #76]	; (408340 <pmc_disable_periph_clk+0x80>)
  4082f4:	2101      	movs	r1, #1
  4082f6:	687b      	ldr	r3, [r7, #4]
  4082f8:	fa01 f303 	lsl.w	r3, r1, r3
  4082fc:	6153      	str	r3, [r2, #20]
  4082fe:	e017      	b.n	408330 <pmc_disable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 \
		|| SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  408300:	687b      	ldr	r3, [r7, #4]
  408302:	3b20      	subs	r3, #32
  408304:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) == (1u << ul_id)) {
  408306:	4b0e      	ldr	r3, [pc, #56]	; (408340 <pmc_disable_periph_clk+0x80>)
  408308:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40830c:	2101      	movs	r1, #1
  40830e:	687b      	ldr	r3, [r7, #4]
  408310:	fa01 f303 	lsl.w	r3, r1, r3
  408314:	401a      	ands	r2, r3
  408316:	2101      	movs	r1, #1
  408318:	687b      	ldr	r3, [r7, #4]
  40831a:	fa01 f303 	lsl.w	r3, r1, r3
  40831e:	429a      	cmp	r2, r3
  408320:	d106      	bne.n	408330 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR1 = 1 << ul_id;
  408322:	4a07      	ldr	r2, [pc, #28]	; (408340 <pmc_disable_periph_clk+0x80>)
  408324:	2101      	movs	r1, #1
  408326:	687b      	ldr	r3, [r7, #4]
  408328:	fa01 f303 	lsl.w	r3, r1, r3
  40832c:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
		}
#endif
	}
	return 0;
  408330:	2300      	movs	r3, #0
}
  408332:	4618      	mov	r0, r3
  408334:	370c      	adds	r7, #12
  408336:	46bd      	mov	sp, r7
  408338:	f85d 7b04 	ldr.w	r7, [sp], #4
  40833c:	4770      	bx	lr
  40833e:	bf00      	nop
  408340:	400e0400 	.word	0x400e0400

00408344 <pmc_switch_udpck_to_pllack>:
 * \brief Switch UDP (USB) clock source selection to PLLA clock.
 *
 * \param ul_usbdiv Clock divisor.
 */
void pmc_switch_udpck_to_pllack(uint32_t ul_usbdiv)
{
  408344:	b480      	push	{r7}
  408346:	b083      	sub	sp, #12
  408348:	af00      	add	r7, sp, #0
  40834a:	6078      	str	r0, [r7, #4]
	PMC->PMC_USB = PMC_USB_USBDIV(ul_usbdiv);
  40834c:	4a05      	ldr	r2, [pc, #20]	; (408364 <pmc_switch_udpck_to_pllack+0x20>)
  40834e:	687b      	ldr	r3, [r7, #4]
  408350:	021b      	lsls	r3, r3, #8
  408352:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
  408356:	6393      	str	r3, [r2, #56]	; 0x38
}
  408358:	bf00      	nop
  40835a:	370c      	adds	r7, #12
  40835c:	46bd      	mov	sp, r7
  40835e:	f85d 7b04 	ldr.w	r7, [sp], #4
  408362:	4770      	bx	lr
  408364:	400e0400 	.word	0x400e0400

00408368 <pmc_enable_udpck>:
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
/**
 * \brief Enable UDP (USB) clock.
 */
void pmc_enable_udpck(void)
{
  408368:	b480      	push	{r7}
  40836a:	af00      	add	r7, sp, #0
#if (SAM3S || SAM4S || SAM4E || SAMG55)
	PMC->PMC_SCER = PMC_SCER_UDP;
  40836c:	4b03      	ldr	r3, [pc, #12]	; (40837c <pmc_enable_udpck+0x14>)
  40836e:	2280      	movs	r2, #128	; 0x80
  408370:	601a      	str	r2, [r3, #0]
#elif (SAMV71 || SAMV70 || SAME70 || SAMS70)
	PMC->PMC_SCER = PMC_SCER_USBCLK;
#else
	PMC->PMC_SCER = PMC_SCER_UOTGCLK;
# endif
}
  408372:	bf00      	nop
  408374:	46bd      	mov	sp, r7
  408376:	f85d 7b04 	ldr.w	r7, [sp], #4
  40837a:	4770      	bx	lr
  40837c:	400e0400 	.word	0x400e0400

00408380 <pmc_set_fast_startup_input>:
 *        (event generation).
 *
 * \param ul_inputs Wake up inputs to enable.
 */
void pmc_set_fast_startup_input(uint32_t ul_inputs)
{
  408380:	b480      	push	{r7}
  408382:	b083      	sub	sp, #12
  408384:	af00      	add	r7, sp, #0
  408386:	6078      	str	r0, [r7, #4]
	ul_inputs &= PMC_FAST_STARTUP_Msk;
  408388:	687b      	ldr	r3, [r7, #4]
  40838a:	f3c3 0312 	ubfx	r3, r3, #0, #19
  40838e:	607b      	str	r3, [r7, #4]
	PMC->PMC_FSMR |= ul_inputs;
  408390:	4905      	ldr	r1, [pc, #20]	; (4083a8 <pmc_set_fast_startup_input+0x28>)
  408392:	4b05      	ldr	r3, [pc, #20]	; (4083a8 <pmc_set_fast_startup_input+0x28>)
  408394:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408396:	687b      	ldr	r3, [r7, #4]
  408398:	4313      	orrs	r3, r2
  40839a:	670b      	str	r3, [r1, #112]	; 0x70
}
  40839c:	bf00      	nop
  40839e:	370c      	adds	r7, #12
  4083a0:	46bd      	mov	sp, r7
  4083a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4083a6:	4770      	bx	lr
  4083a8:	400e0400 	.word	0x400e0400

004083ac <pmc_is_wakeup_clocks_restored>:
#endif
	}
}

bool pmc_is_wakeup_clocks_restored(void)
{
  4083ac:	b480      	push	{r7}
  4083ae:	af00      	add	r7, sp, #0
	return !b_is_sleep_clock_used;
  4083b0:	4b09      	ldr	r3, [pc, #36]	; (4083d8 <pmc_is_wakeup_clocks_restored+0x2c>)
  4083b2:	781b      	ldrb	r3, [r3, #0]
  4083b4:	b2db      	uxtb	r3, r3
  4083b6:	2b00      	cmp	r3, #0
  4083b8:	bf14      	ite	ne
  4083ba:	2301      	movne	r3, #1
  4083bc:	2300      	moveq	r3, #0
  4083be:	b2db      	uxtb	r3, r3
  4083c0:	f083 0301 	eor.w	r3, r3, #1
  4083c4:	b2db      	uxtb	r3, r3
  4083c6:	f003 0301 	and.w	r3, r3, #1
  4083ca:	b2db      	uxtb	r3, r3
}
  4083cc:	4618      	mov	r0, r3
  4083ce:	46bd      	mov	sp, r7
  4083d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4083d4:	4770      	bx	lr
  4083d6:	bf00      	nop
  4083d8:	20008879 	.word	0x20008879

004083dc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4083dc:	b480      	push	{r7}
  4083de:	af00      	add	r7, sp, #0
	while (1) {
  4083e0:	e7fe      	b.n	4083e0 <Dummy_Handler+0x4>
	...

004083e4 <cpu_irq_save>:
{
  4083e4:	b480      	push	{r7}
  4083e6:	b083      	sub	sp, #12
  4083e8:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4083ea:	f3ef 8310 	mrs	r3, PRIMASK
  4083ee:	607b      	str	r3, [r7, #4]
  return(result);
  4083f0:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4083f2:	2b00      	cmp	r3, #0
  4083f4:	bf0c      	ite	eq
  4083f6:	2301      	moveq	r3, #1
  4083f8:	2300      	movne	r3, #0
  4083fa:	b2db      	uxtb	r3, r3
  4083fc:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4083fe:	b672      	cpsid	i
  408400:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  408404:	4b04      	ldr	r3, [pc, #16]	; (408418 <cpu_irq_save+0x34>)
  408406:	2200      	movs	r2, #0
  408408:	701a      	strb	r2, [r3, #0]
	return flags;
  40840a:	683b      	ldr	r3, [r7, #0]
}
  40840c:	4618      	mov	r0, r3
  40840e:	370c      	adds	r7, #12
  408410:	46bd      	mov	sp, r7
  408412:	f85d 7b04 	ldr.w	r7, [sp], #4
  408416:	4770      	bx	lr
  408418:	200001aa 	.word	0x200001aa

0040841c <cpu_irq_is_enabled_flags>:
{
  40841c:	b480      	push	{r7}
  40841e:	b083      	sub	sp, #12
  408420:	af00      	add	r7, sp, #0
  408422:	6078      	str	r0, [r7, #4]
	return (flags);
  408424:	687b      	ldr	r3, [r7, #4]
  408426:	2b00      	cmp	r3, #0
  408428:	bf14      	ite	ne
  40842a:	2301      	movne	r3, #1
  40842c:	2300      	moveq	r3, #0
  40842e:	b2db      	uxtb	r3, r3
}
  408430:	4618      	mov	r0, r3
  408432:	370c      	adds	r7, #12
  408434:	46bd      	mov	sp, r7
  408436:	f85d 7b04 	ldr.w	r7, [sp], #4
  40843a:	4770      	bx	lr

0040843c <cpu_irq_restore>:
{
  40843c:	b580      	push	{r7, lr}
  40843e:	b082      	sub	sp, #8
  408440:	af00      	add	r7, sp, #0
  408442:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  408444:	6878      	ldr	r0, [r7, #4]
  408446:	4b07      	ldr	r3, [pc, #28]	; (408464 <cpu_irq_restore+0x28>)
  408448:	4798      	blx	r3
  40844a:	4603      	mov	r3, r0
  40844c:	2b00      	cmp	r3, #0
  40844e:	d005      	beq.n	40845c <cpu_irq_restore+0x20>
		cpu_irq_enable();
  408450:	4b05      	ldr	r3, [pc, #20]	; (408468 <cpu_irq_restore+0x2c>)
  408452:	2201      	movs	r2, #1
  408454:	701a      	strb	r2, [r3, #0]
  408456:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40845a:	b662      	cpsie	i
}
  40845c:	bf00      	nop
  40845e:	3708      	adds	r7, #8
  408460:	46bd      	mov	sp, r7
  408462:	bd80      	pop	{r7, pc}
  408464:	0040841d 	.word	0x0040841d
  408468:	200001aa 	.word	0x200001aa

0040846c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  40846c:	b580      	push	{r7, lr}
  40846e:	b084      	sub	sp, #16
  408470:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  408472:	4b1e      	ldr	r3, [pc, #120]	; (4084ec <Reset_Handler+0x80>)
  408474:	60fb      	str	r3, [r7, #12]
	pDest = &_srelocate;
  408476:	4b1e      	ldr	r3, [pc, #120]	; (4084f0 <Reset_Handler+0x84>)
  408478:	60bb      	str	r3, [r7, #8]

	if (pSrc != pDest) {
  40847a:	68fa      	ldr	r2, [r7, #12]
  40847c:	68bb      	ldr	r3, [r7, #8]
  40847e:	429a      	cmp	r2, r3
  408480:	d00c      	beq.n	40849c <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  408482:	e007      	b.n	408494 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
  408484:	68bb      	ldr	r3, [r7, #8]
  408486:	1d1a      	adds	r2, r3, #4
  408488:	60ba      	str	r2, [r7, #8]
  40848a:	68fa      	ldr	r2, [r7, #12]
  40848c:	1d11      	adds	r1, r2, #4
  40848e:	60f9      	str	r1, [r7, #12]
  408490:	6812      	ldr	r2, [r2, #0]
  408492:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
  408494:	68bb      	ldr	r3, [r7, #8]
  408496:	4a17      	ldr	r2, [pc, #92]	; (4084f4 <Reset_Handler+0x88>)
  408498:	4293      	cmp	r3, r2
  40849a:	d3f3      	bcc.n	408484 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40849c:	4b16      	ldr	r3, [pc, #88]	; (4084f8 <Reset_Handler+0x8c>)
  40849e:	60bb      	str	r3, [r7, #8]
  4084a0:	e004      	b.n	4084ac <Reset_Handler+0x40>
		*pDest++ = 0;
  4084a2:	68bb      	ldr	r3, [r7, #8]
  4084a4:	1d1a      	adds	r2, r3, #4
  4084a6:	60ba      	str	r2, [r7, #8]
  4084a8:	2200      	movs	r2, #0
  4084aa:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
  4084ac:	68bb      	ldr	r3, [r7, #8]
  4084ae:	4a13      	ldr	r2, [pc, #76]	; (4084fc <Reset_Handler+0x90>)
  4084b0:	4293      	cmp	r3, r2
  4084b2:	d3f6      	bcc.n	4084a2 <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  4084b4:	4b12      	ldr	r3, [pc, #72]	; (408500 <Reset_Handler+0x94>)
  4084b6:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4084b8:	4a12      	ldr	r2, [pc, #72]	; (408504 <Reset_Handler+0x98>)
  4084ba:	68fb      	ldr	r3, [r7, #12]
  4084bc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  4084c0:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  4084c2:	4b11      	ldr	r3, [pc, #68]	; (408508 <Reset_Handler+0x9c>)
  4084c4:	4798      	blx	r3
  4084c6:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  4084c8:	4a10      	ldr	r2, [pc, #64]	; (40850c <Reset_Handler+0xa0>)
  4084ca:	4b10      	ldr	r3, [pc, #64]	; (40850c <Reset_Handler+0xa0>)
  4084cc:	681b      	ldr	r3, [r3, #0]
  4084ce:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4084d2:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb");
  4084d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  4084d8:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  4084dc:	6878      	ldr	r0, [r7, #4]
  4084de:	4b0c      	ldr	r3, [pc, #48]	; (408510 <Reset_Handler+0xa4>)
  4084e0:	4798      	blx	r3
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  4084e2:	4b0c      	ldr	r3, [pc, #48]	; (408514 <Reset_Handler+0xa8>)
  4084e4:	4798      	blx	r3

	/* Branch to main function */
	main();
  4084e6:	4b0c      	ldr	r3, [pc, #48]	; (408518 <Reset_Handler+0xac>)
  4084e8:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  4084ea:	e7fe      	b.n	4084ea <Reset_Handler+0x7e>
  4084ec:	0040af7c 	.word	0x0040af7c
  4084f0:	20000000 	.word	0x20000000
  4084f4:	200009f4 	.word	0x200009f4
  4084f8:	200009f8 	.word	0x200009f8
  4084fc:	200089c8 	.word	0x200089c8
  408500:	00400000 	.word	0x00400000
  408504:	e000ed00 	.word	0xe000ed00
  408508:	004083e5 	.word	0x004083e5
  40850c:	e000ed88 	.word	0xe000ed88
  408510:	0040843d 	.word	0x0040843d
  408514:	0040a065 	.word	0x0040a065
  408518:	00408775 	.word	0x00408775

0040851c <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate( void )
{
  40851c:	b480      	push	{r7}
  40851e:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  408520:	4b52      	ldr	r3, [pc, #328]	; (40866c <SystemCoreClockUpdate+0x150>)
  408522:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  408524:	f003 0303 	and.w	r3, r3, #3
  408528:	2b01      	cmp	r3, #1
  40852a:	d014      	beq.n	408556 <SystemCoreClockUpdate+0x3a>
  40852c:	2b01      	cmp	r3, #1
  40852e:	d302      	bcc.n	408536 <SystemCoreClockUpdate+0x1a>
  408530:	2b02      	cmp	r3, #2
  408532:	d038      	beq.n	4085a6 <SystemCoreClockUpdate+0x8a>
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
		}
		break;

	default:
		break;
  408534:	e07a      	b.n	40862c <SystemCoreClockUpdate+0x110>
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  408536:	4b4e      	ldr	r3, [pc, #312]	; (408670 <SystemCoreClockUpdate+0x154>)
  408538:	695b      	ldr	r3, [r3, #20]
  40853a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40853e:	2b00      	cmp	r3, #0
  408540:	d004      	beq.n	40854c <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  408542:	4b4c      	ldr	r3, [pc, #304]	; (408674 <SystemCoreClockUpdate+0x158>)
  408544:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  408548:	601a      	str	r2, [r3, #0]
		break;
  40854a:	e06f      	b.n	40862c <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40854c:	4b49      	ldr	r3, [pc, #292]	; (408674 <SystemCoreClockUpdate+0x158>)
  40854e:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  408552:	601a      	str	r2, [r3, #0]
		break;
  408554:	e06a      	b.n	40862c <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  408556:	4b45      	ldr	r3, [pc, #276]	; (40866c <SystemCoreClockUpdate+0x150>)
  408558:	6a1b      	ldr	r3, [r3, #32]
  40855a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  40855e:	2b00      	cmp	r3, #0
  408560:	d003      	beq.n	40856a <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  408562:	4b44      	ldr	r3, [pc, #272]	; (408674 <SystemCoreClockUpdate+0x158>)
  408564:	4a44      	ldr	r2, [pc, #272]	; (408678 <SystemCoreClockUpdate+0x15c>)
  408566:	601a      	str	r2, [r3, #0]
		break;
  408568:	e060      	b.n	40862c <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40856a:	4b42      	ldr	r3, [pc, #264]	; (408674 <SystemCoreClockUpdate+0x158>)
  40856c:	4a43      	ldr	r2, [pc, #268]	; (40867c <SystemCoreClockUpdate+0x160>)
  40856e:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  408570:	4b3e      	ldr	r3, [pc, #248]	; (40866c <SystemCoreClockUpdate+0x150>)
  408572:	6a1b      	ldr	r3, [r3, #32]
  408574:	f003 0370 	and.w	r3, r3, #112	; 0x70
  408578:	2b10      	cmp	r3, #16
  40857a:	d004      	beq.n	408586 <SystemCoreClockUpdate+0x6a>
  40857c:	2b20      	cmp	r3, #32
  40857e:	d008      	beq.n	408592 <SystemCoreClockUpdate+0x76>
  408580:	2b00      	cmp	r3, #0
  408582:	d00e      	beq.n	4085a2 <SystemCoreClockUpdate+0x86>
				break;
  408584:	e00e      	b.n	4085a4 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  408586:	4b3b      	ldr	r3, [pc, #236]	; (408674 <SystemCoreClockUpdate+0x158>)
  408588:	681b      	ldr	r3, [r3, #0]
  40858a:	005b      	lsls	r3, r3, #1
  40858c:	4a39      	ldr	r2, [pc, #228]	; (408674 <SystemCoreClockUpdate+0x158>)
  40858e:	6013      	str	r3, [r2, #0]
				break;
  408590:	e008      	b.n	4085a4 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  408592:	4b38      	ldr	r3, [pc, #224]	; (408674 <SystemCoreClockUpdate+0x158>)
  408594:	681a      	ldr	r2, [r3, #0]
  408596:	4613      	mov	r3, r2
  408598:	005b      	lsls	r3, r3, #1
  40859a:	4413      	add	r3, r2
  40859c:	4a35      	ldr	r2, [pc, #212]	; (408674 <SystemCoreClockUpdate+0x158>)
  40859e:	6013      	str	r3, [r2, #0]
				break;
  4085a0:	e000      	b.n	4085a4 <SystemCoreClockUpdate+0x88>
				break;
  4085a2:	bf00      	nop
		break;
  4085a4:	e042      	b.n	40862c <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4085a6:	4b31      	ldr	r3, [pc, #196]	; (40866c <SystemCoreClockUpdate+0x150>)
  4085a8:	6a1b      	ldr	r3, [r3, #32]
  4085aa:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4085ae:	2b00      	cmp	r3, #0
  4085b0:	d003      	beq.n	4085ba <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  4085b2:	4b30      	ldr	r3, [pc, #192]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085b4:	4a30      	ldr	r2, [pc, #192]	; (408678 <SystemCoreClockUpdate+0x15c>)
  4085b6:	601a      	str	r2, [r3, #0]
  4085b8:	e01c      	b.n	4085f4 <SystemCoreClockUpdate+0xd8>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4085ba:	4b2e      	ldr	r3, [pc, #184]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085bc:	4a2f      	ldr	r2, [pc, #188]	; (40867c <SystemCoreClockUpdate+0x160>)
  4085be:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4085c0:	4b2a      	ldr	r3, [pc, #168]	; (40866c <SystemCoreClockUpdate+0x150>)
  4085c2:	6a1b      	ldr	r3, [r3, #32]
  4085c4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4085c8:	2b10      	cmp	r3, #16
  4085ca:	d004      	beq.n	4085d6 <SystemCoreClockUpdate+0xba>
  4085cc:	2b20      	cmp	r3, #32
  4085ce:	d008      	beq.n	4085e2 <SystemCoreClockUpdate+0xc6>
  4085d0:	2b00      	cmp	r3, #0
  4085d2:	d00e      	beq.n	4085f2 <SystemCoreClockUpdate+0xd6>
				break;
  4085d4:	e00e      	b.n	4085f4 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 2U;
  4085d6:	4b27      	ldr	r3, [pc, #156]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085d8:	681b      	ldr	r3, [r3, #0]
  4085da:	005b      	lsls	r3, r3, #1
  4085dc:	4a25      	ldr	r2, [pc, #148]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085de:	6013      	str	r3, [r2, #0]
				break;
  4085e0:	e008      	b.n	4085f4 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 3U;
  4085e2:	4b24      	ldr	r3, [pc, #144]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085e4:	681a      	ldr	r2, [r3, #0]
  4085e6:	4613      	mov	r3, r2
  4085e8:	005b      	lsls	r3, r3, #1
  4085ea:	4413      	add	r3, r2
  4085ec:	4a21      	ldr	r2, [pc, #132]	; (408674 <SystemCoreClockUpdate+0x158>)
  4085ee:	6013      	str	r3, [r2, #0]
				break;
  4085f0:	e000      	b.n	4085f4 <SystemCoreClockUpdate+0xd8>
				break;
  4085f2:	bf00      	nop
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  4085f4:	4b1d      	ldr	r3, [pc, #116]	; (40866c <SystemCoreClockUpdate+0x150>)
  4085f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4085f8:	f003 0303 	and.w	r3, r3, #3
  4085fc:	2b02      	cmp	r3, #2
  4085fe:	d114      	bne.n	40862a <SystemCoreClockUpdate+0x10e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  408600:	4b1a      	ldr	r3, [pc, #104]	; (40866c <SystemCoreClockUpdate+0x150>)
  408602:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  408604:	0c1b      	lsrs	r3, r3, #16
  408606:	f3c3 030a 	ubfx	r3, r3, #0, #11
  40860a:	3301      	adds	r3, #1
  40860c:	4a19      	ldr	r2, [pc, #100]	; (408674 <SystemCoreClockUpdate+0x158>)
  40860e:	6812      	ldr	r2, [r2, #0]
  408610:	fb02 f303 	mul.w	r3, r2, r3
  408614:	4a17      	ldr	r2, [pc, #92]	; (408674 <SystemCoreClockUpdate+0x158>)
  408616:	6013      	str	r3, [r2, #0]
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  408618:	4b14      	ldr	r3, [pc, #80]	; (40866c <SystemCoreClockUpdate+0x150>)
  40861a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40861c:	b2db      	uxtb	r3, r3
  40861e:	4a15      	ldr	r2, [pc, #84]	; (408674 <SystemCoreClockUpdate+0x158>)
  408620:	6812      	ldr	r2, [r2, #0]
  408622:	fbb2 f3f3 	udiv	r3, r2, r3
  408626:	4a13      	ldr	r2, [pc, #76]	; (408674 <SystemCoreClockUpdate+0x158>)
  408628:	6013      	str	r3, [r2, #0]
		break;
  40862a:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  40862c:	4b0f      	ldr	r3, [pc, #60]	; (40866c <SystemCoreClockUpdate+0x150>)
  40862e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  408630:	f003 0370 	and.w	r3, r3, #112	; 0x70
  408634:	2b70      	cmp	r3, #112	; 0x70
  408636:	d108      	bne.n	40864a <SystemCoreClockUpdate+0x12e>
		SystemCoreClock /= 3U;
  408638:	4b0e      	ldr	r3, [pc, #56]	; (408674 <SystemCoreClockUpdate+0x158>)
  40863a:	681b      	ldr	r3, [r3, #0]
  40863c:	4a10      	ldr	r2, [pc, #64]	; (408680 <SystemCoreClockUpdate+0x164>)
  40863e:	fba2 2303 	umull	r2, r3, r2, r3
  408642:	085b      	lsrs	r3, r3, #1
  408644:	4a0b      	ldr	r2, [pc, #44]	; (408674 <SystemCoreClockUpdate+0x158>)
  408646:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
				PMC_MCKR_PRES_Pos);
	}
}
  408648:	e00a      	b.n	408660 <SystemCoreClockUpdate+0x144>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  40864a:	4b08      	ldr	r3, [pc, #32]	; (40866c <SystemCoreClockUpdate+0x150>)
  40864c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40864e:	091b      	lsrs	r3, r3, #4
  408650:	f003 0307 	and.w	r3, r3, #7
  408654:	4a07      	ldr	r2, [pc, #28]	; (408674 <SystemCoreClockUpdate+0x158>)
  408656:	6812      	ldr	r2, [r2, #0]
  408658:	fa22 f303 	lsr.w	r3, r2, r3
  40865c:	4a05      	ldr	r2, [pc, #20]	; (408674 <SystemCoreClockUpdate+0x158>)
  40865e:	6013      	str	r3, [r2, #0]
}
  408660:	bf00      	nop
  408662:	46bd      	mov	sp, r7
  408664:	f85d 7b04 	ldr.w	r7, [sp], #4
  408668:	4770      	bx	lr
  40866a:	bf00      	nop
  40866c:	400e0400 	.word	0x400e0400
  408670:	400e1810 	.word	0x400e1810
  408674:	200001ac 	.word	0x200001ac
  408678:	00b71b00 	.word	0x00b71b00
  40867c:	003d0900 	.word	0x003d0900
  408680:	aaaaaaab 	.word	0xaaaaaaab

00408684 <system_init_flash>:

/**
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  408684:	b480      	push	{r7}
  408686:	b083      	sub	sp, #12
  408688:	af00      	add	r7, sp, #0
  40868a:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  40868c:	687b      	ldr	r3, [r7, #4]
  40868e:	4a19      	ldr	r2, [pc, #100]	; (4086f4 <system_init_flash+0x70>)
  408690:	4293      	cmp	r3, r2
  408692:	d804      	bhi.n	40869e <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  408694:	4b18      	ldr	r3, [pc, #96]	; (4086f8 <system_init_flash+0x74>)
  408696:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40869a:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
}
  40869c:	e023      	b.n	4086e6 <system_init_flash+0x62>
		if (ul_clk < CHIP_FREQ_FWS_1) {
  40869e:	687b      	ldr	r3, [r7, #4]
  4086a0:	4a16      	ldr	r2, [pc, #88]	; (4086fc <system_init_flash+0x78>)
  4086a2:	4293      	cmp	r3, r2
  4086a4:	d803      	bhi.n	4086ae <system_init_flash+0x2a>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4086a6:	4b14      	ldr	r3, [pc, #80]	; (4086f8 <system_init_flash+0x74>)
  4086a8:	4a15      	ldr	r2, [pc, #84]	; (408700 <system_init_flash+0x7c>)
  4086aa:	601a      	str	r2, [r3, #0]
}
  4086ac:	e01b      	b.n	4086e6 <system_init_flash+0x62>
			if (ul_clk < CHIP_FREQ_FWS_2) {
  4086ae:	687b      	ldr	r3, [r7, #4]
  4086b0:	4a14      	ldr	r2, [pc, #80]	; (408704 <system_init_flash+0x80>)
  4086b2:	4293      	cmp	r3, r2
  4086b4:	d803      	bhi.n	4086be <system_init_flash+0x3a>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4086b6:	4b10      	ldr	r3, [pc, #64]	; (4086f8 <system_init_flash+0x74>)
  4086b8:	4a13      	ldr	r2, [pc, #76]	; (408708 <system_init_flash+0x84>)
  4086ba:	601a      	str	r2, [r3, #0]
}
  4086bc:	e013      	b.n	4086e6 <system_init_flash+0x62>
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  4086be:	687b      	ldr	r3, [r7, #4]
  4086c0:	4a12      	ldr	r2, [pc, #72]	; (40870c <system_init_flash+0x88>)
  4086c2:	4293      	cmp	r3, r2
  4086c4:	d803      	bhi.n	4086ce <system_init_flash+0x4a>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  4086c6:	4b0c      	ldr	r3, [pc, #48]	; (4086f8 <system_init_flash+0x74>)
  4086c8:	4a11      	ldr	r2, [pc, #68]	; (408710 <system_init_flash+0x8c>)
  4086ca:	601a      	str	r2, [r3, #0]
}
  4086cc:	e00b      	b.n	4086e6 <system_init_flash+0x62>
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  4086ce:	687b      	ldr	r3, [r7, #4]
  4086d0:	4a10      	ldr	r2, [pc, #64]	; (408714 <system_init_flash+0x90>)
  4086d2:	4293      	cmp	r3, r2
  4086d4:	d804      	bhi.n	4086e0 <system_init_flash+0x5c>
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  4086d6:	4b08      	ldr	r3, [pc, #32]	; (4086f8 <system_init_flash+0x74>)
  4086d8:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  4086dc:	601a      	str	r2, [r3, #0]
}
  4086de:	e002      	b.n	4086e6 <system_init_flash+0x62>
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4086e0:	4b05      	ldr	r3, [pc, #20]	; (4086f8 <system_init_flash+0x74>)
  4086e2:	4a0d      	ldr	r2, [pc, #52]	; (408718 <system_init_flash+0x94>)
  4086e4:	601a      	str	r2, [r3, #0]
}
  4086e6:	bf00      	nop
  4086e8:	370c      	adds	r7, #12
  4086ea:	46bd      	mov	sp, r7
  4086ec:	f85d 7b04 	ldr.w	r7, [sp], #4
  4086f0:	4770      	bx	lr
  4086f2:	bf00      	nop
  4086f4:	01312cff 	.word	0x01312cff
  4086f8:	400e0a00 	.word	0x400e0a00
  4086fc:	026259ff 	.word	0x026259ff
  408700:	04000100 	.word	0x04000100
  408704:	039386ff 	.word	0x039386ff
  408708:	04000200 	.word	0x04000200
  40870c:	04c4b3ff 	.word	0x04c4b3ff
  408710:	04000300 	.word	0x04000300
  408714:	05f5e0ff 	.word	0x05f5e0ff
  408718:	04000500 	.word	0x04000500

0040871c <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
  40871c:	b480      	push	{r7}
  40871e:	b085      	sub	sp, #20
  408720:	af00      	add	r7, sp, #0
  408722:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  408724:	4b10      	ldr	r3, [pc, #64]	; (408768 <_sbrk+0x4c>)
  408726:	60fb      	str	r3, [r7, #12]

	if (heap == NULL) {
  408728:	4b10      	ldr	r3, [pc, #64]	; (40876c <_sbrk+0x50>)
  40872a:	681b      	ldr	r3, [r3, #0]
  40872c:	2b00      	cmp	r3, #0
  40872e:	d102      	bne.n	408736 <_sbrk+0x1a>
		heap = (unsigned char *)&_end;
  408730:	4b0e      	ldr	r3, [pc, #56]	; (40876c <_sbrk+0x50>)
  408732:	4a0f      	ldr	r2, [pc, #60]	; (408770 <_sbrk+0x54>)
  408734:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  408736:	4b0d      	ldr	r3, [pc, #52]	; (40876c <_sbrk+0x50>)
  408738:	681b      	ldr	r3, [r3, #0]
  40873a:	60bb      	str	r3, [r7, #8]

	if (((int)prev_heap + incr) > ramend) {
  40873c:	68ba      	ldr	r2, [r7, #8]
  40873e:	687b      	ldr	r3, [r7, #4]
  408740:	441a      	add	r2, r3
  408742:	68fb      	ldr	r3, [r7, #12]
  408744:	429a      	cmp	r2, r3
  408746:	dd02      	ble.n	40874e <_sbrk+0x32>
		return (caddr_t) -1;	
  408748:	f04f 33ff 	mov.w	r3, #4294967295
  40874c:	e006      	b.n	40875c <_sbrk+0x40>
	}

	heap += incr;
  40874e:	4b07      	ldr	r3, [pc, #28]	; (40876c <_sbrk+0x50>)
  408750:	681a      	ldr	r2, [r3, #0]
  408752:	687b      	ldr	r3, [r7, #4]
  408754:	4413      	add	r3, r2
  408756:	4a05      	ldr	r2, [pc, #20]	; (40876c <_sbrk+0x50>)
  408758:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
  40875a:	68bb      	ldr	r3, [r7, #8]
}
  40875c:	4618      	mov	r0, r3
  40875e:	3714      	adds	r7, #20
  408760:	46bd      	mov	sp, r7
  408762:	f85d 7b04 	ldr.w	r7, [sp], #4
  408766:	4770      	bx	lr
  408768:	2001fffc 	.word	0x2001fffc
  40876c:	2000887c 	.word	0x2000887c
  408770:	2000b9c8 	.word	0x2000b9c8

00408774 <main>:
#include "runtimer.h"
#include "console.h"


int main (void)
{
  408774:	b580      	push	{r7, lr}
  408776:	af00      	add	r7, sp, #0
	/* Insert system clock initialization code here (sysclk_init()). */

    //Initialize interrupt vectors
	irq_initialize_vectors();
	//Enable interrupt controller
	cpu_irq_enable();
  408778:	4b17      	ldr	r3, [pc, #92]	; (4087d8 <main+0x64>)
  40877a:	2201      	movs	r2, #1
  40877c:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb");
  40877e:	f3bf 8f5f 	dmb	sy
  408782:	b662      	cpsie	i
	//Setup and switch to PLL controlled clock
	sysclk_init();
  408784:	4b15      	ldr	r3, [pc, #84]	; (4087dc <main+0x68>)
  408786:	4798      	blx	r3
	//Initalize all board systems
	board_init();
  408788:	4b15      	ldr	r3, [pc, #84]	; (4087e0 <main+0x6c>)
  40878a:	4798      	blx	r3
	//Debug console
	WriteLine("Welcome - Kepler Debug Console - V1.0");
  40878c:	4815      	ldr	r0, [pc, #84]	; (4087e4 <main+0x70>)
  40878e:	4b16      	ldr	r3, [pc, #88]	; (4087e8 <main+0x74>)
  408790:	4798      	blx	r3
	WriteLine("Board Initialization...OK");
  408792:	4816      	ldr	r0, [pc, #88]	; (4087ec <main+0x78>)
  408794:	4b14      	ldr	r3, [pc, #80]	; (4087e8 <main+0x74>)
  408796:	4798      	blx	r3

	//Initialize Kepler Configuration
	SystemConfiguration.pc_com_mode = 0;
  408798:	4b15      	ldr	r3, [pc, #84]	; (4087f0 <main+0x7c>)
  40879a:	2200      	movs	r2, #0
  40879c:	701a      	strb	r2, [r3, #0]
	SystemConfiguration.vehicle_com_mode = 0xFF;
  40879e:	4b14      	ldr	r3, [pc, #80]	; (4087f0 <main+0x7c>)
  4087a0:	22ff      	movs	r2, #255	; 0xff
  4087a2:	705a      	strb	r2, [r3, #1]
	SystemConfiguration.bluetooth_unlocked = false;
  4087a4:	4b12      	ldr	r3, [pc, #72]	; (4087f0 <main+0x7c>)
  4087a6:	2200      	movs	r2, #0
  4087a8:	70da      	strb	r2, [r3, #3]
	SystemConfiguration.in_secure_mode = false;
  4087aa:	4b11      	ldr	r3, [pc, #68]	; (4087f0 <main+0x7c>)
  4087ac:	2200      	movs	r2, #0
  4087ae:	709a      	strb	r2, [r3, #2]
	SystemConfiguration.isotp_mode = 0;
  4087b0:	4b0f      	ldr	r3, [pc, #60]	; (4087f0 <main+0x7c>)
  4087b2:	2200      	movs	r2, #0
  4087b4:	711a      	strb	r2, [r3, #4]
	
	WriteLine("System Configuration...OK");
  4087b6:	480f      	ldr	r0, [pc, #60]	; (4087f4 <main+0x80>)
  4087b8:	4b0b      	ldr	r3, [pc, #44]	; (4087e8 <main+0x74>)
  4087ba:	4798      	blx	r3
	WriteLine("System...RUNNING");
  4087bc:	480e      	ldr	r0, [pc, #56]	; (4087f8 <main+0x84>)
  4087be:	4b0a      	ldr	r3, [pc, #40]	; (4087e8 <main+0x74>)
  4087c0:	4798      	blx	r3
	
	//Loop and handle commands forever
	while(1)
	{
	 	if(MessageAvailable == 1)
  4087c2:	4b0e      	ldr	r3, [pc, #56]	; (4087fc <main+0x88>)
  4087c4:	781b      	ldrb	r3, [r3, #0]
  4087c6:	2b01      	cmp	r3, #1
  4087c8:	d1fb      	bne.n	4087c2 <main+0x4e>
		{
			//Got a message, handle it
			HandleMessage(&IncommingMessage);
  4087ca:	480d      	ldr	r0, [pc, #52]	; (408800 <main+0x8c>)
  4087cc:	4b0d      	ldr	r3, [pc, #52]	; (408804 <main+0x90>)
  4087ce:	4798      	blx	r3
			MessageAvailable = 0;
  4087d0:	4b0a      	ldr	r3, [pc, #40]	; (4087fc <main+0x88>)
  4087d2:	2200      	movs	r2, #0
  4087d4:	701a      	strb	r2, [r3, #0]
	 	if(MessageAvailable == 1)
  4087d6:	e7f4      	b.n	4087c2 <main+0x4e>
  4087d8:	200001aa 	.word	0x200001aa
  4087dc:	004078f5 	.word	0x004078f5
  4087e0:	00407f7d 	.word	0x00407f7d
  4087e4:	0040acd8 	.word	0x0040acd8
  4087e8:	0040134b 	.word	0x0040134b
  4087ec:	0040ad00 	.word	0x0040ad00
  4087f0:	20008880 	.word	0x20008880
  4087f4:	0040ad1c 	.word	0x0040ad1c
  4087f8:	0040ad38 	.word	0x0040ad38
  4087fc:	20001db8 	.word	0x20001db8
  408800:	2000892c 	.word	0x2000892c
  408804:	004017f9 	.word	0x004017f9

00408808 <isotp_init_shims>:
/* void isotp_set_timeout(IsoTpHandler* handler, uint16_t timeout_ms) { */
    /* handler->timeout_ms = timeout_ms; */
/* } */

IsoTpShims isotp_init_shims(LogShim log, SendCanMessageShim send_can_message,
        SetTimerShim set_timer, DelayMilliShim delay) {
  408808:	b4b0      	push	{r4, r5, r7}
  40880a:	b08b      	sub	sp, #44	; 0x2c
  40880c:	af00      	add	r7, sp, #0
  40880e:	60f8      	str	r0, [r7, #12]
  408810:	60b9      	str	r1, [r7, #8]
  408812:	607a      	str	r2, [r7, #4]
  408814:	603b      	str	r3, [r7, #0]
    IsoTpShims shims = {
  408816:	68bb      	ldr	r3, [r7, #8]
  408818:	617b      	str	r3, [r7, #20]
  40881a:	687b      	ldr	r3, [r7, #4]
  40881c:	61bb      	str	r3, [r7, #24]
  40881e:	683b      	ldr	r3, [r7, #0]
  408820:	61fb      	str	r3, [r7, #28]
  408822:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  408824:	623b      	str	r3, [r7, #32]
  408826:	2301      	movs	r3, #1
  408828:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        send_can_message: send_can_message,
        set_timer: set_timer,
		DelayMillis: delay,
        frame_padding: ISO_TP_DEFAULT_FRAME_PADDING_STATUS
    };
    return shims;
  40882c:	68fb      	ldr	r3, [r7, #12]
  40882e:	461d      	mov	r5, r3
  408830:	f107 0414 	add.w	r4, r7, #20
  408834:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408836:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  408838:	6823      	ldr	r3, [r4, #0]
  40883a:	602b      	str	r3, [r5, #0]
}
  40883c:	68f8      	ldr	r0, [r7, #12]
  40883e:	372c      	adds	r7, #44	; 0x2c
  408840:	46bd      	mov	sp, r7
  408842:	bcb0      	pop	{r4, r5, r7}
  408844:	4770      	bx	lr

00408846 <isotp_receive>:
    return true;
}


IsoTpReceiveHandle isotp_receive(IsoTpShims* shims,
        const uint32_t arbitration_id, IsoTpMessageReceivedHandler callback) {
  408846:	b4b0      	push	{r4, r5, r7}
  408848:	b08b      	sub	sp, #44	; 0x2c
  40884a:	af00      	add	r7, sp, #0
  40884c:	60f8      	str	r0, [r7, #12]
  40884e:	60b9      	str	r1, [r7, #8]
  408850:	607a      	str	r2, [r7, #4]
  408852:	603b      	str	r3, [r7, #0]
    IsoTpReceiveHandle handle = {
  408854:	f107 0310 	add.w	r3, r7, #16
  408858:	2200      	movs	r2, #0
  40885a:	601a      	str	r2, [r3, #0]
  40885c:	605a      	str	r2, [r3, #4]
  40885e:	609a      	str	r2, [r3, #8]
  408860:	60da      	str	r2, [r3, #12]
  408862:	611a      	str	r2, [r3, #16]
  408864:	615a      	str	r2, [r3, #20]
  408866:	687b      	ldr	r3, [r7, #4]
  408868:	617b      	str	r3, [r7, #20]
  40886a:	683b      	ldr	r3, [r7, #0]
  40886c:	61bb      	str	r3, [r7, #24]
        completed: false,
        arbitration_id: arbitration_id,
        message_received_callback: callback
    };

    return handle;
  40886e:	68fb      	ldr	r3, [r7, #12]
  408870:	461d      	mov	r5, r3
  408872:	f107 0410 	add.w	r4, r7, #16
  408876:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408878:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  40887a:	e894 0003 	ldmia.w	r4, {r0, r1}
  40887e:	e885 0003 	stmia.w	r5, {r0, r1}
}
  408882:	68f8      	ldr	r0, [r7, #12]
  408884:	372c      	adds	r7, #44	; 0x2c
  408886:	46bd      	mov	sp, r7
  408888:	bcb0      	pop	{r4, r5, r7}
  40888a:	4770      	bx	lr

0040888c <isotp_complete_send>:
 * the time crunch demands an answer now. TODO HERE!
 */
IsoTpSendHandle CurrentHandle;

void isotp_complete_send(IsoTpShims* shims, IsoTpMessage* message,
        bool status, IsoTpMessageSentHandler callback) {
  40888c:	b580      	push	{r7, lr}
  40888e:	b084      	sub	sp, #16
  408890:	af00      	add	r7, sp, #0
  408892:	60f8      	str	r0, [r7, #12]
  408894:	60b9      	str	r1, [r7, #8]
  408896:	603b      	str	r3, [r7, #0]
  408898:	4613      	mov	r3, r2
  40889a:	71fb      	strb	r3, [r7, #7]
    if(callback != NULL) {
  40889c:	683b      	ldr	r3, [r7, #0]
  40889e:	2b00      	cmp	r3, #0
  4088a0:	d004      	beq.n	4088ac <isotp_complete_send+0x20>
        callback(message, status);
  4088a2:	79fa      	ldrb	r2, [r7, #7]
  4088a4:	683b      	ldr	r3, [r7, #0]
  4088a6:	4611      	mov	r1, r2
  4088a8:	68b8      	ldr	r0, [r7, #8]
  4088aa:	4798      	blx	r3
    }
}
  4088ac:	bf00      	nop
  4088ae:	3710      	adds	r7, #16
  4088b0:	46bd      	mov	sp, r7
  4088b2:	bd80      	pop	{r7, pc}

004088b4 <isotp_send_single_frame_ext>:
// send CAN message that can be contained within 1 8-byte frame (7 byte message max)
IsoTpSendHandle isotp_send_single_frame_ext(IsoTpShims* shims, IsoTpMessage* message,
IsoTpMessageSentHandler callback) {
  4088b4:	b5b0      	push	{r4, r5, r7, lr}
  4088b6:	b08e      	sub	sp, #56	; 0x38
  4088b8:	af00      	add	r7, sp, #0
  4088ba:	60f8      	str	r0, [r7, #12]
  4088bc:	60b9      	str	r1, [r7, #8]
  4088be:	607a      	str	r2, [r7, #4]
  4088c0:	603b      	str	r3, [r7, #0]
	// create the send handle
	IsoTpSendHandle handle = {
  4088c2:	f107 0320 	add.w	r3, r7, #32
  4088c6:	2200      	movs	r2, #0
  4088c8:	601a      	str	r2, [r3, #0]
  4088ca:	605a      	str	r2, [r3, #4]
  4088cc:	609a      	str	r2, [r3, #8]
  4088ce:	60da      	str	r2, [r3, #12]
  4088d0:	611a      	str	r2, [r3, #16]
  4088d2:	615a      	str	r2, [r3, #20]
  4088d4:	2301      	movs	r3, #1
  4088d6:	f887 3020 	strb.w	r3, [r7, #32]
  4088da:	687b      	ldr	r3, [r7, #4]
  4088dc:	627b      	str	r3, [r7, #36]	; 0x24
		completed: true,
		message_ptr: message
	};

	// create the CAN frame array
	uint8_t can_data[CAN_MESSAGE_BYTE_COUNT + 4] = {0};
  4088de:	f107 0314 	add.w	r3, r7, #20
  4088e2:	2200      	movs	r2, #0
  4088e4:	601a      	str	r2, [r3, #0]
  4088e6:	605a      	str	r2, [r3, #4]
  4088e8:	609a      	str	r2, [r3, #8]
		
	can_data[0] = (message->arbitration_id >> 24) & 0xFF;
  4088ea:	687b      	ldr	r3, [r7, #4]
  4088ec:	681b      	ldr	r3, [r3, #0]
  4088ee:	0e1b      	lsrs	r3, r3, #24
  4088f0:	b2db      	uxtb	r3, r3
  4088f2:	753b      	strb	r3, [r7, #20]
	can_data[1] = (message->arbitration_id >> 16) & 0xFF;
  4088f4:	687b      	ldr	r3, [r7, #4]
  4088f6:	681b      	ldr	r3, [r3, #0]
  4088f8:	0c1b      	lsrs	r3, r3, #16
  4088fa:	b2db      	uxtb	r3, r3
  4088fc:	757b      	strb	r3, [r7, #21]
	can_data[2] = (message->arbitration_id >> 8) & 0xFF;
  4088fe:	687b      	ldr	r3, [r7, #4]
  408900:	681b      	ldr	r3, [r3, #0]
  408902:	0a1b      	lsrs	r3, r3, #8
  408904:	b2db      	uxtb	r3, r3
  408906:	75bb      	strb	r3, [r7, #22]
	can_data[3] = message->arbitration_id & 0xFF;
  408908:	687b      	ldr	r3, [r7, #4]
  40890a:	681b      	ldr	r3, [r3, #0]
  40890c:	b2db      	uxtb	r3, r3
  40890e:	75fb      	strb	r3, [r7, #23]
	
	// set nibble 0 = 0 to define message as single frame
	if(!set_nibble(PCI_NIBBLE_INDEX+2, PCI_SINGLE, can_data, sizeof(can_data))) {
  408910:	f107 0214 	add.w	r2, r7, #20
  408914:	230c      	movs	r3, #12
  408916:	2100      	movs	r1, #0
  408918:	200a      	movs	r0, #10
  40891a:	4c39      	ldr	r4, [pc, #228]	; (408a00 <isotp_send_single_frame_ext+0x14c>)
  40891c:	47a0      	blx	r4
  40891e:	4603      	mov	r3, r0
  408920:	f083 0301 	eor.w	r3, r3, #1
  408924:	b2db      	uxtb	r3, r3
  408926:	2b00      	cmp	r3, #0
  408928:	d00e      	beq.n	408948 <isotp_send_single_frame_ext+0x94>
		shims->log("Unable to set PCI in CAN data");
  40892a:	68bb      	ldr	r3, [r7, #8]
  40892c:	681b      	ldr	r3, [r3, #0]
  40892e:	4835      	ldr	r0, [pc, #212]	; (408a04 <isotp_send_single_frame_ext+0x150>)
  408930:	4798      	blx	r3
		return handle;
  408932:	68fb      	ldr	r3, [r7, #12]
  408934:	461d      	mov	r5, r3
  408936:	f107 0420 	add.w	r4, r7, #32
  40893a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  40893c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  40893e:	e894 0003 	ldmia.w	r4, {r0, r1}
  408942:	e885 0003 	stmia.w	r5, {r0, r1}
  408946:	e057      	b.n	4089f8 <isotp_send_single_frame_ext+0x144>
	}

	// set nibble 1 = can message length
	if(!set_nibble(PAYLOAD_LENGTH_NIBBLE_INDEX+2, message->size-2, can_data,
  408948:	687b      	ldr	r3, [r7, #4]
  40894a:	891b      	ldrh	r3, [r3, #8]
  40894c:	b2db      	uxtb	r3, r3
  40894e:	3b02      	subs	r3, #2
  408950:	b2d9      	uxtb	r1, r3
  408952:	f107 0214 	add.w	r2, r7, #20
  408956:	230c      	movs	r3, #12
  408958:	200b      	movs	r0, #11
  40895a:	4c29      	ldr	r4, [pc, #164]	; (408a00 <isotp_send_single_frame_ext+0x14c>)
  40895c:	47a0      	blx	r4
  40895e:	4603      	mov	r3, r0
  408960:	f083 0301 	eor.w	r3, r3, #1
  408964:	b2db      	uxtb	r3, r3
  408966:	2b00      	cmp	r3, #0
  408968:	d00e      	beq.n	408988 <isotp_send_single_frame_ext+0xd4>
	sizeof(can_data))) {
		shims->log("Unable to set payload length in CAN data");
  40896a:	68bb      	ldr	r3, [r7, #8]
  40896c:	681b      	ldr	r3, [r3, #0]
  40896e:	4826      	ldr	r0, [pc, #152]	; (408a08 <isotp_send_single_frame_ext+0x154>)
  408970:	4798      	blx	r3
		return handle;
  408972:	68fb      	ldr	r3, [r7, #12]
  408974:	461d      	mov	r5, r3
  408976:	f107 0420 	add.w	r4, r7, #32
  40897a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  40897c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  40897e:	e894 0003 	ldmia.w	r4, {r0, r1}
  408982:	e885 0003 	stmia.w	r5, {r0, r1}
  408986:	e037      	b.n	4089f8 <isotp_send_single_frame_ext+0x144>
	}

	// copy the CAN message into the frame array
	if(message->size > 0) {
  408988:	687b      	ldr	r3, [r7, #4]
  40898a:	891b      	ldrh	r3, [r3, #8]
  40898c:	2b00      	cmp	r3, #0
  40898e:	d00c      	beq.n	4089aa <isotp_send_single_frame_ext+0xf6>
		memcpy(&can_data[6], message->payload + 2, message->size - 2);
  408990:	687b      	ldr	r3, [r7, #4]
  408992:	68db      	ldr	r3, [r3, #12]
  408994:	1c99      	adds	r1, r3, #2
  408996:	687b      	ldr	r3, [r7, #4]
  408998:	891b      	ldrh	r3, [r3, #8]
  40899a:	3b02      	subs	r3, #2
  40899c:	461a      	mov	r2, r3
  40899e:	f107 0314 	add.w	r3, r7, #20
  4089a2:	3306      	adds	r3, #6
  4089a4:	4618      	mov	r0, r3
  4089a6:	4b19      	ldr	r3, [pc, #100]	; (408a0c <isotp_send_single_frame_ext+0x158>)
  4089a8:	4798      	blx	r3
	}
 can_data[4] = message->extended_address;
  4089aa:	687b      	ldr	r3, [r7, #4]
  4089ac:	7c1b      	ldrb	r3, [r3, #16]
  4089ae:	763b      	strb	r3, [r7, #24]
	// write the message to the CAN bus and note send success
	shims->send_can_message(0, can_data,
  4089b0:	68bb      	ldr	r3, [r7, #8]
  4089b2:	685b      	ldr	r3, [r3, #4]
	shims->frame_padding ? 8 : 1 + message->size-2);
  4089b4:	68ba      	ldr	r2, [r7, #8]
  4089b6:	7c12      	ldrb	r2, [r2, #16]
	shims->send_can_message(0, can_data,
  4089b8:	2a00      	cmp	r2, #0
  4089ba:	d001      	beq.n	4089c0 <isotp_send_single_frame_ext+0x10c>
  4089bc:	2208      	movs	r2, #8
  4089be:	e004      	b.n	4089ca <isotp_send_single_frame_ext+0x116>
	shims->frame_padding ? 8 : 1 + message->size-2);
  4089c0:	687a      	ldr	r2, [r7, #4]
  4089c2:	8912      	ldrh	r2, [r2, #8]
  4089c4:	b2d2      	uxtb	r2, r2
	shims->send_can_message(0, can_data,
  4089c6:	3a01      	subs	r2, #1
  4089c8:	b2d2      	uxtb	r2, r2
  4089ca:	f107 0114 	add.w	r1, r7, #20
  4089ce:	2000      	movs	r0, #0
  4089d0:	4798      	blx	r3
	handle.success = true;
  4089d2:	2301      	movs	r3, #1
  4089d4:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
	isotp_complete_send(shims, message, true, callback);
  4089d8:	683b      	ldr	r3, [r7, #0]
  4089da:	2201      	movs	r2, #1
  4089dc:	6879      	ldr	r1, [r7, #4]
  4089de:	68b8      	ldr	r0, [r7, #8]
  4089e0:	4c0b      	ldr	r4, [pc, #44]	; (408a10 <isotp_send_single_frame_ext+0x15c>)
  4089e2:	47a0      	blx	r4
	return handle;
  4089e4:	68fb      	ldr	r3, [r7, #12]
  4089e6:	461d      	mov	r5, r3
  4089e8:	f107 0420 	add.w	r4, r7, #32
  4089ec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  4089ee:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  4089f0:	e894 0003 	ldmia.w	r4, {r0, r1}
  4089f4:	e885 0003 	stmia.w	r5, {r0, r1}
}
  4089f8:	68f8      	ldr	r0, [r7, #12]
  4089fa:	3738      	adds	r7, #56	; 0x38
  4089fc:	46bd      	mov	sp, r7
  4089fe:	bdb0      	pop	{r4, r5, r7, pc}
  408a00:	00409149 	.word	0x00409149
  408a04:	0040ad4c 	.word	0x0040ad4c
  408a08:	0040ad6c 	.word	0x0040ad6c
  408a0c:	0040a635 	.word	0x0040a635
  408a10:	0040888d 	.word	0x0040888d

00408a14 <isotp_send_single_frame>:
// send CAN message that can be contained within 1 8-byte frame (6 byte message max)
IsoTpSendHandle isotp_send_single_frame(IsoTpShims* shims, IsoTpMessage* message,
        IsoTpMessageSentHandler callback) {
  408a14:	b5b0      	push	{r4, r5, r7, lr}
  408a16:	b08e      	sub	sp, #56	; 0x38
  408a18:	af00      	add	r7, sp, #0
  408a1a:	60f8      	str	r0, [r7, #12]
  408a1c:	60b9      	str	r1, [r7, #8]
  408a1e:	607a      	str	r2, [r7, #4]
  408a20:	603b      	str	r3, [r7, #0]
	// create the send handle
    IsoTpSendHandle handle = {
  408a22:	f107 0320 	add.w	r3, r7, #32
  408a26:	2200      	movs	r2, #0
  408a28:	601a      	str	r2, [r3, #0]
  408a2a:	605a      	str	r2, [r3, #4]
  408a2c:	609a      	str	r2, [r3, #8]
  408a2e:	60da      	str	r2, [r3, #12]
  408a30:	611a      	str	r2, [r3, #16]
  408a32:	615a      	str	r2, [r3, #20]
  408a34:	2301      	movs	r3, #1
  408a36:	f887 3020 	strb.w	r3, [r7, #32]
  408a3a:	687b      	ldr	r3, [r7, #4]
  408a3c:	627b      	str	r3, [r7, #36]	; 0x24
        completed: true,
		message_ptr: message
    };

	// create the CAN frame array
    uint8_t can_data[CAN_MESSAGE_BYTE_COUNT + 4] = {0};
  408a3e:	f107 0314 	add.w	r3, r7, #20
  408a42:	2200      	movs	r2, #0
  408a44:	601a      	str	r2, [r3, #0]
  408a46:	605a      	str	r2, [r3, #4]
  408a48:	609a      	str	r2, [r3, #8]
	
	can_data[0] = (message->arbitration_id >> 24) & 0xFF;
  408a4a:	687b      	ldr	r3, [r7, #4]
  408a4c:	681b      	ldr	r3, [r3, #0]
  408a4e:	0e1b      	lsrs	r3, r3, #24
  408a50:	b2db      	uxtb	r3, r3
  408a52:	753b      	strb	r3, [r7, #20]
	can_data[1] = (message->arbitration_id >> 16) & 0xFF;
  408a54:	687b      	ldr	r3, [r7, #4]
  408a56:	681b      	ldr	r3, [r3, #0]
  408a58:	0c1b      	lsrs	r3, r3, #16
  408a5a:	b2db      	uxtb	r3, r3
  408a5c:	757b      	strb	r3, [r7, #21]
	can_data[2] = (message->arbitration_id >> 8) & 0xFF;
  408a5e:	687b      	ldr	r3, [r7, #4]
  408a60:	681b      	ldr	r3, [r3, #0]
  408a62:	0a1b      	lsrs	r3, r3, #8
  408a64:	b2db      	uxtb	r3, r3
  408a66:	75bb      	strb	r3, [r7, #22]
	can_data[3] = message->arbitration_id & 0xFF;
  408a68:	687b      	ldr	r3, [r7, #4]
  408a6a:	681b      	ldr	r3, [r3, #0]
  408a6c:	b2db      	uxtb	r3, r3
  408a6e:	75fb      	strb	r3, [r7, #23]
	
	// set nibble 0 = 0 to define message as single frame
    if(!set_nibble(PCI_NIBBLE_INDEX, PCI_SINGLE, can_data, sizeof(can_data))) {
  408a70:	f107 0214 	add.w	r2, r7, #20
  408a74:	230c      	movs	r3, #12
  408a76:	2100      	movs	r1, #0
  408a78:	2008      	movs	r0, #8
  408a7a:	4c38      	ldr	r4, [pc, #224]	; (408b5c <isotp_send_single_frame+0x148>)
  408a7c:	47a0      	blx	r4
  408a7e:	4603      	mov	r3, r0
  408a80:	f083 0301 	eor.w	r3, r3, #1
  408a84:	b2db      	uxtb	r3, r3
  408a86:	2b00      	cmp	r3, #0
  408a88:	d00e      	beq.n	408aa8 <isotp_send_single_frame+0x94>
        shims->log("Unable to set PCI in CAN data");
  408a8a:	68bb      	ldr	r3, [r7, #8]
  408a8c:	681b      	ldr	r3, [r3, #0]
  408a8e:	4834      	ldr	r0, [pc, #208]	; (408b60 <isotp_send_single_frame+0x14c>)
  408a90:	4798      	blx	r3
        return handle;
  408a92:	68fb      	ldr	r3, [r7, #12]
  408a94:	461d      	mov	r5, r3
  408a96:	f107 0420 	add.w	r4, r7, #32
  408a9a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408a9c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  408a9e:	e894 0003 	ldmia.w	r4, {r0, r1}
  408aa2:	e885 0003 	stmia.w	r5, {r0, r1}
  408aa6:	e054      	b.n	408b52 <isotp_send_single_frame+0x13e>
    }

	// set nibble 1 = can message length
    if(!set_nibble(PAYLOAD_LENGTH_NIBBLE_INDEX, message->size-2, can_data,
  408aa8:	687b      	ldr	r3, [r7, #4]
  408aaa:	891b      	ldrh	r3, [r3, #8]
  408aac:	b2db      	uxtb	r3, r3
  408aae:	3b02      	subs	r3, #2
  408ab0:	b2d9      	uxtb	r1, r3
  408ab2:	f107 0214 	add.w	r2, r7, #20
  408ab6:	230c      	movs	r3, #12
  408ab8:	2009      	movs	r0, #9
  408aba:	4c28      	ldr	r4, [pc, #160]	; (408b5c <isotp_send_single_frame+0x148>)
  408abc:	47a0      	blx	r4
  408abe:	4603      	mov	r3, r0
  408ac0:	f083 0301 	eor.w	r3, r3, #1
  408ac4:	b2db      	uxtb	r3, r3
  408ac6:	2b00      	cmp	r3, #0
  408ac8:	d00e      	beq.n	408ae8 <isotp_send_single_frame+0xd4>
                sizeof(can_data))) {
        shims->log("Unable to set payload length in CAN data");
  408aca:	68bb      	ldr	r3, [r7, #8]
  408acc:	681b      	ldr	r3, [r3, #0]
  408ace:	4825      	ldr	r0, [pc, #148]	; (408b64 <isotp_send_single_frame+0x150>)
  408ad0:	4798      	blx	r3
        return handle;
  408ad2:	68fb      	ldr	r3, [r7, #12]
  408ad4:	461d      	mov	r5, r3
  408ad6:	f107 0420 	add.w	r4, r7, #32
  408ada:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408adc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  408ade:	e894 0003 	ldmia.w	r4, {r0, r1}
  408ae2:	e885 0003 	stmia.w	r5, {r0, r1}
  408ae6:	e034      	b.n	408b52 <isotp_send_single_frame+0x13e>
    }

	// copy the CAN message into the frame array
    if(message->size > 0) {
  408ae8:	687b      	ldr	r3, [r7, #4]
  408aea:	891b      	ldrh	r3, [r3, #8]
  408aec:	2b00      	cmp	r3, #0
  408aee:	d00c      	beq.n	408b0a <isotp_send_single_frame+0xf6>
        memcpy(&can_data[PAYLOAD_BYTE_INDEX], message->payload+2, message->size-2);
  408af0:	687b      	ldr	r3, [r7, #4]
  408af2:	68db      	ldr	r3, [r3, #12]
  408af4:	1c99      	adds	r1, r3, #2
  408af6:	687b      	ldr	r3, [r7, #4]
  408af8:	891b      	ldrh	r3, [r3, #8]
  408afa:	3b02      	subs	r3, #2
  408afc:	461a      	mov	r2, r3
  408afe:	f107 0314 	add.w	r3, r7, #20
  408b02:	3305      	adds	r3, #5
  408b04:	4618      	mov	r0, r3
  408b06:	4b18      	ldr	r3, [pc, #96]	; (408b68 <isotp_send_single_frame+0x154>)
  408b08:	4798      	blx	r3
    }

	// write the message to the CAN bus and note send success
    shims->send_can_message(0, can_data,
  408b0a:	68bb      	ldr	r3, [r7, #8]
  408b0c:	685b      	ldr	r3, [r3, #4]
            shims->frame_padding ? 8 : 1 + message->size-2);
  408b0e:	68ba      	ldr	r2, [r7, #8]
  408b10:	7c12      	ldrb	r2, [r2, #16]
    shims->send_can_message(0, can_data,
  408b12:	2a00      	cmp	r2, #0
  408b14:	d001      	beq.n	408b1a <isotp_send_single_frame+0x106>
  408b16:	2208      	movs	r2, #8
  408b18:	e004      	b.n	408b24 <isotp_send_single_frame+0x110>
            shims->frame_padding ? 8 : 1 + message->size-2);
  408b1a:	687a      	ldr	r2, [r7, #4]
  408b1c:	8912      	ldrh	r2, [r2, #8]
  408b1e:	b2d2      	uxtb	r2, r2
    shims->send_can_message(0, can_data,
  408b20:	3a01      	subs	r2, #1
  408b22:	b2d2      	uxtb	r2, r2
  408b24:	f107 0114 	add.w	r1, r7, #20
  408b28:	2000      	movs	r0, #0
  408b2a:	4798      	blx	r3
    handle.success = true;
  408b2c:	2301      	movs	r3, #1
  408b2e:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    isotp_complete_send(shims, message, true, callback);
  408b32:	683b      	ldr	r3, [r7, #0]
  408b34:	2201      	movs	r2, #1
  408b36:	6879      	ldr	r1, [r7, #4]
  408b38:	68b8      	ldr	r0, [r7, #8]
  408b3a:	4c0c      	ldr	r4, [pc, #48]	; (408b6c <isotp_send_single_frame+0x158>)
  408b3c:	47a0      	blx	r4
    return handle;
  408b3e:	68fb      	ldr	r3, [r7, #12]
  408b40:	461d      	mov	r5, r3
  408b42:	f107 0420 	add.w	r4, r7, #32
  408b46:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408b48:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  408b4a:	e894 0003 	ldmia.w	r4, {r0, r1}
  408b4e:	e885 0003 	stmia.w	r5, {r0, r1}
}
  408b52:	68f8      	ldr	r0, [r7, #12]
  408b54:	3738      	adds	r7, #56	; 0x38
  408b56:	46bd      	mov	sp, r7
  408b58:	bdb0      	pop	{r4, r5, r7, pc}
  408b5a:	bf00      	nop
  408b5c:	00409149 	.word	0x00409149
  408b60:	0040ad4c 	.word	0x0040ad4c
  408b64:	0040ad6c 	.word	0x0040ad6c
  408b68:	0040a635 	.word	0x0040a635
  408b6c:	0040888d 	.word	0x0040888d

00408b70 <isotp_send_first_frame>:

bool isotp_send_first_frame(IsoTpShims* shims, IsoTpSendHandle *Handle)
{
  408b70:	b590      	push	{r4, r7, lr}
  408b72:	b089      	sub	sp, #36	; 0x24
  408b74:	af02      	add	r7, sp, #8
  408b76:	6078      	str	r0, [r7, #4]
  408b78:	6039      	str	r1, [r7, #0]
	// create the CAN frame array
	uint8_t can_data[CAN_MESSAGE_BYTE_COUNT + 4] = {0};
  408b7a:	f107 030c 	add.w	r3, r7, #12
  408b7e:	2200      	movs	r2, #0
  408b80:	601a      	str	r2, [r3, #0]
  408b82:	605a      	str	r2, [r3, #4]
  408b84:	609a      	str	r2, [r3, #8]
	
	can_data[0] = (Handle->message_ptr->arbitration_id >> 24) & 0xFF;
  408b86:	683b      	ldr	r3, [r7, #0]
  408b88:	685b      	ldr	r3, [r3, #4]
  408b8a:	681b      	ldr	r3, [r3, #0]
  408b8c:	0e1b      	lsrs	r3, r3, #24
  408b8e:	b2db      	uxtb	r3, r3
  408b90:	733b      	strb	r3, [r7, #12]
	can_data[1] = (Handle->message_ptr->arbitration_id >> 16) & 0xFF;
  408b92:	683b      	ldr	r3, [r7, #0]
  408b94:	685b      	ldr	r3, [r3, #4]
  408b96:	681b      	ldr	r3, [r3, #0]
  408b98:	0c1b      	lsrs	r3, r3, #16
  408b9a:	b2db      	uxtb	r3, r3
  408b9c:	737b      	strb	r3, [r7, #13]
	can_data[2] = (Handle->message_ptr->arbitration_id >> 8) & 0xFF;
  408b9e:	683b      	ldr	r3, [r7, #0]
  408ba0:	685b      	ldr	r3, [r3, #4]
  408ba2:	681b      	ldr	r3, [r3, #0]
  408ba4:	0a1b      	lsrs	r3, r3, #8
  408ba6:	b2db      	uxtb	r3, r3
  408ba8:	73bb      	strb	r3, [r7, #14]
	can_data[3] = Handle->message_ptr->arbitration_id & 0xFF;
  408baa:	683b      	ldr	r3, [r7, #0]
  408bac:	685b      	ldr	r3, [r3, #4]
  408bae:	681b      	ldr	r3, [r3, #0]
  408bb0:	b2db      	uxtb	r3, r3
  408bb2:	73fb      	strb	r3, [r7, #15]
	
	// set nibble 0 = 1 to define message as first frame of multi-frame sequence
	if(!set_nibble(PCI_NIBBLE_INDEX, PCI_FIRST_FRAME, can_data, sizeof(can_data))) {
  408bb4:	f107 020c 	add.w	r2, r7, #12
  408bb8:	230c      	movs	r3, #12
  408bba:	2101      	movs	r1, #1
  408bbc:	2008      	movs	r0, #8
  408bbe:	4c2a      	ldr	r4, [pc, #168]	; (408c68 <isotp_send_first_frame+0xf8>)
  408bc0:	47a0      	blx	r4
  408bc2:	4603      	mov	r3, r0
  408bc4:	f083 0301 	eor.w	r3, r3, #1
  408bc8:	b2db      	uxtb	r3, r3
  408bca:	2b00      	cmp	r3, #0
  408bcc:	d005      	beq.n	408bda <isotp_send_first_frame+0x6a>
		shims->log("Unable to set PCI in first frame CAN data");
  408bce:	687b      	ldr	r3, [r7, #4]
  408bd0:	681b      	ldr	r3, [r3, #0]
  408bd2:	4826      	ldr	r0, [pc, #152]	; (408c6c <isotp_send_first_frame+0xfc>)
  408bd4:	4798      	blx	r3
		return false;
  408bd6:	2300      	movs	r3, #0
  408bd8:	e041      	b.n	408c5e <isotp_send_first_frame+0xee>
	}

	// define the total message size (note, now we have 3 nibbles instead of 1)
	if(!set_bitfield((Handle->message_ptr->size)-2,36,12,can_data,sizeof(can_data))){
  408bda:	683b      	ldr	r3, [r7, #0]
  408bdc:	685b      	ldr	r3, [r3, #4]
  408bde:	891b      	ldrh	r3, [r3, #8]
  408be0:	3b02      	subs	r3, #2
  408be2:	4618      	mov	r0, r3
  408be4:	ea4f 71e0 	mov.w	r1, r0, asr #31
  408be8:	230c      	movs	r3, #12
  408bea:	9301      	str	r3, [sp, #4]
  408bec:	f107 030c 	add.w	r3, r7, #12
  408bf0:	9300      	str	r3, [sp, #0]
  408bf2:	230c      	movs	r3, #12
  408bf4:	2224      	movs	r2, #36	; 0x24
  408bf6:	4c1e      	ldr	r4, [pc, #120]	; (408c70 <isotp_send_first_frame+0x100>)
  408bf8:	47a0      	blx	r4
  408bfa:	4603      	mov	r3, r0
  408bfc:	f083 0301 	eor.w	r3, r3, #1
  408c00:	b2db      	uxtb	r3, r3
  408c02:	2b00      	cmp	r3, #0
  408c04:	d005      	beq.n	408c12 <isotp_send_first_frame+0xa2>
		shims->log("Unable to set payload length in CAN data");
  408c06:	687b      	ldr	r3, [r7, #4]
  408c08:	681b      	ldr	r3, [r3, #0]
  408c0a:	481a      	ldr	r0, [pc, #104]	; (408c74 <isotp_send_first_frame+0x104>)
  408c0c:	4798      	blx	r3
		return false;
  408c0e:	2300      	movs	r3, #0
  408c10:	e025      	b.n	408c5e <isotp_send_first_frame+0xee>
	}

	// copy first 6 bytes of the message
	if(Handle->message_ptr->size > 0) {
  408c12:	683b      	ldr	r3, [r7, #0]
  408c14:	685b      	ldr	r3, [r3, #4]
  408c16:	891b      	ldrh	r3, [r3, #8]
  408c18:	2b00      	cmp	r3, #0
  408c1a:	d00a      	beq.n	408c32 <isotp_send_first_frame+0xc2>
		memcpy(&can_data[MULTI_PAYLOAD_BYTE_INDEX], Handle->message_ptr->payload+2, 6);
  408c1c:	683b      	ldr	r3, [r7, #0]
  408c1e:	685b      	ldr	r3, [r3, #4]
  408c20:	68db      	ldr	r3, [r3, #12]
  408c22:	1c99      	adds	r1, r3, #2
  408c24:	f107 030c 	add.w	r3, r7, #12
  408c28:	3306      	adds	r3, #6
  408c2a:	2206      	movs	r2, #6
  408c2c:	4618      	mov	r0, r3
  408c2e:	4b12      	ldr	r3, [pc, #72]	; (408c78 <isotp_send_first_frame+0x108>)
  408c30:	4798      	blx	r3
	}
	
	// write the message to the CAN bus and note send success
	shims->send_can_message(0, can_data,
  408c32:	687b      	ldr	r3, [r7, #4]
  408c34:	685b      	ldr	r3, [r3, #4]
	shims->frame_padding ? 8 : 1 + Handle->message_ptr->size-2);
  408c36:	687a      	ldr	r2, [r7, #4]
  408c38:	7c12      	ldrb	r2, [r2, #16]
	shims->send_can_message(0, can_data,
  408c3a:	2a00      	cmp	r2, #0
  408c3c:	d001      	beq.n	408c42 <isotp_send_first_frame+0xd2>
  408c3e:	2208      	movs	r2, #8
  408c40:	e005      	b.n	408c4e <isotp_send_first_frame+0xde>
	shims->frame_padding ? 8 : 1 + Handle->message_ptr->size-2);
  408c42:	683a      	ldr	r2, [r7, #0]
  408c44:	6852      	ldr	r2, [r2, #4]
  408c46:	8912      	ldrh	r2, [r2, #8]
  408c48:	b2d2      	uxtb	r2, r2
	shims->send_can_message(0, can_data,
  408c4a:	3a01      	subs	r2, #1
  408c4c:	b2d2      	uxtb	r2, r2
  408c4e:	f107 010c 	add.w	r1, r7, #12
  408c52:	2000      	movs	r0, #0
  408c54:	4798      	blx	r3
	Handle->success = true;
  408c56:	683b      	ldr	r3, [r7, #0]
  408c58:	2201      	movs	r2, #1
  408c5a:	705a      	strb	r2, [r3, #1]
	
	
	return true;
  408c5c:	2301      	movs	r3, #1
}
  408c5e:	4618      	mov	r0, r3
  408c60:	371c      	adds	r7, #28
  408c62:	46bd      	mov	sp, r7
  408c64:	bd90      	pop	{r4, r7, pc}
  408c66:	bf00      	nop
  408c68:	00409149 	.word	0x00409149
  408c6c:	0040ad98 	.word	0x0040ad98
  408c70:	0040918d 	.word	0x0040918d
  408c74:	0040ad6c 	.word	0x0040ad6c
  408c78:	0040a635 	.word	0x0040a635

00408c7c <SendTimeout>:

void SendTimeout(void)
{
  408c7c:	b480      	push	{r7}
  408c7e:	af00      	add	r7, sp, #0
	//Oh Dear, we timed out!
	CurrentHandle.current_isotp_state = ISOTP_IDLE;
  408c80:	4b03      	ldr	r3, [pc, #12]	; (408c90 <SendTimeout+0x14>)
  408c82:	2200      	movs	r2, #0
  408c84:	751a      	strb	r2, [r3, #20]

	
}
  408c86:	bf00      	nop
  408c88:	46bd      	mov	sp, r7
  408c8a:	bc80      	pop	{r7}
  408c8c:	4770      	bx	lr
  408c8e:	bf00      	nop
  408c90:	20008988 	.word	0x20008988

00408c94 <isotp_send_multi_frame>:
}


// send multi-frame CAN message
IsoTpSendHandle isotp_send_multi_frame(IsoTpShims* shims, IsoTpMessage* message,
        IsoTpMessageSentHandler callback) {	
  408c94:	b5b0      	push	{r4, r5, r7, lr}
  408c96:	b08a      	sub	sp, #40	; 0x28
  408c98:	af00      	add	r7, sp, #0
  408c9a:	60f8      	str	r0, [r7, #12]
  408c9c:	60b9      	str	r1, [r7, #8]
  408c9e:	607a      	str	r2, [r7, #4]
  408ca0:	603b      	str	r3, [r7, #0]
	// create the send handle - note that completed = false here
    IsoTpSendHandle handle = {
  408ca2:	f107 0310 	add.w	r3, r7, #16
  408ca6:	2200      	movs	r2, #0
  408ca8:	601a      	str	r2, [r3, #0]
  408caa:	605a      	str	r2, [r3, #4]
  408cac:	609a      	str	r2, [r3, #8]
  408cae:	60da      	str	r2, [r3, #12]
  408cb0:	611a      	str	r2, [r3, #16]
  408cb2:	615a      	str	r2, [r3, #20]
  408cb4:	687b      	ldr	r3, [r7, #4]
  408cb6:	617b      	str	r3, [r7, #20]
        success: false,
        completed: false,
		message_ptr: message,
    };
	
	CurrentHandle = handle; 
  408cb8:	4b9a      	ldr	r3, [pc, #616]	; (408f24 <isotp_send_multi_frame+0x290>)
  408cba:	461d      	mov	r5, r3
  408cbc:	f107 0410 	add.w	r4, r7, #16
  408cc0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  408cc2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  408cc4:	e894 0003 	ldmia.w	r4, {r0, r1}
  408cc8:	e885 0003 	stmia.w	r5, {r0, r1}
	CurrentHandle.current_isotp_state = ISOTP_SEND;
  408ccc:	4b95      	ldr	r3, [pc, #596]	; (408f24 <isotp_send_multi_frame+0x290>)
  408cce:	2201      	movs	r2, #1
  408cd0:	751a      	strb	r2, [r3, #20]
	#ifdef ISO_TP_DEBUG_ENABLE
	shims->log("Start Multiframe Send Procedure. . .");
  408cd2:	68bb      	ldr	r3, [r7, #8]
  408cd4:	681b      	ldr	r3, [r3, #0]
  408cd6:	4894      	ldr	r0, [pc, #592]	; (408f28 <isotp_send_multi_frame+0x294>)
  408cd8:	4798      	blx	r3
	#endif
	 while(CurrentHandle.current_isotp_state != ISOTP_IDLE){
  408cda:	e118      	b.n	408f0e <isotp_send_multi_frame+0x27a>
		 switch(CurrentHandle.current_isotp_state){
  408cdc:	4b91      	ldr	r3, [pc, #580]	; (408f24 <isotp_send_multi_frame+0x290>)
  408cde:	7d1b      	ldrb	r3, [r3, #20]
  408ce0:	2b05      	cmp	r3, #5
  408ce2:	f200 8114 	bhi.w	408f0e <isotp_send_multi_frame+0x27a>
  408ce6:	a201      	add	r2, pc, #4	; (adr r2, 408cec <isotp_send_multi_frame+0x58>)
  408ce8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408cec:	00408f0f 	.word	0x00408f0f
  408cf0:	00408d05 	.word	0x00408d05
  408cf4:	00408f0f 	.word	0x00408f0f
  408cf8:	00408e71 	.word	0x00408e71
  408cfc:	00408d8d 	.word	0x00408d8d
  408d00:	00408d8d 	.word	0x00408d8d
			case ISOTP_IDLE: break;
			case ISOTP_SEND:{
				

				CurrentHandle.current_isotp_state = ISOTP_WAIT_FIRST_FC;
  408d04:	4b87      	ldr	r3, [pc, #540]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d06:	2204      	movs	r2, #4
  408d08:	751a      	strb	r2, [r3, #20]
				CurrentHandle.message_ptr->seq_id = 1;
  408d0a:	4b86      	ldr	r3, [pc, #536]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d0c:	685b      	ldr	r3, [r3, #4]
  408d0e:	2201      	movs	r2, #1
  408d10:	74da      	strb	r2, [r3, #19]
				if(!isotp_send_first_frame(shims, &CurrentHandle)){
  408d12:	4984      	ldr	r1, [pc, #528]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d14:	68b8      	ldr	r0, [r7, #8]
  408d16:	4b85      	ldr	r3, [pc, #532]	; (408f2c <isotp_send_multi_frame+0x298>)
  408d18:	4798      	blx	r3
  408d1a:	4603      	mov	r3, r0
  408d1c:	f083 0301 	eor.w	r3, r3, #1
  408d20:	b2db      	uxtb	r3, r3
  408d22:	2b00      	cmp	r3, #0
  408d24:	d013      	beq.n	408d4e <isotp_send_multi_frame+0xba>
					CurrentHandle.current_isotp_state = ISOTP_IDLE;
  408d26:	4b7f      	ldr	r3, [pc, #508]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d28:	2200      	movs	r2, #0
  408d2a:	751a      	strb	r2, [r3, #20]
					CurrentHandle.completed = false;
  408d2c:	4b7d      	ldr	r3, [pc, #500]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d2e:	2200      	movs	r2, #0
  408d30:	701a      	strb	r2, [r3, #0]
					CurrentHandle.success = false;
  408d32:	4b7c      	ldr	r3, [pc, #496]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d34:	2200      	movs	r2, #0
  408d36:	705a      	strb	r2, [r3, #1]
					//TODO: CALL ERROR SHIM		
					return CurrentHandle;		
  408d38:	68fb      	ldr	r3, [r7, #12]
  408d3a:	4a7a      	ldr	r2, [pc, #488]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d3c:	461c      	mov	r4, r3
  408d3e:	4615      	mov	r5, r2
  408d40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408d42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  408d44:	e895 0003 	ldmia.w	r5, {r0, r1}
  408d48:	e884 0003 	stmia.w	r4, {r0, r1}
  408d4c:	e0e5      	b.n	408f1a <isotp_send_multi_frame+0x286>
				}	
				CurrentHandle.message_ptr->payload+=6;
  408d4e:	4b75      	ldr	r3, [pc, #468]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d50:	685b      	ldr	r3, [r3, #4]
  408d52:	4a74      	ldr	r2, [pc, #464]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d54:	6852      	ldr	r2, [r2, #4]
  408d56:	68d2      	ldr	r2, [r2, #12]
  408d58:	3206      	adds	r2, #6
  408d5a:	60da      	str	r2, [r3, #12]
				CurrentHandle.message_ptr->size-=6;
  408d5c:	4b71      	ldr	r3, [pc, #452]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d5e:	685b      	ldr	r3, [r3, #4]
  408d60:	4a70      	ldr	r2, [pc, #448]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d62:	6852      	ldr	r2, [r2, #4]
  408d64:	8912      	ldrh	r2, [r2, #8]
  408d66:	3a06      	subs	r2, #6
  408d68:	b292      	uxth	r2, r2
  408d6a:	811a      	strh	r2, [r3, #8]
				#ifdef ISO_TP_DEBUG_ENABLE
				shims->log("Sent First Frame");
  408d6c:	68bb      	ldr	r3, [r7, #8]
  408d6e:	681b      	ldr	r3, [r3, #0]
  408d70:	486f      	ldr	r0, [pc, #444]	; (408f30 <isotp_send_multi_frame+0x29c>)
  408d72:	4798      	blx	r3
				#endif
				
				#ifdef ISO_TP_DEBUG_ENABLE
				shims->log("Waiting for FC. Starting timeout timer!");
  408d74:	68bb      	ldr	r3, [r7, #8]
  408d76:	681b      	ldr	r3, [r3, #0]
  408d78:	486e      	ldr	r0, [pc, #440]	; (408f34 <isotp_send_multi_frame+0x2a0>)
  408d7a:	4798      	blx	r3
				#endif
				shims->set_timer(500,false, SendTimeout);
  408d7c:	68bb      	ldr	r3, [r7, #8]
  408d7e:	689b      	ldr	r3, [r3, #8]
  408d80:	4a6d      	ldr	r2, [pc, #436]	; (408f38 <isotp_send_multi_frame+0x2a4>)
  408d82:	2100      	movs	r1, #0
  408d84:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  408d88:	4798      	blx	r3
			}
			break;
  408d8a:	e0c0      	b.n	408f0e <isotp_send_multi_frame+0x27a>
			
			case ISOTP_WAIT_FC:
			case ISOTP_WAIT_FIRST_FC: 
				#ifdef ISO_TP_DEBUG_ENABLE
				shims->log("Waiting - Timeout timer running...");
  408d8c:	68bb      	ldr	r3, [r7, #8]
  408d8e:	681b      	ldr	r3, [r3, #0]
  408d90:	486a      	ldr	r0, [pc, #424]	; (408f3c <isotp_send_multi_frame+0x2a8>)
  408d92:	4798      	blx	r3
				#endif
			break;
  408d94:	e0bb      	b.n	408f0e <isotp_send_multi_frame+0x27a>
		
			case ISOTP_SEND_CF:{
				while(CurrentHandle.message_ptr->size > 7 & !CurrentHandle.message_ptr->block_sent){
					
					if(!isotp_send_consecutive_frame(shims, &CurrentHandle)){
  408d96:	4963      	ldr	r1, [pc, #396]	; (408f24 <isotp_send_multi_frame+0x290>)
  408d98:	68b8      	ldr	r0, [r7, #8]
  408d9a:	4b69      	ldr	r3, [pc, #420]	; (408f40 <isotp_send_multi_frame+0x2ac>)
  408d9c:	4798      	blx	r3
  408d9e:	4603      	mov	r3, r0
  408da0:	f083 0301 	eor.w	r3, r3, #1
  408da4:	b2db      	uxtb	r3, r3
  408da6:	2b00      	cmp	r3, #0
  408da8:	d013      	beq.n	408dd2 <isotp_send_multi_frame+0x13e>
						CurrentHandle.current_isotp_state = ISOTP_IDLE;
  408daa:	4b5e      	ldr	r3, [pc, #376]	; (408f24 <isotp_send_multi_frame+0x290>)
  408dac:	2200      	movs	r2, #0
  408dae:	751a      	strb	r2, [r3, #20]
						CurrentHandle.completed = false;
  408db0:	4b5c      	ldr	r3, [pc, #368]	; (408f24 <isotp_send_multi_frame+0x290>)
  408db2:	2200      	movs	r2, #0
  408db4:	701a      	strb	r2, [r3, #0]
						CurrentHandle.success = false;
  408db6:	4b5b      	ldr	r3, [pc, #364]	; (408f24 <isotp_send_multi_frame+0x290>)
  408db8:	2200      	movs	r2, #0
  408dba:	705a      	strb	r2, [r3, #1]
						//TODO: CALL ERROR SHIM
						return CurrentHandle;
  408dbc:	68fb      	ldr	r3, [r7, #12]
  408dbe:	4a59      	ldr	r2, [pc, #356]	; (408f24 <isotp_send_multi_frame+0x290>)
  408dc0:	461c      	mov	r4, r3
  408dc2:	4615      	mov	r5, r2
  408dc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408dc6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  408dc8:	e895 0003 	ldmia.w	r5, {r0, r1}
  408dcc:	e884 0003 	stmia.w	r4, {r0, r1}
  408dd0:	e0a3      	b.n	408f1a <isotp_send_multi_frame+0x286>
					}
					#ifdef ISO_TP_DEBUG_ENABLE
					shims->log("Sent consecutive frame with seq id: ");
  408dd2:	68bb      	ldr	r3, [r7, #8]
  408dd4:	681b      	ldr	r3, [r3, #0]
  408dd6:	485b      	ldr	r0, [pc, #364]	; (408f44 <isotp_send_multi_frame+0x2b0>)
  408dd8:	4798      	blx	r3
					shims->log(CurrentHandle.message_ptr->seq_id);
  408dda:	68bb      	ldr	r3, [r7, #8]
  408ddc:	681b      	ldr	r3, [r3, #0]
  408dde:	4a51      	ldr	r2, [pc, #324]	; (408f24 <isotp_send_multi_frame+0x290>)
  408de0:	6852      	ldr	r2, [r2, #4]
  408de2:	7cd2      	ldrb	r2, [r2, #19]
  408de4:	4610      	mov	r0, r2
  408de6:	4798      	blx	r3
					#endif
					
					if(CurrentHandle.message_ptr->blocksize > 0 ){
  408de8:	4b4e      	ldr	r3, [pc, #312]	; (408f24 <isotp_send_multi_frame+0x290>)
  408dea:	685b      	ldr	r3, [r3, #4]
  408dec:	7c5b      	ldrb	r3, [r3, #17]
  408dee:	2b00      	cmp	r3, #0
  408df0:	d018      	beq.n	408e24 <isotp_send_multi_frame+0x190>
						if(!(CurrentHandle.message_ptr->seq_id % CurrentHandle.message_ptr->blocksize))
  408df2:	4b4c      	ldr	r3, [pc, #304]	; (408f24 <isotp_send_multi_frame+0x290>)
  408df4:	685b      	ldr	r3, [r3, #4]
  408df6:	7cdb      	ldrb	r3, [r3, #19]
  408df8:	4a4a      	ldr	r2, [pc, #296]	; (408f24 <isotp_send_multi_frame+0x290>)
  408dfa:	6852      	ldr	r2, [r2, #4]
  408dfc:	7c52      	ldrb	r2, [r2, #17]
  408dfe:	fbb3 f1f2 	udiv	r1, r3, r2
  408e02:	fb02 f201 	mul.w	r2, r2, r1
  408e06:	1a9b      	subs	r3, r3, r2
  408e08:	b2db      	uxtb	r3, r3
  408e0a:	2b00      	cmp	r3, #0
  408e0c:	d10a      	bne.n	408e24 <isotp_send_multi_frame+0x190>
						{
							CurrentHandle.message_ptr->blocksize = true;
  408e0e:	4b45      	ldr	r3, [pc, #276]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e10:	685b      	ldr	r3, [r3, #4]
  408e12:	2201      	movs	r2, #1
  408e14:	745a      	strb	r2, [r3, #17]
							CurrentHandle.current_isotp_state = ISOTP_WAIT_FC;
  408e16:	4b43      	ldr	r3, [pc, #268]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e18:	2205      	movs	r2, #5
  408e1a:	751a      	strb	r2, [r3, #20]
							#ifdef ISO_TP_DEBUG_ENABLE
							shims->log("Sent full block to remote, waiting for next flow control frame");
  408e1c:	68bb      	ldr	r3, [r7, #8]
  408e1e:	681b      	ldr	r3, [r3, #0]
  408e20:	4849      	ldr	r0, [pc, #292]	; (408f48 <isotp_send_multi_frame+0x2b4>)
  408e22:	4798      	blx	r3
							#endif
						}
					}
					CurrentHandle.message_ptr->seq_id++;
  408e24:	4b3f      	ldr	r3, [pc, #252]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e26:	685b      	ldr	r3, [r3, #4]
  408e28:	7cda      	ldrb	r2, [r3, #19]
  408e2a:	3201      	adds	r2, #1
  408e2c:	b2d2      	uxtb	r2, r2
  408e2e:	74da      	strb	r2, [r3, #19]
					CurrentHandle.message_ptr->seq_id%= 16;
  408e30:	4b3c      	ldr	r3, [pc, #240]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e32:	685b      	ldr	r3, [r3, #4]
  408e34:	4a3b      	ldr	r2, [pc, #236]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e36:	6852      	ldr	r2, [r2, #4]
  408e38:	7cd2      	ldrb	r2, [r2, #19]
  408e3a:	f002 020f 	and.w	r2, r2, #15
  408e3e:	b2d2      	uxtb	r2, r2
  408e40:	74da      	strb	r2, [r3, #19]
					CurrentHandle.message_ptr->payload+=7;
  408e42:	4b38      	ldr	r3, [pc, #224]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e44:	685b      	ldr	r3, [r3, #4]
  408e46:	4a37      	ldr	r2, [pc, #220]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e48:	6852      	ldr	r2, [r2, #4]
  408e4a:	68d2      	ldr	r2, [r2, #12]
  408e4c:	3207      	adds	r2, #7
  408e4e:	60da      	str	r2, [r3, #12]
					CurrentHandle.message_ptr->size-=7;
  408e50:	4b34      	ldr	r3, [pc, #208]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e52:	685b      	ldr	r3, [r3, #4]
  408e54:	4a33      	ldr	r2, [pc, #204]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e56:	6852      	ldr	r2, [r2, #4]
  408e58:	8912      	ldrh	r2, [r2, #8]
  408e5a:	3a07      	subs	r2, #7
  408e5c:	b292      	uxth	r2, r2
  408e5e:	811a      	strh	r2, [r3, #8]
					shims->DelayMillis(CurrentHandle.message_ptr->min_sep_time);
  408e60:	68bb      	ldr	r3, [r7, #8]
  408e62:	68db      	ldr	r3, [r3, #12]
  408e64:	4a2f      	ldr	r2, [pc, #188]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e66:	6852      	ldr	r2, [r2, #4]
  408e68:	7c92      	ldrb	r2, [r2, #18]
  408e6a:	b292      	uxth	r2, r2
  408e6c:	4610      	mov	r0, r2
  408e6e:	4798      	blx	r3
				while(CurrentHandle.message_ptr->size > 7 & !CurrentHandle.message_ptr->block_sent){
  408e70:	4b2c      	ldr	r3, [pc, #176]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e72:	685b      	ldr	r3, [r3, #4]
  408e74:	891b      	ldrh	r3, [r3, #8]
  408e76:	2b07      	cmp	r3, #7
  408e78:	bf8c      	ite	hi
  408e7a:	2301      	movhi	r3, #1
  408e7c:	2300      	movls	r3, #0
  408e7e:	b2db      	uxtb	r3, r3
  408e80:	461a      	mov	r2, r3
  408e82:	4b28      	ldr	r3, [pc, #160]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e84:	685b      	ldr	r3, [r3, #4]
  408e86:	7d9b      	ldrb	r3, [r3, #22]
  408e88:	f083 0301 	eor.w	r3, r3, #1
  408e8c:	b2db      	uxtb	r3, r3
  408e8e:	4013      	ands	r3, r2
  408e90:	2b00      	cmp	r3, #0
  408e92:	d180      	bne.n	408d96 <isotp_send_multi_frame+0x102>
				}
				if(!CurrentHandle.message_ptr->block_sent)
  408e94:	4b23      	ldr	r3, [pc, #140]	; (408f24 <isotp_send_multi_frame+0x290>)
  408e96:	685b      	ldr	r3, [r3, #4]
  408e98:	7d9b      	ldrb	r3, [r3, #22]
  408e9a:	f083 0301 	eor.w	r3, r3, #1
  408e9e:	b2db      	uxtb	r3, r3
  408ea0:	2b00      	cmp	r3, #0
  408ea2:	d033      	beq.n	408f0c <isotp_send_multi_frame+0x278>
				{
					shims->DelayMillis(CurrentHandle.message_ptr->min_sep_time);
  408ea4:	68bb      	ldr	r3, [r7, #8]
  408ea6:	68db      	ldr	r3, [r3, #12]
  408ea8:	4a1e      	ldr	r2, [pc, #120]	; (408f24 <isotp_send_multi_frame+0x290>)
  408eaa:	6852      	ldr	r2, [r2, #4]
  408eac:	7c92      	ldrb	r2, [r2, #18]
  408eae:	b292      	uxth	r2, r2
  408eb0:	4610      	mov	r0, r2
  408eb2:	4798      	blx	r3
					#ifdef ISO_TP_DEBUG_ENABLE
						shims->log("Sending last frame with seq id: ");
  408eb4:	68bb      	ldr	r3, [r7, #8]
  408eb6:	681b      	ldr	r3, [r3, #0]
  408eb8:	4824      	ldr	r0, [pc, #144]	; (408f4c <isotp_send_multi_frame+0x2b8>)
  408eba:	4798      	blx	r3
						shims->log(CurrentHandle.message_ptr->seq_id);
  408ebc:	68bb      	ldr	r3, [r7, #8]
  408ebe:	681b      	ldr	r3, [r3, #0]
  408ec0:	4a18      	ldr	r2, [pc, #96]	; (408f24 <isotp_send_multi_frame+0x290>)
  408ec2:	6852      	ldr	r2, [r2, #4]
  408ec4:	7cd2      	ldrb	r2, [r2, #19]
  408ec6:	4610      	mov	r0, r2
  408ec8:	4798      	blx	r3
					#endif
					
					if(!isotp_send_consecutive_frame(shims, &CurrentHandle)){
  408eca:	4916      	ldr	r1, [pc, #88]	; (408f24 <isotp_send_multi_frame+0x290>)
  408ecc:	68b8      	ldr	r0, [r7, #8]
  408ece:	4b1c      	ldr	r3, [pc, #112]	; (408f40 <isotp_send_multi_frame+0x2ac>)
  408ed0:	4798      	blx	r3
  408ed2:	4603      	mov	r3, r0
  408ed4:	f083 0301 	eor.w	r3, r3, #1
  408ed8:	b2db      	uxtb	r3, r3
  408eda:	2b00      	cmp	r3, #0
  408edc:	d013      	beq.n	408f06 <isotp_send_multi_frame+0x272>
						CurrentHandle.current_isotp_state = ISOTP_IDLE;
  408ede:	4b11      	ldr	r3, [pc, #68]	; (408f24 <isotp_send_multi_frame+0x290>)
  408ee0:	2200      	movs	r2, #0
  408ee2:	751a      	strb	r2, [r3, #20]
						CurrentHandle.completed = false;
  408ee4:	4b0f      	ldr	r3, [pc, #60]	; (408f24 <isotp_send_multi_frame+0x290>)
  408ee6:	2200      	movs	r2, #0
  408ee8:	701a      	strb	r2, [r3, #0]
						CurrentHandle.success = false;
  408eea:	4b0e      	ldr	r3, [pc, #56]	; (408f24 <isotp_send_multi_frame+0x290>)
  408eec:	2200      	movs	r2, #0
  408eee:	705a      	strb	r2, [r3, #1]
						//TODO: CALL ERROR SHIM
						return CurrentHandle;
  408ef0:	68fb      	ldr	r3, [r7, #12]
  408ef2:	4a0c      	ldr	r2, [pc, #48]	; (408f24 <isotp_send_multi_frame+0x290>)
  408ef4:	461c      	mov	r4, r3
  408ef6:	4615      	mov	r5, r2
  408ef8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408efa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  408efc:	e895 0003 	ldmia.w	r5, {r0, r1}
  408f00:	e884 0003 	stmia.w	r4, {r0, r1}
  408f04:	e009      	b.n	408f1a <isotp_send_multi_frame+0x286>
					}
					CurrentHandle.current_isotp_state = ISOTP_IDLE;						
  408f06:	4b07      	ldr	r3, [pc, #28]	; (408f24 <isotp_send_multi_frame+0x290>)
  408f08:	2200      	movs	r2, #0
  408f0a:	751a      	strb	r2, [r3, #20]
				}	
			}
			break;
  408f0c:	bf00      	nop
	 while(CurrentHandle.current_isotp_state != ISOTP_IDLE){
  408f0e:	4b05      	ldr	r3, [pc, #20]	; (408f24 <isotp_send_multi_frame+0x290>)
  408f10:	7d1b      	ldrb	r3, [r3, #20]
  408f12:	2b00      	cmp	r3, #0
  408f14:	f47f aee2 	bne.w	408cdc <isotp_send_multi_frame+0x48>
			
		 }
	 }

}
  408f18:	bf00      	nop
  408f1a:	68f8      	ldr	r0, [r7, #12]
  408f1c:	3728      	adds	r7, #40	; 0x28
  408f1e:	46bd      	mov	sp, r7
  408f20:	bdb0      	pop	{r4, r5, r7, pc}
  408f22:	bf00      	nop
  408f24:	20008988 	.word	0x20008988
  408f28:	0040adc4 	.word	0x0040adc4
  408f2c:	00408b71 	.word	0x00408b71
  408f30:	0040adec 	.word	0x0040adec
  408f34:	0040ae00 	.word	0x0040ae00
  408f38:	00408c7d 	.word	0x00408c7d
  408f3c:	0040ae28 	.word	0x0040ae28
  408f40:	00409011 	.word	0x00409011
  408f44:	0040ae4c 	.word	0x0040ae4c
  408f48:	0040ae74 	.word	0x0040ae74
  408f4c:	0040aeb4 	.word	0x0040aeb4

00408f50 <isotp_send>:

// create the IsoTpMessage and call the appropriate CAN write function
IsoTpSendHandle isotp_send(IsoTpShims* shims, const uint16_t arbitration_id,
        const uint8_t payload[], uint16_t size,
        IsoTpMessageSentHandler callback) {
  408f50:	b590      	push	{r4, r7, lr}
  408f52:	b08b      	sub	sp, #44	; 0x2c
  408f54:	af00      	add	r7, sp, #0
  408f56:	60f8      	str	r0, [r7, #12]
  408f58:	60b9      	str	r1, [r7, #8]
  408f5a:	603b      	str	r3, [r7, #0]
  408f5c:	4613      	mov	r3, r2
  408f5e:	80fb      	strh	r3, [r7, #6]
    IsoTpMessage message = {
  408f60:	f107 0310 	add.w	r3, r7, #16
  408f64:	2200      	movs	r2, #0
  408f66:	601a      	str	r2, [r3, #0]
  408f68:	605a      	str	r2, [r3, #4]
  408f6a:	609a      	str	r2, [r3, #8]
  408f6c:	60da      	str	r2, [r3, #12]
  408f6e:	611a      	str	r2, [r3, #16]
  408f70:	615a      	str	r2, [r3, #20]
  408f72:	88fb      	ldrh	r3, [r7, #6]
  408f74:	613b      	str	r3, [r7, #16]
  408f76:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
  408f78:	833b      	strh	r3, [r7, #24]
  408f7a:	683b      	ldr	r3, [r7, #0]
  408f7c:	61fb      	str	r3, [r7, #28]
        size: size,
		payload: payload
    };

	// if we can fit entire payload onto one message, send single frame
    if(size < 8) {
  408f7e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
  408f80:	2b07      	cmp	r3, #7
  408f82:	d807      	bhi.n	408f94 <isotp_send+0x44>
		return isotp_send_single_frame(shims, &message, callback);
  408f84:	68f8      	ldr	r0, [r7, #12]
  408f86:	f107 0210 	add.w	r2, r7, #16
  408f8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  408f8c:	68b9      	ldr	r1, [r7, #8]
  408f8e:	4c07      	ldr	r4, [pc, #28]	; (408fac <isotp_send+0x5c>)
  408f90:	47a0      	blx	r4
  408f92:	e006      	b.n	408fa2 <isotp_send+0x52>
		}
	// otherwise we need to send first frame of multi-frame sequencey
	else {
		return isotp_send_multi_frame(shims, &message, callback);}
  408f94:	68f8      	ldr	r0, [r7, #12]
  408f96:	f107 0210 	add.w	r2, r7, #16
  408f9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  408f9c:	68b9      	ldr	r1, [r7, #8]
  408f9e:	4c04      	ldr	r4, [pc, #16]	; (408fb0 <isotp_send+0x60>)
  408fa0:	47a0      	blx	r4
}
  408fa2:	68f8      	ldr	r0, [r7, #12]
  408fa4:	372c      	adds	r7, #44	; 0x2c
  408fa6:	46bd      	mov	sp, r7
  408fa8:	bd90      	pop	{r4, r7, pc}
  408faa:	bf00      	nop
  408fac:	00408a15 	.word	0x00408a15
  408fb0:	00408c95 	.word	0x00408c95

00408fb4 <isotp_send_ext>:

// create the IsoTpMessage and call the appropriate CAN write function
IsoTpSendHandle isotp_send_ext(IsoTpShims* shims, const uint16_t arbitration_id,
const uint8_t payload[], uint16_t size,
IsoTpMessageSentHandler callback, uint8_t extended_address) {
  408fb4:	b590      	push	{r4, r7, lr}
  408fb6:	b08b      	sub	sp, #44	; 0x2c
  408fb8:	af00      	add	r7, sp, #0
  408fba:	60f8      	str	r0, [r7, #12]
  408fbc:	60b9      	str	r1, [r7, #8]
  408fbe:	603b      	str	r3, [r7, #0]
  408fc0:	4613      	mov	r3, r2
  408fc2:	80fb      	strh	r3, [r7, #6]
	IsoTpMessage message = {
  408fc4:	f107 0310 	add.w	r3, r7, #16
  408fc8:	2200      	movs	r2, #0
  408fca:	601a      	str	r2, [r3, #0]
  408fcc:	605a      	str	r2, [r3, #4]
  408fce:	609a      	str	r2, [r3, #8]
  408fd0:	60da      	str	r2, [r3, #12]
  408fd2:	611a      	str	r2, [r3, #16]
  408fd4:	615a      	str	r2, [r3, #20]
  408fd6:	88fb      	ldrh	r3, [r7, #6]
  408fd8:	613b      	str	r3, [r7, #16]
  408fda:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
  408fdc:	833b      	strh	r3, [r7, #24]
  408fde:	683b      	ldr	r3, [r7, #0]
  408fe0:	61fb      	str	r3, [r7, #28]
  408fe2:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
  408fe6:	f887 3020 	strb.w	r3, [r7, #32]
	};

	
	
	// if we can fit entire payload onto one message, send single frame
	if(size < 8) {
  408fea:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
  408fec:	2b07      	cmp	r3, #7
  408fee:	d807      	bhi.n	409000 <isotp_send_ext+0x4c>
		return isotp_send_single_frame_ext(shims, &message, callback);
  408ff0:	68f8      	ldr	r0, [r7, #12]
  408ff2:	f107 0210 	add.w	r2, r7, #16
  408ff6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  408ff8:	68b9      	ldr	r1, [r7, #8]
  408ffa:	4c04      	ldr	r4, [pc, #16]	; (40900c <isotp_send_ext+0x58>)
  408ffc:	47a0      	blx	r4
  408ffe:	e000      	b.n	409002 <isotp_send_ext+0x4e>
	}
	// unspported w/ extended addr for now
	else {
	return;}
  409000:	bf00      	nop
}
  409002:	68f8      	ldr	r0, [r7, #12]
  409004:	372c      	adds	r7, #44	; 0x2c
  409006:	46bd      	mov	sp, r7
  409008:	bd90      	pop	{r4, r7, pc}
  40900a:	bf00      	nop
  40900c:	004088b5 	.word	0x004088b5

00409010 <isotp_send_consecutive_frame>:

// send second frames of multi-frame CAN message
bool isotp_send_consecutive_frame(IsoTpShims* shims, IsoTpSendHandle *Handle) {
  409010:	b590      	push	{r4, r7, lr}
  409012:	b087      	sub	sp, #28
  409014:	af00      	add	r7, sp, #0
  409016:	6078      	str	r0, [r7, #4]
  409018:	6039      	str	r1, [r7, #0]
	// create the CAN frame array
	uint8_t can_data[CAN_MESSAGE_BYTE_COUNT + 4] = {0};
  40901a:	f107 030c 	add.w	r3, r7, #12
  40901e:	2200      	movs	r2, #0
  409020:	601a      	str	r2, [r3, #0]
  409022:	605a      	str	r2, [r3, #4]
  409024:	609a      	str	r2, [r3, #8]
	
	can_data[0] = (Handle->message_ptr->arbitration_id >> 24) & 0xFF;
  409026:	683b      	ldr	r3, [r7, #0]
  409028:	685b      	ldr	r3, [r3, #4]
  40902a:	681b      	ldr	r3, [r3, #0]
  40902c:	0e1b      	lsrs	r3, r3, #24
  40902e:	b2db      	uxtb	r3, r3
  409030:	733b      	strb	r3, [r7, #12]
	can_data[1] = (Handle->message_ptr->arbitration_id >> 16) & 0xFF;
  409032:	683b      	ldr	r3, [r7, #0]
  409034:	685b      	ldr	r3, [r3, #4]
  409036:	681b      	ldr	r3, [r3, #0]
  409038:	0c1b      	lsrs	r3, r3, #16
  40903a:	b2db      	uxtb	r3, r3
  40903c:	737b      	strb	r3, [r7, #13]
	can_data[2] = (Handle->message_ptr->arbitration_id >> 8) & 0xFF;
  40903e:	683b      	ldr	r3, [r7, #0]
  409040:	685b      	ldr	r3, [r3, #4]
  409042:	681b      	ldr	r3, [r3, #0]
  409044:	0a1b      	lsrs	r3, r3, #8
  409046:	b2db      	uxtb	r3, r3
  409048:	73bb      	strb	r3, [r7, #14]
	can_data[3] = Handle->message_ptr->arbitration_id & 0xFF;
  40904a:	683b      	ldr	r3, [r7, #0]
  40904c:	685b      	ldr	r3, [r3, #4]
  40904e:	681b      	ldr	r3, [r3, #0]
  409050:	b2db      	uxtb	r3, r3
  409052:	73fb      	strb	r3, [r7, #15]
	
	// set nibble 0 = 2 to define message as second frame of multi-frame sequence
    if(!set_nibble(PCI_NIBBLE_INDEX, PCI_CONSECUTIVE_FRAME, can_data, sizeof(can_data))) {
  409054:	f107 020c 	add.w	r2, r7, #12
  409058:	230c      	movs	r3, #12
  40905a:	2102      	movs	r1, #2
  40905c:	2008      	movs	r0, #8
  40905e:	4c25      	ldr	r4, [pc, #148]	; (4090f4 <isotp_send_consecutive_frame+0xe4>)
  409060:	47a0      	blx	r4
  409062:	4603      	mov	r3, r0
  409064:	f083 0301 	eor.w	r3, r3, #1
  409068:	b2db      	uxtb	r3, r3
  40906a:	2b00      	cmp	r3, #0
  40906c:	d005      	beq.n	40907a <isotp_send_consecutive_frame+0x6a>
        shims->log("Unable to set PCI in second frame CAN data");
  40906e:	687b      	ldr	r3, [r7, #4]
  409070:	681b      	ldr	r3, [r3, #0]
  409072:	4821      	ldr	r0, [pc, #132]	; (4090f8 <isotp_send_consecutive_frame+0xe8>)
  409074:	4798      	blx	r3
        return false;
  409076:	2300      	movs	r3, #0
  409078:	e037      	b.n	4090ea <isotp_send_consecutive_frame+0xda>
    }

	// set nibble 1 to be second frame number of the sequence (i.e. second frame 1 out 3)
    if(!set_nibble(PAYLOAD_LENGTH_NIBBLE_INDEX, Handle->message_ptr->seq_id, can_data,sizeof(can_data))) {
  40907a:	683b      	ldr	r3, [r7, #0]
  40907c:	685b      	ldr	r3, [r3, #4]
  40907e:	7cd9      	ldrb	r1, [r3, #19]
  409080:	f107 020c 	add.w	r2, r7, #12
  409084:	230c      	movs	r3, #12
  409086:	2009      	movs	r0, #9
  409088:	4c1a      	ldr	r4, [pc, #104]	; (4090f4 <isotp_send_consecutive_frame+0xe4>)
  40908a:	47a0      	blx	r4
  40908c:	4603      	mov	r3, r0
  40908e:	f083 0301 	eor.w	r3, r3, #1
  409092:	b2db      	uxtb	r3, r3
  409094:	2b00      	cmp	r3, #0
  409096:	d005      	beq.n	4090a4 <isotp_send_consecutive_frame+0x94>
        shims->log("Unable to set second frame number in CAN data");
  409098:	687b      	ldr	r3, [r7, #4]
  40909a:	681b      	ldr	r3, [r3, #0]
  40909c:	4817      	ldr	r0, [pc, #92]	; (4090fc <isotp_send_consecutive_frame+0xec>)
  40909e:	4798      	blx	r3
        return false;
  4090a0:	2300      	movs	r3, #0
  4090a2:	e022      	b.n	4090ea <isotp_send_consecutive_frame+0xda>
	//else {
		//memcpy(&can_data[1], &payload[index], size - (uint8_t)index);}
	
	// send message and return true	
	
	if(Handle->message_ptr->size > 0) {
  4090a4:	683b      	ldr	r3, [r7, #0]
  4090a6:	685b      	ldr	r3, [r3, #4]
  4090a8:	891b      	ldrh	r3, [r3, #8]
  4090aa:	2b00      	cmp	r3, #0
  4090ac:	d00a      	beq.n	4090c4 <isotp_send_consecutive_frame+0xb4>
		memcpy(&can_data[PAYLOAD_BYTE_INDEX], Handle->message_ptr->payload+2, 7);
  4090ae:	683b      	ldr	r3, [r7, #0]
  4090b0:	685b      	ldr	r3, [r3, #4]
  4090b2:	68db      	ldr	r3, [r3, #12]
  4090b4:	1c99      	adds	r1, r3, #2
  4090b6:	f107 030c 	add.w	r3, r7, #12
  4090ba:	3305      	adds	r3, #5
  4090bc:	2207      	movs	r2, #7
  4090be:	4618      	mov	r0, r3
  4090c0:	4b0f      	ldr	r3, [pc, #60]	; (409100 <isotp_send_consecutive_frame+0xf0>)
  4090c2:	4798      	blx	r3
	}
	
	// write the message to the CAN bus and note send success
	shims->send_can_message(0, can_data,
  4090c4:	687b      	ldr	r3, [r7, #4]
  4090c6:	685b      	ldr	r3, [r3, #4]
	shims->frame_padding ? 8 : 1 + Handle->message_ptr->size-2);
  4090c8:	687a      	ldr	r2, [r7, #4]
  4090ca:	7c12      	ldrb	r2, [r2, #16]
	shims->send_can_message(0, can_data,
  4090cc:	2a00      	cmp	r2, #0
  4090ce:	d001      	beq.n	4090d4 <isotp_send_consecutive_frame+0xc4>
  4090d0:	2208      	movs	r2, #8
  4090d2:	e005      	b.n	4090e0 <isotp_send_consecutive_frame+0xd0>
	shims->frame_padding ? 8 : 1 + Handle->message_ptr->size-2);
  4090d4:	683a      	ldr	r2, [r7, #0]
  4090d6:	6852      	ldr	r2, [r2, #4]
  4090d8:	8912      	ldrh	r2, [r2, #8]
  4090da:	b2d2      	uxtb	r2, r2
	shims->send_can_message(0, can_data,
  4090dc:	3a01      	subs	r2, #1
  4090de:	b2d2      	uxtb	r2, r2
  4090e0:	f107 010c 	add.w	r1, r7, #12
  4090e4:	2000      	movs	r0, #0
  4090e6:	4798      	blx	r3
	return true;
  4090e8:	2301      	movs	r3, #1

}
  4090ea:	4618      	mov	r0, r3
  4090ec:	371c      	adds	r7, #28
  4090ee:	46bd      	mov	sp, r7
  4090f0:	bd90      	pop	{r4, r7, pc}
  4090f2:	bf00      	nop
  4090f4:	00409149 	.word	0x00409149
  4090f8:	0040aed8 	.word	0x0040aed8
  4090fc:	0040af04 	.word	0x0040af04
  409100:	0040a635 	.word	0x0040a635

00409104 <bitmask>:
#include <limits.h>
#include <string.h>
#include <stddef.h>
#include <sys/param.h>

uint64_t bitmask(const uint8_t bit_count) {
  409104:	b4f0      	push	{r4, r5, r6, r7}
  409106:	b082      	sub	sp, #8
  409108:	af00      	add	r7, sp, #0
  40910a:	4602      	mov	r2, r0
  40910c:	71fa      	strb	r2, [r7, #7]
    return (((uint64_t)0x1) << bit_count) - 1;
  40910e:	79f8      	ldrb	r0, [r7, #7]
  409110:	f04f 0101 	mov.w	r1, #1
  409114:	f04f 0200 	mov.w	r2, #0
  409118:	f1a0 0620 	sub.w	r6, r0, #32
  40911c:	f1c0 0520 	rsb	r5, r0, #32
  409120:	fa02 f400 	lsl.w	r4, r2, r0
  409124:	fa01 f606 	lsl.w	r6, r1, r6
  409128:	4334      	orrs	r4, r6
  40912a:	fa21 f505 	lsr.w	r5, r1, r5
  40912e:	432c      	orrs	r4, r5
  409130:	fa01 f300 	lsl.w	r3, r1, r0
  409134:	f113 33ff 	adds.w	r3, r3, #4294967295
  409138:	f144 34ff 	adc.w	r4, r4, #4294967295
}
  40913c:	4618      	mov	r0, r3
  40913e:	4621      	mov	r1, r4
  409140:	3708      	adds	r7, #8
  409142:	46bd      	mov	sp, r7
  409144:	bcf0      	pop	{r4, r5, r6, r7}
  409146:	4770      	bx	lr

00409148 <set_nibble>:
    }
    return combined.whole;
}

bool set_nibble(const uint16_t nibble_index, const uint8_t value,
        uint8_t* destination, const uint16_t destination_length) {
  409148:	b590      	push	{r4, r7, lr}
  40914a:	b089      	sub	sp, #36	; 0x24
  40914c:	af04      	add	r7, sp, #16
  40914e:	60ba      	str	r2, [r7, #8]
  409150:	461a      	mov	r2, r3
  409152:	4603      	mov	r3, r0
  409154:	81fb      	strh	r3, [r7, #14]
  409156:	460b      	mov	r3, r1
  409158:	737b      	strb	r3, [r7, #13]
  40915a:	4613      	mov	r3, r2
  40915c:	80fb      	strh	r3, [r7, #6]
    return copy_bits(&value, CHAR_BIT, NIBBLE_SIZE, NIBBLE_SIZE, destination,
  40915e:	89fb      	ldrh	r3, [r7, #14]
  409160:	009b      	lsls	r3, r3, #2
  409162:	b29b      	uxth	r3, r3
  409164:	f107 000d 	add.w	r0, r7, #13
  409168:	9302      	str	r3, [sp, #8]
  40916a:	88fb      	ldrh	r3, [r7, #6]
  40916c:	9301      	str	r3, [sp, #4]
  40916e:	68bb      	ldr	r3, [r7, #8]
  409170:	9300      	str	r3, [sp, #0]
  409172:	2304      	movs	r3, #4
  409174:	2204      	movs	r2, #4
  409176:	2108      	movs	r1, #8
  409178:	4c03      	ldr	r4, [pc, #12]	; (409188 <set_nibble+0x40>)
  40917a:	47a0      	blx	r4
  40917c:	4603      	mov	r3, r0
            destination_length, nibble_index * NIBBLE_SIZE);
}
  40917e:	4618      	mov	r0, r3
  409180:	3714      	adds	r7, #20
  409182:	46bd      	mov	sp, r7
  409184:	bd90      	pop	{r4, r7, pc}
  409186:	bf00      	nop
  409188:	0040920d 	.word	0x0040920d

0040918c <set_bitfield>:

bool set_bitfield(const uint64_t value, const uint16_t offset,
        const uint16_t bit_count, uint8_t destination[],
        uint16_t destination_length) {
  40918c:	b590      	push	{r4, r7, lr}
  40918e:	b08b      	sub	sp, #44	; 0x2c
  409190:	af04      	add	r7, sp, #16
  409192:	e9c7 0102 	strd	r0, r1, [r7, #8]
  409196:	4611      	mov	r1, r2
  409198:	461a      	mov	r2, r3
  40919a:	460b      	mov	r3, r1
  40919c:	80fb      	strh	r3, [r7, #6]
  40919e:	4613      	mov	r3, r2
  4091a0:	80bb      	strh	r3, [r7, #4]
    if(value > bitmask(bit_count)) {
  4091a2:	88bb      	ldrh	r3, [r7, #4]
  4091a4:	b2db      	uxtb	r3, r3
  4091a6:	4618      	mov	r0, r3
  4091a8:	4b16      	ldr	r3, [pc, #88]	; (409204 <set_bitfield+0x78>)
  4091aa:	4798      	blx	r3
  4091ac:	460a      	mov	r2, r1
  4091ae:	4601      	mov	r1, r0
  4091b0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  4091b4:	42a2      	cmp	r2, r4
  4091b6:	bf08      	it	eq
  4091b8:	4299      	cmpeq	r1, r3
  4091ba:	d201      	bcs.n	4091c0 <set_bitfield+0x34>
        return false;
  4091bc:	2300      	movs	r3, #0
  4091be:	e01d      	b.n	4091fc <set_bitfield+0x70>
    }

    ArrayOrBytes combined = {
  4091c0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  4091c4:	e9c7 3404 	strd	r3, r4, [r7, #16]
        whole: value
    };

    if(BYTE_ORDER == LITTLE_ENDIAN) {
        combined.whole = __builtin_bswap64(combined.whole);
  4091c8:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
  4091cc:	ba1a      	rev	r2, r3
  4091ce:	ba21      	rev	r1, r4
  4091d0:	460b      	mov	r3, r1
  4091d2:	4614      	mov	r4, r2
  4091d4:	e9c7 3404 	strd	r3, r4, [r7, #16]
    }

    return copy_bits(combined.bytes, sizeof(combined.bytes),
  4091d8:	88bb      	ldrh	r3, [r7, #4]
  4091da:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  4091de:	b29a      	uxth	r2, r3
  4091e0:	88b9      	ldrh	r1, [r7, #4]
  4091e2:	f107 0010 	add.w	r0, r7, #16
  4091e6:	88fb      	ldrh	r3, [r7, #6]
  4091e8:	9302      	str	r3, [sp, #8]
  4091ea:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
  4091ec:	9301      	str	r3, [sp, #4]
  4091ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4091f0:	9300      	str	r3, [sp, #0]
  4091f2:	460b      	mov	r3, r1
  4091f4:	2108      	movs	r1, #8
  4091f6:	4c04      	ldr	r4, [pc, #16]	; (409208 <set_bitfield+0x7c>)
  4091f8:	47a0      	blx	r4
  4091fa:	4603      	mov	r3, r0
            sizeof(combined.bytes) * CHAR_BIT - bit_count, bit_count,
            destination, destination_length, offset);
}
  4091fc:	4618      	mov	r0, r3
  4091fe:	371c      	adds	r7, #28
  409200:	46bd      	mov	sp, r7
  409202:	bd90      	pop	{r4, r7, pc}
  409204:	00409105 	.word	0x00409105
  409208:	0040920d 	.word	0x0040920d

0040920c <copy_bits>:
    { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00 };

bool copy_bits(const uint8_t* source_origin, const uint16_t source_length,
        const uint16_t source_offset, uint16_t bit_count,
        uint8_t* destination_origin, const uint16_t destination_length,
        const uint16_t destination_offset) {
  40920c:	b580      	push	{r7, lr}
  40920e:	b090      	sub	sp, #64	; 0x40
  409210:	af00      	add	r7, sp, #0
  409212:	60f8      	str	r0, [r7, #12]
  409214:	4608      	mov	r0, r1
  409216:	4611      	mov	r1, r2
  409218:	461a      	mov	r2, r3
  40921a:	4603      	mov	r3, r0
  40921c:	817b      	strh	r3, [r7, #10]
  40921e:	460b      	mov	r3, r1
  409220:	813b      	strh	r3, [r7, #8]
  409222:	4613      	mov	r3, r2
  409224:	80fb      	strh	r3, [r7, #6]
    if(bit_count < 1) {
  409226:	88fb      	ldrh	r3, [r7, #6]
  409228:	2b00      	cmp	r3, #0
  40922a:	d101      	bne.n	409230 <copy_bits+0x24>
        return false;
  40922c:	2300      	movs	r3, #0
  40922e:	e19e      	b.n	40956e <copy_bits+0x362>
    }

    if(source_offset + bit_count > source_length * CHAR_BIT ||
  409230:	893a      	ldrh	r2, [r7, #8]
  409232:	88fb      	ldrh	r3, [r7, #6]
  409234:	441a      	add	r2, r3
  409236:	897b      	ldrh	r3, [r7, #10]
  409238:	00db      	lsls	r3, r3, #3
  40923a:	429a      	cmp	r2, r3
  40923c:	dc08      	bgt.n	409250 <copy_bits+0x44>
            destination_offset + bit_count > destination_length * CHAR_BIT ) {
  40923e:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
  409242:	88fb      	ldrh	r3, [r7, #6]
  409244:	441a      	add	r2, r3
  409246:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
  40924a:	00db      	lsls	r3, r3, #3
    if(source_offset + bit_count > source_length * CHAR_BIT ||
  40924c:	429a      	cmp	r2, r3
  40924e:	dd01      	ble.n	409254 <copy_bits+0x48>
        return false;
  409250:	2300      	movs	r3, #0
  409252:	e18c      	b.n	40956e <copy_bits+0x362>
    }

    const uint8_t* source = source_origin + (source_offset / CHAR_BIT);
  409254:	893b      	ldrh	r3, [r7, #8]
  409256:	08db      	lsrs	r3, r3, #3
  409258:	b29b      	uxth	r3, r3
  40925a:	461a      	mov	r2, r3
  40925c:	68fb      	ldr	r3, [r7, #12]
  40925e:	4413      	add	r3, r2
  409260:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint8_t* destination = destination_origin + (destination_offset / CHAR_BIT);
  409262:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
  409266:	08db      	lsrs	r3, r3, #3
  409268:	b29b      	uxth	r3, r3
  40926a:	461a      	mov	r2, r3
  40926c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  40926e:	4413      	add	r3, r2
  409270:	63bb      	str	r3, [r7, #56]	; 0x38
    int source_offset_modulo = source_offset % CHAR_BIT;
  409272:	893b      	ldrh	r3, [r7, #8]
  409274:	f003 0307 	and.w	r3, r3, #7
  409278:	623b      	str	r3, [r7, #32]
    int destination_offset_modulo = destination_offset % CHAR_BIT;
  40927a:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
  40927e:	f003 0307 	and.w	r3, r3, #7
  409282:	61fb      	str	r3, [r7, #28]

    if(source_offset_modulo == destination_offset_modulo) {
  409284:	6a3a      	ldr	r2, [r7, #32]
  409286:	69fb      	ldr	r3, [r7, #28]
  409288:	429a      	cmp	r2, r3
  40928a:	f040 8083 	bne.w	409394 <copy_bits+0x188>
        if(source_offset_modulo > 0) {
  40928e:	6a3b      	ldr	r3, [r7, #32]
  409290:	2b00      	cmp	r3, #0
  409292:	dd49      	ble.n	409328 <copy_bits+0x11c>
            uint8_t c = reverse_mask_xor[destination_offset_modulo] & *source++;
  409294:	4a84      	ldr	r2, [pc, #528]	; (4094a8 <copy_bits+0x29c>)
  409296:	69fb      	ldr	r3, [r7, #28]
  409298:	4413      	add	r3, r2
  40929a:	781a      	ldrb	r2, [r3, #0]
  40929c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40929e:	1c59      	adds	r1, r3, #1
  4092a0:	63f9      	str	r1, [r7, #60]	; 0x3c
  4092a2:	781b      	ldrb	r3, [r3, #0]
  4092a4:	4013      	ands	r3, r2
  4092a6:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            PREPARE_FIRST_COPY();
  4092aa:	88fa      	ldrh	r2, [r7, #6]
  4092ac:	69fb      	ldr	r3, [r7, #28]
  4092ae:	f1c3 0308 	rsb	r3, r3, #8
  4092b2:	429a      	cmp	r2, r3
  4092b4:	db11      	blt.n	4092da <copy_bits+0xce>
  4092b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4092b8:	781a      	ldrb	r2, [r3, #0]
  4092ba:	497c      	ldr	r1, [pc, #496]	; (4094ac <copy_bits+0x2a0>)
  4092bc:	69fb      	ldr	r3, [r7, #28]
  4092be:	440b      	add	r3, r1
  4092c0:	781b      	ldrb	r3, [r3, #0]
  4092c2:	4013      	ands	r3, r2
  4092c4:	b2da      	uxtb	r2, r3
  4092c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4092c8:	701a      	strb	r2, [r3, #0]
  4092ca:	69fb      	ldr	r3, [r7, #28]
  4092cc:	b29a      	uxth	r2, r3
  4092ce:	88fb      	ldrh	r3, [r7, #6]
  4092d0:	4413      	add	r3, r2
  4092d2:	b29b      	uxth	r3, r3
  4092d4:	3b08      	subs	r3, #8
  4092d6:	80fb      	strh	r3, [r7, #6]
  4092d8:	e01d      	b.n	409316 <copy_bits+0x10a>
  4092da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4092dc:	781a      	ldrb	r2, [r3, #0]
  4092de:	4973      	ldr	r1, [pc, #460]	; (4094ac <copy_bits+0x2a0>)
  4092e0:	69fb      	ldr	r3, [r7, #28]
  4092e2:	440b      	add	r3, r1
  4092e4:	7819      	ldrb	r1, [r3, #0]
  4092e6:	88f8      	ldrh	r0, [r7, #6]
  4092e8:	69fb      	ldr	r3, [r7, #28]
  4092ea:	4403      	add	r3, r0
  4092ec:	3301      	adds	r3, #1
  4092ee:	486e      	ldr	r0, [pc, #440]	; (4094a8 <copy_bits+0x29c>)
  4092f0:	5cc3      	ldrb	r3, [r0, r3]
  4092f2:	430b      	orrs	r3, r1
  4092f4:	b2db      	uxtb	r3, r3
  4092f6:	4013      	ands	r3, r2
  4092f8:	b2da      	uxtb	r2, r3
  4092fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4092fc:	701a      	strb	r2, [r3, #0]
  4092fe:	88fa      	ldrh	r2, [r7, #6]
  409300:	69fb      	ldr	r3, [r7, #28]
  409302:	4413      	add	r3, r2
  409304:	4a69      	ldr	r2, [pc, #420]	; (4094ac <copy_bits+0x2a0>)
  409306:	5cd2      	ldrb	r2, [r2, r3]
  409308:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  40930c:	4013      	ands	r3, r2
  40930e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  409312:	2300      	movs	r3, #0
  409314:	80fb      	strh	r3, [r7, #6]
            *destination++ |= c;
  409316:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409318:	1c5a      	adds	r2, r3, #1
  40931a:	63ba      	str	r2, [r7, #56]	; 0x38
  40931c:	7819      	ldrb	r1, [r3, #0]
  40931e:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
  409322:	430a      	orrs	r2, r1
  409324:	b2d2      	uxtb	r2, r2
  409326:	701a      	strb	r2, [r3, #0]
        }

        int byte_len = bit_count / CHAR_BIT;
  409328:	88fb      	ldrh	r3, [r7, #6]
  40932a:	08db      	lsrs	r3, r3, #3
  40932c:	b29b      	uxth	r3, r3
  40932e:	61bb      	str	r3, [r7, #24]
        int bit_count_modulo = bit_count % CHAR_BIT;
  409330:	88fb      	ldrh	r3, [r7, #6]
  409332:	f003 0307 	and.w	r3, r3, #7
  409336:	617b      	str	r3, [r7, #20]

        if(byte_len > 0) {
  409338:	69bb      	ldr	r3, [r7, #24]
  40933a:	2b00      	cmp	r3, #0
  40933c:	dd0d      	ble.n	40935a <copy_bits+0x14e>
            memcpy(destination, source, byte_len);
  40933e:	69bb      	ldr	r3, [r7, #24]
  409340:	461a      	mov	r2, r3
  409342:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409344:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  409346:	4b5a      	ldr	r3, [pc, #360]	; (4094b0 <copy_bits+0x2a4>)
  409348:	4798      	blx	r3
            source += byte_len;
  40934a:	69bb      	ldr	r3, [r7, #24]
  40934c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  40934e:	4413      	add	r3, r2
  409350:	63fb      	str	r3, [r7, #60]	; 0x3c
            destination += byte_len;
  409352:	69bb      	ldr	r3, [r7, #24]
  409354:	6bba      	ldr	r2, [r7, #56]	; 0x38
  409356:	4413      	add	r3, r2
  409358:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        if(bit_count_modulo > 0) {
  40935a:	697b      	ldr	r3, [r7, #20]
  40935c:	2b00      	cmp	r3, #0
  40935e:	f340 8105 	ble.w	40956c <copy_bits+0x360>
            *destination &= reverse_mask_xor[bit_count_modulo];
  409362:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409364:	781a      	ldrb	r2, [r3, #0]
  409366:	4950      	ldr	r1, [pc, #320]	; (4094a8 <copy_bits+0x29c>)
  409368:	697b      	ldr	r3, [r7, #20]
  40936a:	440b      	add	r3, r1
  40936c:	781b      	ldrb	r3, [r3, #0]
  40936e:	4013      	ands	r3, r2
  409370:	b2da      	uxtb	r2, r3
  409372:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409374:	701a      	strb	r2, [r3, #0]
            *destination |= reverse_mask[bit_count_modulo] & *source;
  409376:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409378:	781a      	ldrb	r2, [r3, #0]
  40937a:	494c      	ldr	r1, [pc, #304]	; (4094ac <copy_bits+0x2a0>)
  40937c:	697b      	ldr	r3, [r7, #20]
  40937e:	440b      	add	r3, r1
  409380:	7819      	ldrb	r1, [r3, #0]
  409382:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409384:	781b      	ldrb	r3, [r3, #0]
  409386:	400b      	ands	r3, r1
  409388:	b2db      	uxtb	r3, r3
  40938a:	4313      	orrs	r3, r2
  40938c:	b2da      	uxtb	r2, r3
  40938e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409390:	701a      	strb	r2, [r3, #0]
  409392:	e0eb      	b.n	40956c <copy_bits+0x360>
        int bit_diff_right_shift;
        uint8_t c;
        /*
         * Begin: Line things up on destination.
         */
        if(source_offset_modulo > destination_offset_modulo) {
  409394:	6a3a      	ldr	r2, [r7, #32]
  409396:	69fb      	ldr	r3, [r7, #28]
  409398:	429a      	cmp	r2, r3
  40939a:	dd28      	ble.n	4093ee <copy_bits+0x1e2>
            bit_diff_left_shift = source_offset_modulo - destination_offset_modulo;
  40939c:	6a3a      	ldr	r2, [r7, #32]
  40939e:	69fb      	ldr	r3, [r7, #28]
  4093a0:	1ad3      	subs	r3, r2, r3
  4093a2:	633b      	str	r3, [r7, #48]	; 0x30
            bit_diff_right_shift = CHAR_BIT - bit_diff_left_shift;
  4093a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4093a6:	f1c3 0308 	rsb	r3, r3, #8
  4093aa:	62fb      	str	r3, [r7, #44]	; 0x2c

            c = *source++ << bit_diff_left_shift;
  4093ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  4093ae:	1c5a      	adds	r2, r3, #1
  4093b0:	63fa      	str	r2, [r7, #60]	; 0x3c
  4093b2:	781b      	ldrb	r3, [r3, #0]
  4093b4:	461a      	mov	r2, r3
  4093b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4093b8:	fa02 f303 	lsl.w	r3, r2, r3
  4093bc:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            c |= *source >> bit_diff_right_shift;
  4093c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  4093c2:	781b      	ldrb	r3, [r3, #0]
  4093c4:	461a      	mov	r2, r3
  4093c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4093c8:	fa42 f303 	asr.w	r3, r2, r3
  4093cc:	b25a      	sxtb	r2, r3
  4093ce:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
  4093d2:	4313      	orrs	r3, r2
  4093d4:	b25b      	sxtb	r3, r3
  4093d6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            c &= reverse_mask_xor[destination_offset_modulo];
  4093da:	4a33      	ldr	r2, [pc, #204]	; (4094a8 <copy_bits+0x29c>)
  4093dc:	69fb      	ldr	r3, [r7, #28]
  4093de:	4413      	add	r3, r2
  4093e0:	781a      	ldrb	r2, [r3, #0]
  4093e2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4093e6:	4013      	ands	r3, r2
  4093e8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  4093ec:	e017      	b.n	40941e <copy_bits+0x212>
        } else {
            bit_diff_right_shift = destination_offset_modulo - source_offset_modulo;
  4093ee:	69fa      	ldr	r2, [r7, #28]
  4093f0:	6a3b      	ldr	r3, [r7, #32]
  4093f2:	1ad3      	subs	r3, r2, r3
  4093f4:	62fb      	str	r3, [r7, #44]	; 0x2c
            bit_diff_left_shift = CHAR_BIT - bit_diff_right_shift;
  4093f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4093f8:	f1c3 0308 	rsb	r3, r3, #8
  4093fc:	633b      	str	r3, [r7, #48]	; 0x30

            c = *source >> bit_diff_right_shift &
  4093fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409400:	781b      	ldrb	r3, [r3, #0]
  409402:	461a      	mov	r2, r3
  409404:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409406:	fa42 f303 	asr.w	r3, r2, r3
  40940a:	b25a      	sxtb	r2, r3
                    reverse_mask_xor[destination_offset_modulo];
  40940c:	4926      	ldr	r1, [pc, #152]	; (4094a8 <copy_bits+0x29c>)
  40940e:	69fb      	ldr	r3, [r7, #28]
  409410:	440b      	add	r3, r1
  409412:	781b      	ldrb	r3, [r3, #0]
  409414:	b25b      	sxtb	r3, r3
            c = *source >> bit_diff_right_shift &
  409416:	4013      	ands	r3, r2
  409418:	b25b      	sxtb	r3, r3
  40941a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }
        PREPARE_FIRST_COPY();
  40941e:	88fa      	ldrh	r2, [r7, #6]
  409420:	69fb      	ldr	r3, [r7, #28]
  409422:	f1c3 0308 	rsb	r3, r3, #8
  409426:	429a      	cmp	r2, r3
  409428:	db11      	blt.n	40944e <copy_bits+0x242>
  40942a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40942c:	781a      	ldrb	r2, [r3, #0]
  40942e:	491f      	ldr	r1, [pc, #124]	; (4094ac <copy_bits+0x2a0>)
  409430:	69fb      	ldr	r3, [r7, #28]
  409432:	440b      	add	r3, r1
  409434:	781b      	ldrb	r3, [r3, #0]
  409436:	4013      	ands	r3, r2
  409438:	b2da      	uxtb	r2, r3
  40943a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40943c:	701a      	strb	r2, [r3, #0]
  40943e:	69fb      	ldr	r3, [r7, #28]
  409440:	b29a      	uxth	r2, r3
  409442:	88fb      	ldrh	r3, [r7, #6]
  409444:	4413      	add	r3, r2
  409446:	b29b      	uxth	r3, r3
  409448:	3b08      	subs	r3, #8
  40944a:	80fb      	strh	r3, [r7, #6]
  40944c:	e01d      	b.n	40948a <copy_bits+0x27e>
  40944e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409450:	781a      	ldrb	r2, [r3, #0]
  409452:	4916      	ldr	r1, [pc, #88]	; (4094ac <copy_bits+0x2a0>)
  409454:	69fb      	ldr	r3, [r7, #28]
  409456:	440b      	add	r3, r1
  409458:	7819      	ldrb	r1, [r3, #0]
  40945a:	88f8      	ldrh	r0, [r7, #6]
  40945c:	69fb      	ldr	r3, [r7, #28]
  40945e:	4403      	add	r3, r0
  409460:	3301      	adds	r3, #1
  409462:	4811      	ldr	r0, [pc, #68]	; (4094a8 <copy_bits+0x29c>)
  409464:	5cc3      	ldrb	r3, [r0, r3]
  409466:	430b      	orrs	r3, r1
  409468:	b2db      	uxtb	r3, r3
  40946a:	4013      	ands	r3, r2
  40946c:	b2da      	uxtb	r2, r3
  40946e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  409470:	701a      	strb	r2, [r3, #0]
  409472:	88fa      	ldrh	r2, [r7, #6]
  409474:	69fb      	ldr	r3, [r7, #28]
  409476:	4413      	add	r3, r2
  409478:	4a0c      	ldr	r2, [pc, #48]	; (4094ac <copy_bits+0x2a0>)
  40947a:	5cd2      	ldrb	r2, [r2, r3]
  40947c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  409480:	4013      	ands	r3, r2
  409482:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  409486:	2300      	movs	r3, #0
  409488:	80fb      	strh	r3, [r7, #6]
        *destination++ |= c;
  40948a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40948c:	1c5a      	adds	r2, r3, #1
  40948e:	63ba      	str	r2, [r7, #56]	; 0x38
  409490:	7819      	ldrb	r1, [r3, #0]
  409492:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  409496:	430a      	orrs	r2, r1
  409498:	b2d2      	uxtb	r2, r2
  40949a:	701a      	strb	r2, [r3, #0]

        /*
         * Middle: copy with only shifting the source.
         */
        int byte_len = bit_count / CHAR_BIT;
  40949c:	88fb      	ldrh	r3, [r7, #6]
  40949e:	08db      	lsrs	r3, r3, #3
  4094a0:	b29b      	uxth	r3, r3
  4094a2:	627b      	str	r3, [r7, #36]	; 0x24
        while(--byte_len >= 0) {
  4094a4:	e023      	b.n	4094ee <copy_bits+0x2e2>
  4094a6:	bf00      	nop
  4094a8:	0040af40 	.word	0x0040af40
  4094ac:	0040af34 	.word	0x0040af34
  4094b0:	0040a635 	.word	0x0040a635
            c = *source++ << bit_diff_left_shift;
  4094b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  4094b6:	1c5a      	adds	r2, r3, #1
  4094b8:	63fa      	str	r2, [r7, #60]	; 0x3c
  4094ba:	781b      	ldrb	r3, [r3, #0]
  4094bc:	461a      	mov	r2, r3
  4094be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4094c0:	fa02 f303 	lsl.w	r3, r2, r3
  4094c4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            c |= *source >> bit_diff_right_shift;
  4094c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  4094ca:	781b      	ldrb	r3, [r3, #0]
  4094cc:	461a      	mov	r2, r3
  4094ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4094d0:	fa42 f303 	asr.w	r3, r2, r3
  4094d4:	b25a      	sxtb	r2, r3
  4094d6:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
  4094da:	4313      	orrs	r3, r2
  4094dc:	b25b      	sxtb	r3, r3
  4094de:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            *destination++ = c;
  4094e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  4094e4:	1c5a      	adds	r2, r3, #1
  4094e6:	63ba      	str	r2, [r7, #56]	; 0x38
  4094e8:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  4094ec:	701a      	strb	r2, [r3, #0]
        while(--byte_len >= 0) {
  4094ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4094f0:	3b01      	subs	r3, #1
  4094f2:	627b      	str	r3, [r7, #36]	; 0x24
  4094f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4094f6:	2b00      	cmp	r3, #0
  4094f8:	dadc      	bge.n	4094b4 <copy_bits+0x2a8>
        }

        /*
         * End: copy the remaing bits;
         */
        int bit_count_modulo = bit_count % CHAR_BIT;
  4094fa:	88fb      	ldrh	r3, [r7, #6]
  4094fc:	f003 0307 	and.w	r3, r3, #7
  409500:	613b      	str	r3, [r7, #16]
        if(bit_count_modulo > 0) {
  409502:	693b      	ldr	r3, [r7, #16]
  409504:	2b00      	cmp	r3, #0
  409506:	dd31      	ble.n	40956c <copy_bits+0x360>
            c = *source++ << bit_diff_left_shift;
  409508:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40950a:	1c5a      	adds	r2, r3, #1
  40950c:	63fa      	str	r2, [r7, #60]	; 0x3c
  40950e:	781b      	ldrb	r3, [r3, #0]
  409510:	461a      	mov	r2, r3
  409512:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  409514:	fa02 f303 	lsl.w	r3, r2, r3
  409518:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            c |= *source >> bit_diff_right_shift;
  40951c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40951e:	781b      	ldrb	r3, [r3, #0]
  409520:	461a      	mov	r2, r3
  409522:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409524:	fa42 f303 	asr.w	r3, r2, r3
  409528:	b25a      	sxtb	r2, r3
  40952a:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
  40952e:	4313      	orrs	r3, r2
  409530:	b25b      	sxtb	r3, r3
  409532:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            c &= reverse_mask[bit_count_modulo];
  409536:	4a10      	ldr	r2, [pc, #64]	; (409578 <copy_bits+0x36c>)
  409538:	693b      	ldr	r3, [r7, #16]
  40953a:	4413      	add	r3, r2
  40953c:	781a      	ldrb	r2, [r3, #0]
  40953e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  409542:	4013      	ands	r3, r2
  409544:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

            *destination &= reverse_mask_xor[bit_count_modulo];
  409548:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40954a:	781a      	ldrb	r2, [r3, #0]
  40954c:	490b      	ldr	r1, [pc, #44]	; (40957c <copy_bits+0x370>)
  40954e:	693b      	ldr	r3, [r7, #16]
  409550:	440b      	add	r3, r1
  409552:	781b      	ldrb	r3, [r3, #0]
  409554:	4013      	ands	r3, r2
  409556:	b2da      	uxtb	r2, r3
  409558:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40955a:	701a      	strb	r2, [r3, #0]
            *destination |= c;
  40955c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40955e:	781a      	ldrb	r2, [r3, #0]
  409560:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  409564:	4313      	orrs	r3, r2
  409566:	b2da      	uxtb	r2, r3
  409568:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40956a:	701a      	strb	r2, [r3, #0]
        }
    }
    return true;
  40956c:	2301      	movs	r3, #1
}
  40956e:	4618      	mov	r0, r3
  409570:	3740      	adds	r7, #64	; 0x40
  409572:	46bd      	mov	sp, r7
  409574:	bd80      	pop	{r7, pc}
  409576:	bf00      	nop
  409578:	0040af34 	.word	0x0040af34
  40957c:	0040af40 	.word	0x0040af40

00409580 <__aeabi_drsub>:
  409580:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  409584:	e002      	b.n	40958c <__adddf3>
  409586:	bf00      	nop

00409588 <__aeabi_dsub>:
  409588:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0040958c <__adddf3>:
  40958c:	b530      	push	{r4, r5, lr}
  40958e:	ea4f 0441 	mov.w	r4, r1, lsl #1
  409592:	ea4f 0543 	mov.w	r5, r3, lsl #1
  409596:	ea94 0f05 	teq	r4, r5
  40959a:	bf08      	it	eq
  40959c:	ea90 0f02 	teqeq	r0, r2
  4095a0:	bf1f      	itttt	ne
  4095a2:	ea54 0c00 	orrsne.w	ip, r4, r0
  4095a6:	ea55 0c02 	orrsne.w	ip, r5, r2
  4095aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  4095ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4095b2:	f000 80e2 	beq.w	40977a <__adddf3+0x1ee>
  4095b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
  4095ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  4095be:	bfb8      	it	lt
  4095c0:	426d      	neglt	r5, r5
  4095c2:	dd0c      	ble.n	4095de <__adddf3+0x52>
  4095c4:	442c      	add	r4, r5
  4095c6:	ea80 0202 	eor.w	r2, r0, r2
  4095ca:	ea81 0303 	eor.w	r3, r1, r3
  4095ce:	ea82 0000 	eor.w	r0, r2, r0
  4095d2:	ea83 0101 	eor.w	r1, r3, r1
  4095d6:	ea80 0202 	eor.w	r2, r0, r2
  4095da:	ea81 0303 	eor.w	r3, r1, r3
  4095de:	2d36      	cmp	r5, #54	; 0x36
  4095e0:	bf88      	it	hi
  4095e2:	bd30      	pophi	{r4, r5, pc}
  4095e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4095e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4095ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4095f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4095f4:	d002      	beq.n	4095fc <__adddf3+0x70>
  4095f6:	4240      	negs	r0, r0
  4095f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4095fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  409600:	ea4f 3303 	mov.w	r3, r3, lsl #12
  409604:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  409608:	d002      	beq.n	409610 <__adddf3+0x84>
  40960a:	4252      	negs	r2, r2
  40960c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  409610:	ea94 0f05 	teq	r4, r5
  409614:	f000 80a7 	beq.w	409766 <__adddf3+0x1da>
  409618:	f1a4 0401 	sub.w	r4, r4, #1
  40961c:	f1d5 0e20 	rsbs	lr, r5, #32
  409620:	db0d      	blt.n	40963e <__adddf3+0xb2>
  409622:	fa02 fc0e 	lsl.w	ip, r2, lr
  409626:	fa22 f205 	lsr.w	r2, r2, r5
  40962a:	1880      	adds	r0, r0, r2
  40962c:	f141 0100 	adc.w	r1, r1, #0
  409630:	fa03 f20e 	lsl.w	r2, r3, lr
  409634:	1880      	adds	r0, r0, r2
  409636:	fa43 f305 	asr.w	r3, r3, r5
  40963a:	4159      	adcs	r1, r3
  40963c:	e00e      	b.n	40965c <__adddf3+0xd0>
  40963e:	f1a5 0520 	sub.w	r5, r5, #32
  409642:	f10e 0e20 	add.w	lr, lr, #32
  409646:	2a01      	cmp	r2, #1
  409648:	fa03 fc0e 	lsl.w	ip, r3, lr
  40964c:	bf28      	it	cs
  40964e:	f04c 0c02 	orrcs.w	ip, ip, #2
  409652:	fa43 f305 	asr.w	r3, r3, r5
  409656:	18c0      	adds	r0, r0, r3
  409658:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  40965c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  409660:	d507      	bpl.n	409672 <__adddf3+0xe6>
  409662:	f04f 0e00 	mov.w	lr, #0
  409666:	f1dc 0c00 	rsbs	ip, ip, #0
  40966a:	eb7e 0000 	sbcs.w	r0, lr, r0
  40966e:	eb6e 0101 	sbc.w	r1, lr, r1
  409672:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  409676:	d31b      	bcc.n	4096b0 <__adddf3+0x124>
  409678:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  40967c:	d30c      	bcc.n	409698 <__adddf3+0x10c>
  40967e:	0849      	lsrs	r1, r1, #1
  409680:	ea5f 0030 	movs.w	r0, r0, rrx
  409684:	ea4f 0c3c 	mov.w	ip, ip, rrx
  409688:	f104 0401 	add.w	r4, r4, #1
  40968c:	ea4f 5244 	mov.w	r2, r4, lsl #21
  409690:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  409694:	f080 809a 	bcs.w	4097cc <__adddf3+0x240>
  409698:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  40969c:	bf08      	it	eq
  40969e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  4096a2:	f150 0000 	adcs.w	r0, r0, #0
  4096a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4096aa:	ea41 0105 	orr.w	r1, r1, r5
  4096ae:	bd30      	pop	{r4, r5, pc}
  4096b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  4096b4:	4140      	adcs	r0, r0
  4096b6:	eb41 0101 	adc.w	r1, r1, r1
  4096ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4096be:	f1a4 0401 	sub.w	r4, r4, #1
  4096c2:	d1e9      	bne.n	409698 <__adddf3+0x10c>
  4096c4:	f091 0f00 	teq	r1, #0
  4096c8:	bf04      	itt	eq
  4096ca:	4601      	moveq	r1, r0
  4096cc:	2000      	moveq	r0, #0
  4096ce:	fab1 f381 	clz	r3, r1
  4096d2:	bf08      	it	eq
  4096d4:	3320      	addeq	r3, #32
  4096d6:	f1a3 030b 	sub.w	r3, r3, #11
  4096da:	f1b3 0220 	subs.w	r2, r3, #32
  4096de:	da0c      	bge.n	4096fa <__adddf3+0x16e>
  4096e0:	320c      	adds	r2, #12
  4096e2:	dd08      	ble.n	4096f6 <__adddf3+0x16a>
  4096e4:	f102 0c14 	add.w	ip, r2, #20
  4096e8:	f1c2 020c 	rsb	r2, r2, #12
  4096ec:	fa01 f00c 	lsl.w	r0, r1, ip
  4096f0:	fa21 f102 	lsr.w	r1, r1, r2
  4096f4:	e00c      	b.n	409710 <__adddf3+0x184>
  4096f6:	f102 0214 	add.w	r2, r2, #20
  4096fa:	bfd8      	it	le
  4096fc:	f1c2 0c20 	rsble	ip, r2, #32
  409700:	fa01 f102 	lsl.w	r1, r1, r2
  409704:	fa20 fc0c 	lsr.w	ip, r0, ip
  409708:	bfdc      	itt	le
  40970a:	ea41 010c 	orrle.w	r1, r1, ip
  40970e:	4090      	lslle	r0, r2
  409710:	1ae4      	subs	r4, r4, r3
  409712:	bfa2      	ittt	ge
  409714:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  409718:	4329      	orrge	r1, r5
  40971a:	bd30      	popge	{r4, r5, pc}
  40971c:	ea6f 0404 	mvn.w	r4, r4
  409720:	3c1f      	subs	r4, #31
  409722:	da1c      	bge.n	40975e <__adddf3+0x1d2>
  409724:	340c      	adds	r4, #12
  409726:	dc0e      	bgt.n	409746 <__adddf3+0x1ba>
  409728:	f104 0414 	add.w	r4, r4, #20
  40972c:	f1c4 0220 	rsb	r2, r4, #32
  409730:	fa20 f004 	lsr.w	r0, r0, r4
  409734:	fa01 f302 	lsl.w	r3, r1, r2
  409738:	ea40 0003 	orr.w	r0, r0, r3
  40973c:	fa21 f304 	lsr.w	r3, r1, r4
  409740:	ea45 0103 	orr.w	r1, r5, r3
  409744:	bd30      	pop	{r4, r5, pc}
  409746:	f1c4 040c 	rsb	r4, r4, #12
  40974a:	f1c4 0220 	rsb	r2, r4, #32
  40974e:	fa20 f002 	lsr.w	r0, r0, r2
  409752:	fa01 f304 	lsl.w	r3, r1, r4
  409756:	ea40 0003 	orr.w	r0, r0, r3
  40975a:	4629      	mov	r1, r5
  40975c:	bd30      	pop	{r4, r5, pc}
  40975e:	fa21 f004 	lsr.w	r0, r1, r4
  409762:	4629      	mov	r1, r5
  409764:	bd30      	pop	{r4, r5, pc}
  409766:	f094 0f00 	teq	r4, #0
  40976a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  40976e:	bf06      	itte	eq
  409770:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  409774:	3401      	addeq	r4, #1
  409776:	3d01      	subne	r5, #1
  409778:	e74e      	b.n	409618 <__adddf3+0x8c>
  40977a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40977e:	bf18      	it	ne
  409780:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  409784:	d029      	beq.n	4097da <__adddf3+0x24e>
  409786:	ea94 0f05 	teq	r4, r5
  40978a:	bf08      	it	eq
  40978c:	ea90 0f02 	teqeq	r0, r2
  409790:	d005      	beq.n	40979e <__adddf3+0x212>
  409792:	ea54 0c00 	orrs.w	ip, r4, r0
  409796:	bf04      	itt	eq
  409798:	4619      	moveq	r1, r3
  40979a:	4610      	moveq	r0, r2
  40979c:	bd30      	pop	{r4, r5, pc}
  40979e:	ea91 0f03 	teq	r1, r3
  4097a2:	bf1e      	ittt	ne
  4097a4:	2100      	movne	r1, #0
  4097a6:	2000      	movne	r0, #0
  4097a8:	bd30      	popne	{r4, r5, pc}
  4097aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  4097ae:	d105      	bne.n	4097bc <__adddf3+0x230>
  4097b0:	0040      	lsls	r0, r0, #1
  4097b2:	4149      	adcs	r1, r1
  4097b4:	bf28      	it	cs
  4097b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  4097ba:	bd30      	pop	{r4, r5, pc}
  4097bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4097c0:	bf3c      	itt	cc
  4097c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  4097c6:	bd30      	popcc	{r4, r5, pc}
  4097c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4097cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  4097d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4097d4:	f04f 0000 	mov.w	r0, #0
  4097d8:	bd30      	pop	{r4, r5, pc}
  4097da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4097de:	bf1a      	itte	ne
  4097e0:	4619      	movne	r1, r3
  4097e2:	4610      	movne	r0, r2
  4097e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4097e8:	bf1c      	itt	ne
  4097ea:	460b      	movne	r3, r1
  4097ec:	4602      	movne	r2, r0
  4097ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4097f2:	bf06      	itte	eq
  4097f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4097f8:	ea91 0f03 	teqeq	r1, r3
  4097fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  409800:	bd30      	pop	{r4, r5, pc}
  409802:	bf00      	nop

00409804 <__aeabi_ui2d>:
  409804:	f090 0f00 	teq	r0, #0
  409808:	bf04      	itt	eq
  40980a:	2100      	moveq	r1, #0
  40980c:	4770      	bxeq	lr
  40980e:	b530      	push	{r4, r5, lr}
  409810:	f44f 6480 	mov.w	r4, #1024	; 0x400
  409814:	f104 0432 	add.w	r4, r4, #50	; 0x32
  409818:	f04f 0500 	mov.w	r5, #0
  40981c:	f04f 0100 	mov.w	r1, #0
  409820:	e750      	b.n	4096c4 <__adddf3+0x138>
  409822:	bf00      	nop

00409824 <__aeabi_i2d>:
  409824:	f090 0f00 	teq	r0, #0
  409828:	bf04      	itt	eq
  40982a:	2100      	moveq	r1, #0
  40982c:	4770      	bxeq	lr
  40982e:	b530      	push	{r4, r5, lr}
  409830:	f44f 6480 	mov.w	r4, #1024	; 0x400
  409834:	f104 0432 	add.w	r4, r4, #50	; 0x32
  409838:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  40983c:	bf48      	it	mi
  40983e:	4240      	negmi	r0, r0
  409840:	f04f 0100 	mov.w	r1, #0
  409844:	e73e      	b.n	4096c4 <__adddf3+0x138>
  409846:	bf00      	nop

00409848 <__aeabi_f2d>:
  409848:	0042      	lsls	r2, r0, #1
  40984a:	ea4f 01e2 	mov.w	r1, r2, asr #3
  40984e:	ea4f 0131 	mov.w	r1, r1, rrx
  409852:	ea4f 7002 	mov.w	r0, r2, lsl #28
  409856:	bf1f      	itttt	ne
  409858:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  40985c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  409860:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  409864:	4770      	bxne	lr
  409866:	f092 0f00 	teq	r2, #0
  40986a:	bf14      	ite	ne
  40986c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  409870:	4770      	bxeq	lr
  409872:	b530      	push	{r4, r5, lr}
  409874:	f44f 7460 	mov.w	r4, #896	; 0x380
  409878:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40987c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  409880:	e720      	b.n	4096c4 <__adddf3+0x138>
  409882:	bf00      	nop

00409884 <__aeabi_ul2d>:
  409884:	ea50 0201 	orrs.w	r2, r0, r1
  409888:	bf08      	it	eq
  40988a:	4770      	bxeq	lr
  40988c:	b530      	push	{r4, r5, lr}
  40988e:	f04f 0500 	mov.w	r5, #0
  409892:	e00a      	b.n	4098aa <__aeabi_l2d+0x16>

00409894 <__aeabi_l2d>:
  409894:	ea50 0201 	orrs.w	r2, r0, r1
  409898:	bf08      	it	eq
  40989a:	4770      	bxeq	lr
  40989c:	b530      	push	{r4, r5, lr}
  40989e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  4098a2:	d502      	bpl.n	4098aa <__aeabi_l2d+0x16>
  4098a4:	4240      	negs	r0, r0
  4098a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4098aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4098ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4098b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  4098b6:	f43f aedc 	beq.w	409672 <__adddf3+0xe6>
  4098ba:	f04f 0203 	mov.w	r2, #3
  4098be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4098c2:	bf18      	it	ne
  4098c4:	3203      	addne	r2, #3
  4098c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4098ca:	bf18      	it	ne
  4098cc:	3203      	addne	r2, #3
  4098ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  4098d2:	f1c2 0320 	rsb	r3, r2, #32
  4098d6:	fa00 fc03 	lsl.w	ip, r0, r3
  4098da:	fa20 f002 	lsr.w	r0, r0, r2
  4098de:	fa01 fe03 	lsl.w	lr, r1, r3
  4098e2:	ea40 000e 	orr.w	r0, r0, lr
  4098e6:	fa21 f102 	lsr.w	r1, r1, r2
  4098ea:	4414      	add	r4, r2
  4098ec:	e6c1      	b.n	409672 <__adddf3+0xe6>
  4098ee:	bf00      	nop

004098f0 <__aeabi_dmul>:
  4098f0:	b570      	push	{r4, r5, r6, lr}
  4098f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4098f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4098fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4098fe:	bf1d      	ittte	ne
  409900:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  409904:	ea94 0f0c 	teqne	r4, ip
  409908:	ea95 0f0c 	teqne	r5, ip
  40990c:	f000 f8de 	bleq	409acc <__aeabi_dmul+0x1dc>
  409910:	442c      	add	r4, r5
  409912:	ea81 0603 	eor.w	r6, r1, r3
  409916:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  40991a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  40991e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  409922:	bf18      	it	ne
  409924:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  409928:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40992c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  409930:	d038      	beq.n	4099a4 <__aeabi_dmul+0xb4>
  409932:	fba0 ce02 	umull	ip, lr, r0, r2
  409936:	f04f 0500 	mov.w	r5, #0
  40993a:	fbe1 e502 	umlal	lr, r5, r1, r2
  40993e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  409942:	fbe0 e503 	umlal	lr, r5, r0, r3
  409946:	f04f 0600 	mov.w	r6, #0
  40994a:	fbe1 5603 	umlal	r5, r6, r1, r3
  40994e:	f09c 0f00 	teq	ip, #0
  409952:	bf18      	it	ne
  409954:	f04e 0e01 	orrne.w	lr, lr, #1
  409958:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  40995c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  409960:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  409964:	d204      	bcs.n	409970 <__aeabi_dmul+0x80>
  409966:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  40996a:	416d      	adcs	r5, r5
  40996c:	eb46 0606 	adc.w	r6, r6, r6
  409970:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  409974:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  409978:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  40997c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  409980:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  409984:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  409988:	bf88      	it	hi
  40998a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  40998e:	d81e      	bhi.n	4099ce <__aeabi_dmul+0xde>
  409990:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  409994:	bf08      	it	eq
  409996:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  40999a:	f150 0000 	adcs.w	r0, r0, #0
  40999e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4099a2:	bd70      	pop	{r4, r5, r6, pc}
  4099a4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  4099a8:	ea46 0101 	orr.w	r1, r6, r1
  4099ac:	ea40 0002 	orr.w	r0, r0, r2
  4099b0:	ea81 0103 	eor.w	r1, r1, r3
  4099b4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  4099b8:	bfc2      	ittt	gt
  4099ba:	ebd4 050c 	rsbsgt	r5, r4, ip
  4099be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  4099c2:	bd70      	popgt	{r4, r5, r6, pc}
  4099c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4099c8:	f04f 0e00 	mov.w	lr, #0
  4099cc:	3c01      	subs	r4, #1
  4099ce:	f300 80ab 	bgt.w	409b28 <__aeabi_dmul+0x238>
  4099d2:	f114 0f36 	cmn.w	r4, #54	; 0x36
  4099d6:	bfde      	ittt	le
  4099d8:	2000      	movle	r0, #0
  4099da:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  4099de:	bd70      	pople	{r4, r5, r6, pc}
  4099e0:	f1c4 0400 	rsb	r4, r4, #0
  4099e4:	3c20      	subs	r4, #32
  4099e6:	da35      	bge.n	409a54 <__aeabi_dmul+0x164>
  4099e8:	340c      	adds	r4, #12
  4099ea:	dc1b      	bgt.n	409a24 <__aeabi_dmul+0x134>
  4099ec:	f104 0414 	add.w	r4, r4, #20
  4099f0:	f1c4 0520 	rsb	r5, r4, #32
  4099f4:	fa00 f305 	lsl.w	r3, r0, r5
  4099f8:	fa20 f004 	lsr.w	r0, r0, r4
  4099fc:	fa01 f205 	lsl.w	r2, r1, r5
  409a00:	ea40 0002 	orr.w	r0, r0, r2
  409a04:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  409a08:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  409a0c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  409a10:	fa21 f604 	lsr.w	r6, r1, r4
  409a14:	eb42 0106 	adc.w	r1, r2, r6
  409a18:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  409a1c:	bf08      	it	eq
  409a1e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  409a22:	bd70      	pop	{r4, r5, r6, pc}
  409a24:	f1c4 040c 	rsb	r4, r4, #12
  409a28:	f1c4 0520 	rsb	r5, r4, #32
  409a2c:	fa00 f304 	lsl.w	r3, r0, r4
  409a30:	fa20 f005 	lsr.w	r0, r0, r5
  409a34:	fa01 f204 	lsl.w	r2, r1, r4
  409a38:	ea40 0002 	orr.w	r0, r0, r2
  409a3c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  409a40:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  409a44:	f141 0100 	adc.w	r1, r1, #0
  409a48:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  409a4c:	bf08      	it	eq
  409a4e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  409a52:	bd70      	pop	{r4, r5, r6, pc}
  409a54:	f1c4 0520 	rsb	r5, r4, #32
  409a58:	fa00 f205 	lsl.w	r2, r0, r5
  409a5c:	ea4e 0e02 	orr.w	lr, lr, r2
  409a60:	fa20 f304 	lsr.w	r3, r0, r4
  409a64:	fa01 f205 	lsl.w	r2, r1, r5
  409a68:	ea43 0302 	orr.w	r3, r3, r2
  409a6c:	fa21 f004 	lsr.w	r0, r1, r4
  409a70:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  409a74:	fa21 f204 	lsr.w	r2, r1, r4
  409a78:	ea20 0002 	bic.w	r0, r0, r2
  409a7c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  409a80:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  409a84:	bf08      	it	eq
  409a86:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  409a8a:	bd70      	pop	{r4, r5, r6, pc}
  409a8c:	f094 0f00 	teq	r4, #0
  409a90:	d10f      	bne.n	409ab2 <__aeabi_dmul+0x1c2>
  409a92:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  409a96:	0040      	lsls	r0, r0, #1
  409a98:	eb41 0101 	adc.w	r1, r1, r1
  409a9c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  409aa0:	bf08      	it	eq
  409aa2:	3c01      	subeq	r4, #1
  409aa4:	d0f7      	beq.n	409a96 <__aeabi_dmul+0x1a6>
  409aa6:	ea41 0106 	orr.w	r1, r1, r6
  409aaa:	f095 0f00 	teq	r5, #0
  409aae:	bf18      	it	ne
  409ab0:	4770      	bxne	lr
  409ab2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  409ab6:	0052      	lsls	r2, r2, #1
  409ab8:	eb43 0303 	adc.w	r3, r3, r3
  409abc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  409ac0:	bf08      	it	eq
  409ac2:	3d01      	subeq	r5, #1
  409ac4:	d0f7      	beq.n	409ab6 <__aeabi_dmul+0x1c6>
  409ac6:	ea43 0306 	orr.w	r3, r3, r6
  409aca:	4770      	bx	lr
  409acc:	ea94 0f0c 	teq	r4, ip
  409ad0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  409ad4:	bf18      	it	ne
  409ad6:	ea95 0f0c 	teqne	r5, ip
  409ada:	d00c      	beq.n	409af6 <__aeabi_dmul+0x206>
  409adc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  409ae0:	bf18      	it	ne
  409ae2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  409ae6:	d1d1      	bne.n	409a8c <__aeabi_dmul+0x19c>
  409ae8:	ea81 0103 	eor.w	r1, r1, r3
  409aec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  409af0:	f04f 0000 	mov.w	r0, #0
  409af4:	bd70      	pop	{r4, r5, r6, pc}
  409af6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  409afa:	bf06      	itte	eq
  409afc:	4610      	moveq	r0, r2
  409afe:	4619      	moveq	r1, r3
  409b00:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  409b04:	d019      	beq.n	409b3a <__aeabi_dmul+0x24a>
  409b06:	ea94 0f0c 	teq	r4, ip
  409b0a:	d102      	bne.n	409b12 <__aeabi_dmul+0x222>
  409b0c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  409b10:	d113      	bne.n	409b3a <__aeabi_dmul+0x24a>
  409b12:	ea95 0f0c 	teq	r5, ip
  409b16:	d105      	bne.n	409b24 <__aeabi_dmul+0x234>
  409b18:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  409b1c:	bf1c      	itt	ne
  409b1e:	4610      	movne	r0, r2
  409b20:	4619      	movne	r1, r3
  409b22:	d10a      	bne.n	409b3a <__aeabi_dmul+0x24a>
  409b24:	ea81 0103 	eor.w	r1, r1, r3
  409b28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  409b2c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  409b30:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  409b34:	f04f 0000 	mov.w	r0, #0
  409b38:	bd70      	pop	{r4, r5, r6, pc}
  409b3a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  409b3e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  409b42:	bd70      	pop	{r4, r5, r6, pc}

00409b44 <__aeabi_ddiv>:
  409b44:	b570      	push	{r4, r5, r6, lr}
  409b46:	f04f 0cff 	mov.w	ip, #255	; 0xff
  409b4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  409b4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  409b52:	bf1d      	ittte	ne
  409b54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  409b58:	ea94 0f0c 	teqne	r4, ip
  409b5c:	ea95 0f0c 	teqne	r5, ip
  409b60:	f000 f8a7 	bleq	409cb2 <__aeabi_ddiv+0x16e>
  409b64:	eba4 0405 	sub.w	r4, r4, r5
  409b68:	ea81 0e03 	eor.w	lr, r1, r3
  409b6c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  409b70:	ea4f 3101 	mov.w	r1, r1, lsl #12
  409b74:	f000 8088 	beq.w	409c88 <__aeabi_ddiv+0x144>
  409b78:	ea4f 3303 	mov.w	r3, r3, lsl #12
  409b7c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  409b80:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  409b84:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  409b88:	ea4f 2202 	mov.w	r2, r2, lsl #8
  409b8c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  409b90:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  409b94:	ea4f 2600 	mov.w	r6, r0, lsl #8
  409b98:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  409b9c:	429d      	cmp	r5, r3
  409b9e:	bf08      	it	eq
  409ba0:	4296      	cmpeq	r6, r2
  409ba2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  409ba6:	f504 7440 	add.w	r4, r4, #768	; 0x300
  409baa:	d202      	bcs.n	409bb2 <__aeabi_ddiv+0x6e>
  409bac:	085b      	lsrs	r3, r3, #1
  409bae:	ea4f 0232 	mov.w	r2, r2, rrx
  409bb2:	1ab6      	subs	r6, r6, r2
  409bb4:	eb65 0503 	sbc.w	r5, r5, r3
  409bb8:	085b      	lsrs	r3, r3, #1
  409bba:	ea4f 0232 	mov.w	r2, r2, rrx
  409bbe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  409bc2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  409bc6:	ebb6 0e02 	subs.w	lr, r6, r2
  409bca:	eb75 0e03 	sbcs.w	lr, r5, r3
  409bce:	bf22      	ittt	cs
  409bd0:	1ab6      	subcs	r6, r6, r2
  409bd2:	4675      	movcs	r5, lr
  409bd4:	ea40 000c 	orrcs.w	r0, r0, ip
  409bd8:	085b      	lsrs	r3, r3, #1
  409bda:	ea4f 0232 	mov.w	r2, r2, rrx
  409bde:	ebb6 0e02 	subs.w	lr, r6, r2
  409be2:	eb75 0e03 	sbcs.w	lr, r5, r3
  409be6:	bf22      	ittt	cs
  409be8:	1ab6      	subcs	r6, r6, r2
  409bea:	4675      	movcs	r5, lr
  409bec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  409bf0:	085b      	lsrs	r3, r3, #1
  409bf2:	ea4f 0232 	mov.w	r2, r2, rrx
  409bf6:	ebb6 0e02 	subs.w	lr, r6, r2
  409bfa:	eb75 0e03 	sbcs.w	lr, r5, r3
  409bfe:	bf22      	ittt	cs
  409c00:	1ab6      	subcs	r6, r6, r2
  409c02:	4675      	movcs	r5, lr
  409c04:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  409c08:	085b      	lsrs	r3, r3, #1
  409c0a:	ea4f 0232 	mov.w	r2, r2, rrx
  409c0e:	ebb6 0e02 	subs.w	lr, r6, r2
  409c12:	eb75 0e03 	sbcs.w	lr, r5, r3
  409c16:	bf22      	ittt	cs
  409c18:	1ab6      	subcs	r6, r6, r2
  409c1a:	4675      	movcs	r5, lr
  409c1c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  409c20:	ea55 0e06 	orrs.w	lr, r5, r6
  409c24:	d018      	beq.n	409c58 <__aeabi_ddiv+0x114>
  409c26:	ea4f 1505 	mov.w	r5, r5, lsl #4
  409c2a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  409c2e:	ea4f 1606 	mov.w	r6, r6, lsl #4
  409c32:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  409c36:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  409c3a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  409c3e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  409c42:	d1c0      	bne.n	409bc6 <__aeabi_ddiv+0x82>
  409c44:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  409c48:	d10b      	bne.n	409c62 <__aeabi_ddiv+0x11e>
  409c4a:	ea41 0100 	orr.w	r1, r1, r0
  409c4e:	f04f 0000 	mov.w	r0, #0
  409c52:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  409c56:	e7b6      	b.n	409bc6 <__aeabi_ddiv+0x82>
  409c58:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  409c5c:	bf04      	itt	eq
  409c5e:	4301      	orreq	r1, r0
  409c60:	2000      	moveq	r0, #0
  409c62:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  409c66:	bf88      	it	hi
  409c68:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  409c6c:	f63f aeaf 	bhi.w	4099ce <__aeabi_dmul+0xde>
  409c70:	ebb5 0c03 	subs.w	ip, r5, r3
  409c74:	bf04      	itt	eq
  409c76:	ebb6 0c02 	subseq.w	ip, r6, r2
  409c7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  409c7e:	f150 0000 	adcs.w	r0, r0, #0
  409c82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  409c86:	bd70      	pop	{r4, r5, r6, pc}
  409c88:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  409c8c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  409c90:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  409c94:	bfc2      	ittt	gt
  409c96:	ebd4 050c 	rsbsgt	r5, r4, ip
  409c9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  409c9e:	bd70      	popgt	{r4, r5, r6, pc}
  409ca0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  409ca4:	f04f 0e00 	mov.w	lr, #0
  409ca8:	3c01      	subs	r4, #1
  409caa:	e690      	b.n	4099ce <__aeabi_dmul+0xde>
  409cac:	ea45 0e06 	orr.w	lr, r5, r6
  409cb0:	e68d      	b.n	4099ce <__aeabi_dmul+0xde>
  409cb2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  409cb6:	ea94 0f0c 	teq	r4, ip
  409cba:	bf08      	it	eq
  409cbc:	ea95 0f0c 	teqeq	r5, ip
  409cc0:	f43f af3b 	beq.w	409b3a <__aeabi_dmul+0x24a>
  409cc4:	ea94 0f0c 	teq	r4, ip
  409cc8:	d10a      	bne.n	409ce0 <__aeabi_ddiv+0x19c>
  409cca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  409cce:	f47f af34 	bne.w	409b3a <__aeabi_dmul+0x24a>
  409cd2:	ea95 0f0c 	teq	r5, ip
  409cd6:	f47f af25 	bne.w	409b24 <__aeabi_dmul+0x234>
  409cda:	4610      	mov	r0, r2
  409cdc:	4619      	mov	r1, r3
  409cde:	e72c      	b.n	409b3a <__aeabi_dmul+0x24a>
  409ce0:	ea95 0f0c 	teq	r5, ip
  409ce4:	d106      	bne.n	409cf4 <__aeabi_ddiv+0x1b0>
  409ce6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  409cea:	f43f aefd 	beq.w	409ae8 <__aeabi_dmul+0x1f8>
  409cee:	4610      	mov	r0, r2
  409cf0:	4619      	mov	r1, r3
  409cf2:	e722      	b.n	409b3a <__aeabi_dmul+0x24a>
  409cf4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  409cf8:	bf18      	it	ne
  409cfa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  409cfe:	f47f aec5 	bne.w	409a8c <__aeabi_dmul+0x19c>
  409d02:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  409d06:	f47f af0d 	bne.w	409b24 <__aeabi_dmul+0x234>
  409d0a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  409d0e:	f47f aeeb 	bne.w	409ae8 <__aeabi_dmul+0x1f8>
  409d12:	e712      	b.n	409b3a <__aeabi_dmul+0x24a>

00409d14 <__aeabi_d2uiz>:
  409d14:	004a      	lsls	r2, r1, #1
  409d16:	d211      	bcs.n	409d3c <__aeabi_d2uiz+0x28>
  409d18:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  409d1c:	d211      	bcs.n	409d42 <__aeabi_d2uiz+0x2e>
  409d1e:	d50d      	bpl.n	409d3c <__aeabi_d2uiz+0x28>
  409d20:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  409d24:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  409d28:	d40e      	bmi.n	409d48 <__aeabi_d2uiz+0x34>
  409d2a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  409d2e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  409d32:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  409d36:	fa23 f002 	lsr.w	r0, r3, r2
  409d3a:	4770      	bx	lr
  409d3c:	f04f 0000 	mov.w	r0, #0
  409d40:	4770      	bx	lr
  409d42:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  409d46:	d102      	bne.n	409d4e <__aeabi_d2uiz+0x3a>
  409d48:	f04f 30ff 	mov.w	r0, #4294967295
  409d4c:	4770      	bx	lr
  409d4e:	f04f 0000 	mov.w	r0, #0
  409d52:	4770      	bx	lr

00409d54 <__aeabi_uldivmod>:
  409d54:	b953      	cbnz	r3, 409d6c <__aeabi_uldivmod+0x18>
  409d56:	b94a      	cbnz	r2, 409d6c <__aeabi_uldivmod+0x18>
  409d58:	2900      	cmp	r1, #0
  409d5a:	bf08      	it	eq
  409d5c:	2800      	cmpeq	r0, #0
  409d5e:	bf1c      	itt	ne
  409d60:	f04f 31ff 	movne.w	r1, #4294967295
  409d64:	f04f 30ff 	movne.w	r0, #4294967295
  409d68:	f000 b97a 	b.w	40a060 <__aeabi_idiv0>
  409d6c:	f1ad 0c08 	sub.w	ip, sp, #8
  409d70:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  409d74:	f000 f806 	bl	409d84 <__udivmoddi4>
  409d78:	f8dd e004 	ldr.w	lr, [sp, #4]
  409d7c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  409d80:	b004      	add	sp, #16
  409d82:	4770      	bx	lr

00409d84 <__udivmoddi4>:
  409d84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  409d88:	468c      	mov	ip, r1
  409d8a:	460d      	mov	r5, r1
  409d8c:	4604      	mov	r4, r0
  409d8e:	9e08      	ldr	r6, [sp, #32]
  409d90:	2b00      	cmp	r3, #0
  409d92:	d151      	bne.n	409e38 <__udivmoddi4+0xb4>
  409d94:	428a      	cmp	r2, r1
  409d96:	4617      	mov	r7, r2
  409d98:	d96d      	bls.n	409e76 <__udivmoddi4+0xf2>
  409d9a:	fab2 fe82 	clz	lr, r2
  409d9e:	f1be 0f00 	cmp.w	lr, #0
  409da2:	d00b      	beq.n	409dbc <__udivmoddi4+0x38>
  409da4:	f1ce 0c20 	rsb	ip, lr, #32
  409da8:	fa01 f50e 	lsl.w	r5, r1, lr
  409dac:	fa20 fc0c 	lsr.w	ip, r0, ip
  409db0:	fa02 f70e 	lsl.w	r7, r2, lr
  409db4:	ea4c 0c05 	orr.w	ip, ip, r5
  409db8:	fa00 f40e 	lsl.w	r4, r0, lr
  409dbc:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  409dc0:	0c25      	lsrs	r5, r4, #16
  409dc2:	fbbc f8fa 	udiv	r8, ip, sl
  409dc6:	fa1f f987 	uxth.w	r9, r7
  409dca:	fb0a cc18 	mls	ip, sl, r8, ip
  409dce:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  409dd2:	fb08 f309 	mul.w	r3, r8, r9
  409dd6:	42ab      	cmp	r3, r5
  409dd8:	d90a      	bls.n	409df0 <__udivmoddi4+0x6c>
  409dda:	19ed      	adds	r5, r5, r7
  409ddc:	f108 32ff 	add.w	r2, r8, #4294967295
  409de0:	f080 8123 	bcs.w	40a02a <__udivmoddi4+0x2a6>
  409de4:	42ab      	cmp	r3, r5
  409de6:	f240 8120 	bls.w	40a02a <__udivmoddi4+0x2a6>
  409dea:	f1a8 0802 	sub.w	r8, r8, #2
  409dee:	443d      	add	r5, r7
  409df0:	1aed      	subs	r5, r5, r3
  409df2:	b2a4      	uxth	r4, r4
  409df4:	fbb5 f0fa 	udiv	r0, r5, sl
  409df8:	fb0a 5510 	mls	r5, sl, r0, r5
  409dfc:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  409e00:	fb00 f909 	mul.w	r9, r0, r9
  409e04:	45a1      	cmp	r9, r4
  409e06:	d909      	bls.n	409e1c <__udivmoddi4+0x98>
  409e08:	19e4      	adds	r4, r4, r7
  409e0a:	f100 33ff 	add.w	r3, r0, #4294967295
  409e0e:	f080 810a 	bcs.w	40a026 <__udivmoddi4+0x2a2>
  409e12:	45a1      	cmp	r9, r4
  409e14:	f240 8107 	bls.w	40a026 <__udivmoddi4+0x2a2>
  409e18:	3802      	subs	r0, #2
  409e1a:	443c      	add	r4, r7
  409e1c:	eba4 0409 	sub.w	r4, r4, r9
  409e20:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  409e24:	2100      	movs	r1, #0
  409e26:	2e00      	cmp	r6, #0
  409e28:	d061      	beq.n	409eee <__udivmoddi4+0x16a>
  409e2a:	fa24 f40e 	lsr.w	r4, r4, lr
  409e2e:	2300      	movs	r3, #0
  409e30:	6034      	str	r4, [r6, #0]
  409e32:	6073      	str	r3, [r6, #4]
  409e34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409e38:	428b      	cmp	r3, r1
  409e3a:	d907      	bls.n	409e4c <__udivmoddi4+0xc8>
  409e3c:	2e00      	cmp	r6, #0
  409e3e:	d054      	beq.n	409eea <__udivmoddi4+0x166>
  409e40:	2100      	movs	r1, #0
  409e42:	e886 0021 	stmia.w	r6, {r0, r5}
  409e46:	4608      	mov	r0, r1
  409e48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409e4c:	fab3 f183 	clz	r1, r3
  409e50:	2900      	cmp	r1, #0
  409e52:	f040 808e 	bne.w	409f72 <__udivmoddi4+0x1ee>
  409e56:	42ab      	cmp	r3, r5
  409e58:	d302      	bcc.n	409e60 <__udivmoddi4+0xdc>
  409e5a:	4282      	cmp	r2, r0
  409e5c:	f200 80fa 	bhi.w	40a054 <__udivmoddi4+0x2d0>
  409e60:	1a84      	subs	r4, r0, r2
  409e62:	eb65 0503 	sbc.w	r5, r5, r3
  409e66:	2001      	movs	r0, #1
  409e68:	46ac      	mov	ip, r5
  409e6a:	2e00      	cmp	r6, #0
  409e6c:	d03f      	beq.n	409eee <__udivmoddi4+0x16a>
  409e6e:	e886 1010 	stmia.w	r6, {r4, ip}
  409e72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409e76:	b912      	cbnz	r2, 409e7e <__udivmoddi4+0xfa>
  409e78:	2701      	movs	r7, #1
  409e7a:	fbb7 f7f2 	udiv	r7, r7, r2
  409e7e:	fab7 fe87 	clz	lr, r7
  409e82:	f1be 0f00 	cmp.w	lr, #0
  409e86:	d134      	bne.n	409ef2 <__udivmoddi4+0x16e>
  409e88:	1beb      	subs	r3, r5, r7
  409e8a:	0c3a      	lsrs	r2, r7, #16
  409e8c:	fa1f fc87 	uxth.w	ip, r7
  409e90:	2101      	movs	r1, #1
  409e92:	fbb3 f8f2 	udiv	r8, r3, r2
  409e96:	0c25      	lsrs	r5, r4, #16
  409e98:	fb02 3318 	mls	r3, r2, r8, r3
  409e9c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  409ea0:	fb0c f308 	mul.w	r3, ip, r8
  409ea4:	42ab      	cmp	r3, r5
  409ea6:	d907      	bls.n	409eb8 <__udivmoddi4+0x134>
  409ea8:	19ed      	adds	r5, r5, r7
  409eaa:	f108 30ff 	add.w	r0, r8, #4294967295
  409eae:	d202      	bcs.n	409eb6 <__udivmoddi4+0x132>
  409eb0:	42ab      	cmp	r3, r5
  409eb2:	f200 80d1 	bhi.w	40a058 <__udivmoddi4+0x2d4>
  409eb6:	4680      	mov	r8, r0
  409eb8:	1aed      	subs	r5, r5, r3
  409eba:	b2a3      	uxth	r3, r4
  409ebc:	fbb5 f0f2 	udiv	r0, r5, r2
  409ec0:	fb02 5510 	mls	r5, r2, r0, r5
  409ec4:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  409ec8:	fb0c fc00 	mul.w	ip, ip, r0
  409ecc:	45a4      	cmp	ip, r4
  409ece:	d907      	bls.n	409ee0 <__udivmoddi4+0x15c>
  409ed0:	19e4      	adds	r4, r4, r7
  409ed2:	f100 33ff 	add.w	r3, r0, #4294967295
  409ed6:	d202      	bcs.n	409ede <__udivmoddi4+0x15a>
  409ed8:	45a4      	cmp	ip, r4
  409eda:	f200 80b8 	bhi.w	40a04e <__udivmoddi4+0x2ca>
  409ede:	4618      	mov	r0, r3
  409ee0:	eba4 040c 	sub.w	r4, r4, ip
  409ee4:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  409ee8:	e79d      	b.n	409e26 <__udivmoddi4+0xa2>
  409eea:	4631      	mov	r1, r6
  409eec:	4630      	mov	r0, r6
  409eee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409ef2:	f1ce 0420 	rsb	r4, lr, #32
  409ef6:	fa05 f30e 	lsl.w	r3, r5, lr
  409efa:	fa07 f70e 	lsl.w	r7, r7, lr
  409efe:	fa20 f804 	lsr.w	r8, r0, r4
  409f02:	0c3a      	lsrs	r2, r7, #16
  409f04:	fa25 f404 	lsr.w	r4, r5, r4
  409f08:	ea48 0803 	orr.w	r8, r8, r3
  409f0c:	fbb4 f1f2 	udiv	r1, r4, r2
  409f10:	ea4f 4518 	mov.w	r5, r8, lsr #16
  409f14:	fb02 4411 	mls	r4, r2, r1, r4
  409f18:	fa1f fc87 	uxth.w	ip, r7
  409f1c:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  409f20:	fb01 f30c 	mul.w	r3, r1, ip
  409f24:	42ab      	cmp	r3, r5
  409f26:	fa00 f40e 	lsl.w	r4, r0, lr
  409f2a:	d909      	bls.n	409f40 <__udivmoddi4+0x1bc>
  409f2c:	19ed      	adds	r5, r5, r7
  409f2e:	f101 30ff 	add.w	r0, r1, #4294967295
  409f32:	f080 808a 	bcs.w	40a04a <__udivmoddi4+0x2c6>
  409f36:	42ab      	cmp	r3, r5
  409f38:	f240 8087 	bls.w	40a04a <__udivmoddi4+0x2c6>
  409f3c:	3902      	subs	r1, #2
  409f3e:	443d      	add	r5, r7
  409f40:	1aeb      	subs	r3, r5, r3
  409f42:	fa1f f588 	uxth.w	r5, r8
  409f46:	fbb3 f0f2 	udiv	r0, r3, r2
  409f4a:	fb02 3310 	mls	r3, r2, r0, r3
  409f4e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  409f52:	fb00 f30c 	mul.w	r3, r0, ip
  409f56:	42ab      	cmp	r3, r5
  409f58:	d907      	bls.n	409f6a <__udivmoddi4+0x1e6>
  409f5a:	19ed      	adds	r5, r5, r7
  409f5c:	f100 38ff 	add.w	r8, r0, #4294967295
  409f60:	d26f      	bcs.n	40a042 <__udivmoddi4+0x2be>
  409f62:	42ab      	cmp	r3, r5
  409f64:	d96d      	bls.n	40a042 <__udivmoddi4+0x2be>
  409f66:	3802      	subs	r0, #2
  409f68:	443d      	add	r5, r7
  409f6a:	1aeb      	subs	r3, r5, r3
  409f6c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  409f70:	e78f      	b.n	409e92 <__udivmoddi4+0x10e>
  409f72:	f1c1 0720 	rsb	r7, r1, #32
  409f76:	fa22 f807 	lsr.w	r8, r2, r7
  409f7a:	408b      	lsls	r3, r1
  409f7c:	fa05 f401 	lsl.w	r4, r5, r1
  409f80:	ea48 0303 	orr.w	r3, r8, r3
  409f84:	fa20 fe07 	lsr.w	lr, r0, r7
  409f88:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  409f8c:	40fd      	lsrs	r5, r7
  409f8e:	ea4e 0e04 	orr.w	lr, lr, r4
  409f92:	fbb5 f9fc 	udiv	r9, r5, ip
  409f96:	ea4f 441e 	mov.w	r4, lr, lsr #16
  409f9a:	fb0c 5519 	mls	r5, ip, r9, r5
  409f9e:	fa1f f883 	uxth.w	r8, r3
  409fa2:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  409fa6:	fb09 f408 	mul.w	r4, r9, r8
  409faa:	42ac      	cmp	r4, r5
  409fac:	fa02 f201 	lsl.w	r2, r2, r1
  409fb0:	fa00 fa01 	lsl.w	sl, r0, r1
  409fb4:	d908      	bls.n	409fc8 <__udivmoddi4+0x244>
  409fb6:	18ed      	adds	r5, r5, r3
  409fb8:	f109 30ff 	add.w	r0, r9, #4294967295
  409fbc:	d243      	bcs.n	40a046 <__udivmoddi4+0x2c2>
  409fbe:	42ac      	cmp	r4, r5
  409fc0:	d941      	bls.n	40a046 <__udivmoddi4+0x2c2>
  409fc2:	f1a9 0902 	sub.w	r9, r9, #2
  409fc6:	441d      	add	r5, r3
  409fc8:	1b2d      	subs	r5, r5, r4
  409fca:	fa1f fe8e 	uxth.w	lr, lr
  409fce:	fbb5 f0fc 	udiv	r0, r5, ip
  409fd2:	fb0c 5510 	mls	r5, ip, r0, r5
  409fd6:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  409fda:	fb00 f808 	mul.w	r8, r0, r8
  409fde:	45a0      	cmp	r8, r4
  409fe0:	d907      	bls.n	409ff2 <__udivmoddi4+0x26e>
  409fe2:	18e4      	adds	r4, r4, r3
  409fe4:	f100 35ff 	add.w	r5, r0, #4294967295
  409fe8:	d229      	bcs.n	40a03e <__udivmoddi4+0x2ba>
  409fea:	45a0      	cmp	r8, r4
  409fec:	d927      	bls.n	40a03e <__udivmoddi4+0x2ba>
  409fee:	3802      	subs	r0, #2
  409ff0:	441c      	add	r4, r3
  409ff2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  409ff6:	eba4 0408 	sub.w	r4, r4, r8
  409ffa:	fba0 8902 	umull	r8, r9, r0, r2
  409ffe:	454c      	cmp	r4, r9
  40a000:	46c6      	mov	lr, r8
  40a002:	464d      	mov	r5, r9
  40a004:	d315      	bcc.n	40a032 <__udivmoddi4+0x2ae>
  40a006:	d012      	beq.n	40a02e <__udivmoddi4+0x2aa>
  40a008:	b156      	cbz	r6, 40a020 <__udivmoddi4+0x29c>
  40a00a:	ebba 030e 	subs.w	r3, sl, lr
  40a00e:	eb64 0405 	sbc.w	r4, r4, r5
  40a012:	fa04 f707 	lsl.w	r7, r4, r7
  40a016:	40cb      	lsrs	r3, r1
  40a018:	431f      	orrs	r7, r3
  40a01a:	40cc      	lsrs	r4, r1
  40a01c:	6037      	str	r7, [r6, #0]
  40a01e:	6074      	str	r4, [r6, #4]
  40a020:	2100      	movs	r1, #0
  40a022:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a026:	4618      	mov	r0, r3
  40a028:	e6f8      	b.n	409e1c <__udivmoddi4+0x98>
  40a02a:	4690      	mov	r8, r2
  40a02c:	e6e0      	b.n	409df0 <__udivmoddi4+0x6c>
  40a02e:	45c2      	cmp	sl, r8
  40a030:	d2ea      	bcs.n	40a008 <__udivmoddi4+0x284>
  40a032:	ebb8 0e02 	subs.w	lr, r8, r2
  40a036:	eb69 0503 	sbc.w	r5, r9, r3
  40a03a:	3801      	subs	r0, #1
  40a03c:	e7e4      	b.n	40a008 <__udivmoddi4+0x284>
  40a03e:	4628      	mov	r0, r5
  40a040:	e7d7      	b.n	409ff2 <__udivmoddi4+0x26e>
  40a042:	4640      	mov	r0, r8
  40a044:	e791      	b.n	409f6a <__udivmoddi4+0x1e6>
  40a046:	4681      	mov	r9, r0
  40a048:	e7be      	b.n	409fc8 <__udivmoddi4+0x244>
  40a04a:	4601      	mov	r1, r0
  40a04c:	e778      	b.n	409f40 <__udivmoddi4+0x1bc>
  40a04e:	3802      	subs	r0, #2
  40a050:	443c      	add	r4, r7
  40a052:	e745      	b.n	409ee0 <__udivmoddi4+0x15c>
  40a054:	4608      	mov	r0, r1
  40a056:	e708      	b.n	409e6a <__udivmoddi4+0xe6>
  40a058:	f1a8 0802 	sub.w	r8, r8, #2
  40a05c:	443d      	add	r5, r7
  40a05e:	e72b      	b.n	409eb8 <__udivmoddi4+0x134>

0040a060 <__aeabi_idiv0>:
  40a060:	4770      	bx	lr
  40a062:	bf00      	nop

0040a064 <__libc_init_array>:
  40a064:	b570      	push	{r4, r5, r6, lr}
  40a066:	4e0f      	ldr	r6, [pc, #60]	; (40a0a4 <__libc_init_array+0x40>)
  40a068:	4d0f      	ldr	r5, [pc, #60]	; (40a0a8 <__libc_init_array+0x44>)
  40a06a:	1b76      	subs	r6, r6, r5
  40a06c:	10b6      	asrs	r6, r6, #2
  40a06e:	bf18      	it	ne
  40a070:	2400      	movne	r4, #0
  40a072:	d005      	beq.n	40a080 <__libc_init_array+0x1c>
  40a074:	3401      	adds	r4, #1
  40a076:	f855 3b04 	ldr.w	r3, [r5], #4
  40a07a:	4798      	blx	r3
  40a07c:	42a6      	cmp	r6, r4
  40a07e:	d1f9      	bne.n	40a074 <__libc_init_array+0x10>
  40a080:	4e0a      	ldr	r6, [pc, #40]	; (40a0ac <__libc_init_array+0x48>)
  40a082:	4d0b      	ldr	r5, [pc, #44]	; (40a0b0 <__libc_init_array+0x4c>)
  40a084:	1b76      	subs	r6, r6, r5
  40a086:	f000 ff63 	bl	40af50 <_init>
  40a08a:	10b6      	asrs	r6, r6, #2
  40a08c:	bf18      	it	ne
  40a08e:	2400      	movne	r4, #0
  40a090:	d006      	beq.n	40a0a0 <__libc_init_array+0x3c>
  40a092:	3401      	adds	r4, #1
  40a094:	f855 3b04 	ldr.w	r3, [r5], #4
  40a098:	4798      	blx	r3
  40a09a:	42a6      	cmp	r6, r4
  40a09c:	d1f9      	bne.n	40a092 <__libc_init_array+0x2e>
  40a09e:	bd70      	pop	{r4, r5, r6, pc}
  40a0a0:	bd70      	pop	{r4, r5, r6, pc}
  40a0a2:	bf00      	nop
  40a0a4:	0040af5c 	.word	0x0040af5c
  40a0a8:	0040af5c 	.word	0x0040af5c
  40a0ac:	0040af64 	.word	0x0040af64
  40a0b0:	0040af5c 	.word	0x0040af5c

0040a0b4 <malloc>:
  40a0b4:	4b02      	ldr	r3, [pc, #8]	; (40a0c0 <malloc+0xc>)
  40a0b6:	4601      	mov	r1, r0
  40a0b8:	6818      	ldr	r0, [r3, #0]
  40a0ba:	f000 b80b 	b.w	40a0d4 <_malloc_r>
  40a0be:	bf00      	nop
  40a0c0:	200001b0 	.word	0x200001b0

0040a0c4 <free>:
  40a0c4:	4b02      	ldr	r3, [pc, #8]	; (40a0d0 <free+0xc>)
  40a0c6:	4601      	mov	r1, r0
  40a0c8:	6818      	ldr	r0, [r3, #0]
  40a0ca:	f000 bc33 	b.w	40a934 <_free_r>
  40a0ce:	bf00      	nop
  40a0d0:	200001b0 	.word	0x200001b0

0040a0d4 <_malloc_r>:
  40a0d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a0d8:	f101 060b 	add.w	r6, r1, #11
  40a0dc:	2e16      	cmp	r6, #22
  40a0de:	b083      	sub	sp, #12
  40a0e0:	4605      	mov	r5, r0
  40a0e2:	f240 809e 	bls.w	40a222 <_malloc_r+0x14e>
  40a0e6:	f036 0607 	bics.w	r6, r6, #7
  40a0ea:	f100 80bd 	bmi.w	40a268 <_malloc_r+0x194>
  40a0ee:	42b1      	cmp	r1, r6
  40a0f0:	f200 80ba 	bhi.w	40a268 <_malloc_r+0x194>
  40a0f4:	f000 fb86 	bl	40a804 <__malloc_lock>
  40a0f8:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
  40a0fc:	f0c0 8293 	bcc.w	40a626 <_malloc_r+0x552>
  40a100:	0a73      	lsrs	r3, r6, #9
  40a102:	f000 80b8 	beq.w	40a276 <_malloc_r+0x1a2>
  40a106:	2b04      	cmp	r3, #4
  40a108:	f200 8179 	bhi.w	40a3fe <_malloc_r+0x32a>
  40a10c:	09b3      	lsrs	r3, r6, #6
  40a10e:	f103 0039 	add.w	r0, r3, #57	; 0x39
  40a112:	f103 0e38 	add.w	lr, r3, #56	; 0x38
  40a116:	00c3      	lsls	r3, r0, #3
  40a118:	4fbf      	ldr	r7, [pc, #764]	; (40a418 <_malloc_r+0x344>)
  40a11a:	443b      	add	r3, r7
  40a11c:	f1a3 0108 	sub.w	r1, r3, #8
  40a120:	685c      	ldr	r4, [r3, #4]
  40a122:	42a1      	cmp	r1, r4
  40a124:	d106      	bne.n	40a134 <_malloc_r+0x60>
  40a126:	e00c      	b.n	40a142 <_malloc_r+0x6e>
  40a128:	2a00      	cmp	r2, #0
  40a12a:	f280 80aa 	bge.w	40a282 <_malloc_r+0x1ae>
  40a12e:	68e4      	ldr	r4, [r4, #12]
  40a130:	42a1      	cmp	r1, r4
  40a132:	d006      	beq.n	40a142 <_malloc_r+0x6e>
  40a134:	6863      	ldr	r3, [r4, #4]
  40a136:	f023 0303 	bic.w	r3, r3, #3
  40a13a:	1b9a      	subs	r2, r3, r6
  40a13c:	2a0f      	cmp	r2, #15
  40a13e:	ddf3      	ble.n	40a128 <_malloc_r+0x54>
  40a140:	4670      	mov	r0, lr
  40a142:	693c      	ldr	r4, [r7, #16]
  40a144:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 40a42c <_malloc_r+0x358>
  40a148:	4574      	cmp	r4, lr
  40a14a:	f000 81ab 	beq.w	40a4a4 <_malloc_r+0x3d0>
  40a14e:	6863      	ldr	r3, [r4, #4]
  40a150:	f023 0303 	bic.w	r3, r3, #3
  40a154:	1b9a      	subs	r2, r3, r6
  40a156:	2a0f      	cmp	r2, #15
  40a158:	f300 8190 	bgt.w	40a47c <_malloc_r+0x3a8>
  40a15c:	2a00      	cmp	r2, #0
  40a15e:	f8c7 e014 	str.w	lr, [r7, #20]
  40a162:	f8c7 e010 	str.w	lr, [r7, #16]
  40a166:	f280 809d 	bge.w	40a2a4 <_malloc_r+0x1d0>
  40a16a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40a16e:	f080 8161 	bcs.w	40a434 <_malloc_r+0x360>
  40a172:	08db      	lsrs	r3, r3, #3
  40a174:	f103 0c01 	add.w	ip, r3, #1
  40a178:	1099      	asrs	r1, r3, #2
  40a17a:	687a      	ldr	r2, [r7, #4]
  40a17c:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
  40a180:	f8c4 8008 	str.w	r8, [r4, #8]
  40a184:	2301      	movs	r3, #1
  40a186:	408b      	lsls	r3, r1
  40a188:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
  40a18c:	4313      	orrs	r3, r2
  40a18e:	3908      	subs	r1, #8
  40a190:	60e1      	str	r1, [r4, #12]
  40a192:	607b      	str	r3, [r7, #4]
  40a194:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
  40a198:	f8c8 400c 	str.w	r4, [r8, #12]
  40a19c:	1082      	asrs	r2, r0, #2
  40a19e:	2401      	movs	r4, #1
  40a1a0:	4094      	lsls	r4, r2
  40a1a2:	429c      	cmp	r4, r3
  40a1a4:	f200 808b 	bhi.w	40a2be <_malloc_r+0x1ea>
  40a1a8:	421c      	tst	r4, r3
  40a1aa:	d106      	bne.n	40a1ba <_malloc_r+0xe6>
  40a1ac:	f020 0003 	bic.w	r0, r0, #3
  40a1b0:	0064      	lsls	r4, r4, #1
  40a1b2:	421c      	tst	r4, r3
  40a1b4:	f100 0004 	add.w	r0, r0, #4
  40a1b8:	d0fa      	beq.n	40a1b0 <_malloc_r+0xdc>
  40a1ba:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
  40a1be:	46cc      	mov	ip, r9
  40a1c0:	4680      	mov	r8, r0
  40a1c2:	f8dc 300c 	ldr.w	r3, [ip, #12]
  40a1c6:	459c      	cmp	ip, r3
  40a1c8:	d107      	bne.n	40a1da <_malloc_r+0x106>
  40a1ca:	e16d      	b.n	40a4a8 <_malloc_r+0x3d4>
  40a1cc:	2a00      	cmp	r2, #0
  40a1ce:	f280 817b 	bge.w	40a4c8 <_malloc_r+0x3f4>
  40a1d2:	68db      	ldr	r3, [r3, #12]
  40a1d4:	459c      	cmp	ip, r3
  40a1d6:	f000 8167 	beq.w	40a4a8 <_malloc_r+0x3d4>
  40a1da:	6859      	ldr	r1, [r3, #4]
  40a1dc:	f021 0103 	bic.w	r1, r1, #3
  40a1e0:	1b8a      	subs	r2, r1, r6
  40a1e2:	2a0f      	cmp	r2, #15
  40a1e4:	ddf2      	ble.n	40a1cc <_malloc_r+0xf8>
  40a1e6:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  40a1ea:	f8d3 8008 	ldr.w	r8, [r3, #8]
  40a1ee:	9300      	str	r3, [sp, #0]
  40a1f0:	199c      	adds	r4, r3, r6
  40a1f2:	4628      	mov	r0, r5
  40a1f4:	f046 0601 	orr.w	r6, r6, #1
  40a1f8:	f042 0501 	orr.w	r5, r2, #1
  40a1fc:	605e      	str	r6, [r3, #4]
  40a1fe:	f8c8 c00c 	str.w	ip, [r8, #12]
  40a202:	f8cc 8008 	str.w	r8, [ip, #8]
  40a206:	617c      	str	r4, [r7, #20]
  40a208:	613c      	str	r4, [r7, #16]
  40a20a:	f8c4 e00c 	str.w	lr, [r4, #12]
  40a20e:	f8c4 e008 	str.w	lr, [r4, #8]
  40a212:	6065      	str	r5, [r4, #4]
  40a214:	505a      	str	r2, [r3, r1]
  40a216:	f000 fafb 	bl	40a810 <__malloc_unlock>
  40a21a:	9b00      	ldr	r3, [sp, #0]
  40a21c:	f103 0408 	add.w	r4, r3, #8
  40a220:	e01e      	b.n	40a260 <_malloc_r+0x18c>
  40a222:	2910      	cmp	r1, #16
  40a224:	d820      	bhi.n	40a268 <_malloc_r+0x194>
  40a226:	f000 faed 	bl	40a804 <__malloc_lock>
  40a22a:	2610      	movs	r6, #16
  40a22c:	2318      	movs	r3, #24
  40a22e:	2002      	movs	r0, #2
  40a230:	4f79      	ldr	r7, [pc, #484]	; (40a418 <_malloc_r+0x344>)
  40a232:	443b      	add	r3, r7
  40a234:	f1a3 0208 	sub.w	r2, r3, #8
  40a238:	685c      	ldr	r4, [r3, #4]
  40a23a:	4294      	cmp	r4, r2
  40a23c:	f000 813d 	beq.w	40a4ba <_malloc_r+0x3e6>
  40a240:	6863      	ldr	r3, [r4, #4]
  40a242:	68e1      	ldr	r1, [r4, #12]
  40a244:	68a6      	ldr	r6, [r4, #8]
  40a246:	f023 0303 	bic.w	r3, r3, #3
  40a24a:	4423      	add	r3, r4
  40a24c:	4628      	mov	r0, r5
  40a24e:	685a      	ldr	r2, [r3, #4]
  40a250:	60f1      	str	r1, [r6, #12]
  40a252:	f042 0201 	orr.w	r2, r2, #1
  40a256:	608e      	str	r6, [r1, #8]
  40a258:	605a      	str	r2, [r3, #4]
  40a25a:	f000 fad9 	bl	40a810 <__malloc_unlock>
  40a25e:	3408      	adds	r4, #8
  40a260:	4620      	mov	r0, r4
  40a262:	b003      	add	sp, #12
  40a264:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a268:	2400      	movs	r4, #0
  40a26a:	230c      	movs	r3, #12
  40a26c:	4620      	mov	r0, r4
  40a26e:	602b      	str	r3, [r5, #0]
  40a270:	b003      	add	sp, #12
  40a272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a276:	2040      	movs	r0, #64	; 0x40
  40a278:	f44f 7300 	mov.w	r3, #512	; 0x200
  40a27c:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
  40a280:	e74a      	b.n	40a118 <_malloc_r+0x44>
  40a282:	4423      	add	r3, r4
  40a284:	68e1      	ldr	r1, [r4, #12]
  40a286:	685a      	ldr	r2, [r3, #4]
  40a288:	68a6      	ldr	r6, [r4, #8]
  40a28a:	f042 0201 	orr.w	r2, r2, #1
  40a28e:	60f1      	str	r1, [r6, #12]
  40a290:	4628      	mov	r0, r5
  40a292:	608e      	str	r6, [r1, #8]
  40a294:	605a      	str	r2, [r3, #4]
  40a296:	f000 fabb 	bl	40a810 <__malloc_unlock>
  40a29a:	3408      	adds	r4, #8
  40a29c:	4620      	mov	r0, r4
  40a29e:	b003      	add	sp, #12
  40a2a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a2a4:	4423      	add	r3, r4
  40a2a6:	4628      	mov	r0, r5
  40a2a8:	685a      	ldr	r2, [r3, #4]
  40a2aa:	f042 0201 	orr.w	r2, r2, #1
  40a2ae:	605a      	str	r2, [r3, #4]
  40a2b0:	f000 faae 	bl	40a810 <__malloc_unlock>
  40a2b4:	3408      	adds	r4, #8
  40a2b6:	4620      	mov	r0, r4
  40a2b8:	b003      	add	sp, #12
  40a2ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a2be:	68bc      	ldr	r4, [r7, #8]
  40a2c0:	6863      	ldr	r3, [r4, #4]
  40a2c2:	f023 0803 	bic.w	r8, r3, #3
  40a2c6:	45b0      	cmp	r8, r6
  40a2c8:	d304      	bcc.n	40a2d4 <_malloc_r+0x200>
  40a2ca:	eba8 0306 	sub.w	r3, r8, r6
  40a2ce:	2b0f      	cmp	r3, #15
  40a2d0:	f300 8085 	bgt.w	40a3de <_malloc_r+0x30a>
  40a2d4:	f8df 9158 	ldr.w	r9, [pc, #344]	; 40a430 <_malloc_r+0x35c>
  40a2d8:	4b50      	ldr	r3, [pc, #320]	; (40a41c <_malloc_r+0x348>)
  40a2da:	f8d9 2000 	ldr.w	r2, [r9]
  40a2de:	681b      	ldr	r3, [r3, #0]
  40a2e0:	3201      	adds	r2, #1
  40a2e2:	4433      	add	r3, r6
  40a2e4:	eb04 0a08 	add.w	sl, r4, r8
  40a2e8:	f000 8155 	beq.w	40a596 <_malloc_r+0x4c2>
  40a2ec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  40a2f0:	330f      	adds	r3, #15
  40a2f2:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
  40a2f6:	f02b 0b0f 	bic.w	fp, fp, #15
  40a2fa:	4659      	mov	r1, fp
  40a2fc:	4628      	mov	r0, r5
  40a2fe:	f000 fa8d 	bl	40a81c <_sbrk_r>
  40a302:	1c41      	adds	r1, r0, #1
  40a304:	4602      	mov	r2, r0
  40a306:	f000 80fc 	beq.w	40a502 <_malloc_r+0x42e>
  40a30a:	4582      	cmp	sl, r0
  40a30c:	f200 80f7 	bhi.w	40a4fe <_malloc_r+0x42a>
  40a310:	4b43      	ldr	r3, [pc, #268]	; (40a420 <_malloc_r+0x34c>)
  40a312:	6819      	ldr	r1, [r3, #0]
  40a314:	4459      	add	r1, fp
  40a316:	6019      	str	r1, [r3, #0]
  40a318:	f000 814d 	beq.w	40a5b6 <_malloc_r+0x4e2>
  40a31c:	f8d9 0000 	ldr.w	r0, [r9]
  40a320:	3001      	adds	r0, #1
  40a322:	bf1b      	ittet	ne
  40a324:	eba2 0a0a 	subne.w	sl, r2, sl
  40a328:	4451      	addne	r1, sl
  40a32a:	f8c9 2000 	streq.w	r2, [r9]
  40a32e:	6019      	strne	r1, [r3, #0]
  40a330:	f012 0107 	ands.w	r1, r2, #7
  40a334:	f000 8115 	beq.w	40a562 <_malloc_r+0x48e>
  40a338:	f1c1 0008 	rsb	r0, r1, #8
  40a33c:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  40a340:	4402      	add	r2, r0
  40a342:	3108      	adds	r1, #8
  40a344:	eb02 090b 	add.w	r9, r2, fp
  40a348:	f3c9 090b 	ubfx	r9, r9, #0, #12
  40a34c:	eba1 0909 	sub.w	r9, r1, r9
  40a350:	4649      	mov	r1, r9
  40a352:	4628      	mov	r0, r5
  40a354:	9301      	str	r3, [sp, #4]
  40a356:	9200      	str	r2, [sp, #0]
  40a358:	f000 fa60 	bl	40a81c <_sbrk_r>
  40a35c:	1c43      	adds	r3, r0, #1
  40a35e:	e89d 000c 	ldmia.w	sp, {r2, r3}
  40a362:	f000 8143 	beq.w	40a5ec <_malloc_r+0x518>
  40a366:	1a80      	subs	r0, r0, r2
  40a368:	4448      	add	r0, r9
  40a36a:	f040 0001 	orr.w	r0, r0, #1
  40a36e:	6819      	ldr	r1, [r3, #0]
  40a370:	60ba      	str	r2, [r7, #8]
  40a372:	4449      	add	r1, r9
  40a374:	42bc      	cmp	r4, r7
  40a376:	6050      	str	r0, [r2, #4]
  40a378:	6019      	str	r1, [r3, #0]
  40a37a:	d017      	beq.n	40a3ac <_malloc_r+0x2d8>
  40a37c:	f1b8 0f0f 	cmp.w	r8, #15
  40a380:	f240 80fb 	bls.w	40a57a <_malloc_r+0x4a6>
  40a384:	6860      	ldr	r0, [r4, #4]
  40a386:	f1a8 020c 	sub.w	r2, r8, #12
  40a38a:	f022 0207 	bic.w	r2, r2, #7
  40a38e:	eb04 0e02 	add.w	lr, r4, r2
  40a392:	f000 0001 	and.w	r0, r0, #1
  40a396:	f04f 0c05 	mov.w	ip, #5
  40a39a:	4310      	orrs	r0, r2
  40a39c:	2a0f      	cmp	r2, #15
  40a39e:	6060      	str	r0, [r4, #4]
  40a3a0:	f8ce c004 	str.w	ip, [lr, #4]
  40a3a4:	f8ce c008 	str.w	ip, [lr, #8]
  40a3a8:	f200 8117 	bhi.w	40a5da <_malloc_r+0x506>
  40a3ac:	4b1d      	ldr	r3, [pc, #116]	; (40a424 <_malloc_r+0x350>)
  40a3ae:	68bc      	ldr	r4, [r7, #8]
  40a3b0:	681a      	ldr	r2, [r3, #0]
  40a3b2:	4291      	cmp	r1, r2
  40a3b4:	bf88      	it	hi
  40a3b6:	6019      	strhi	r1, [r3, #0]
  40a3b8:	4b1b      	ldr	r3, [pc, #108]	; (40a428 <_malloc_r+0x354>)
  40a3ba:	681a      	ldr	r2, [r3, #0]
  40a3bc:	4291      	cmp	r1, r2
  40a3be:	6862      	ldr	r2, [r4, #4]
  40a3c0:	bf88      	it	hi
  40a3c2:	6019      	strhi	r1, [r3, #0]
  40a3c4:	f022 0203 	bic.w	r2, r2, #3
  40a3c8:	4296      	cmp	r6, r2
  40a3ca:	eba2 0306 	sub.w	r3, r2, r6
  40a3ce:	d801      	bhi.n	40a3d4 <_malloc_r+0x300>
  40a3d0:	2b0f      	cmp	r3, #15
  40a3d2:	dc04      	bgt.n	40a3de <_malloc_r+0x30a>
  40a3d4:	4628      	mov	r0, r5
  40a3d6:	f000 fa1b 	bl	40a810 <__malloc_unlock>
  40a3da:	2400      	movs	r4, #0
  40a3dc:	e740      	b.n	40a260 <_malloc_r+0x18c>
  40a3de:	19a2      	adds	r2, r4, r6
  40a3e0:	f043 0301 	orr.w	r3, r3, #1
  40a3e4:	f046 0601 	orr.w	r6, r6, #1
  40a3e8:	6066      	str	r6, [r4, #4]
  40a3ea:	4628      	mov	r0, r5
  40a3ec:	60ba      	str	r2, [r7, #8]
  40a3ee:	6053      	str	r3, [r2, #4]
  40a3f0:	f000 fa0e 	bl	40a810 <__malloc_unlock>
  40a3f4:	3408      	adds	r4, #8
  40a3f6:	4620      	mov	r0, r4
  40a3f8:	b003      	add	sp, #12
  40a3fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a3fe:	2b14      	cmp	r3, #20
  40a400:	d971      	bls.n	40a4e6 <_malloc_r+0x412>
  40a402:	2b54      	cmp	r3, #84	; 0x54
  40a404:	f200 80a3 	bhi.w	40a54e <_malloc_r+0x47a>
  40a408:	0b33      	lsrs	r3, r6, #12
  40a40a:	f103 006f 	add.w	r0, r3, #111	; 0x6f
  40a40e:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
  40a412:	00c3      	lsls	r3, r0, #3
  40a414:	e680      	b.n	40a118 <_malloc_r+0x44>
  40a416:	bf00      	nop
  40a418:	200005e0 	.word	0x200005e0
  40a41c:	200088b8 	.word	0x200088b8
  40a420:	20008888 	.word	0x20008888
  40a424:	200088b0 	.word	0x200088b0
  40a428:	200088b4 	.word	0x200088b4
  40a42c:	200005e8 	.word	0x200005e8
  40a430:	200009e8 	.word	0x200009e8
  40a434:	0a5a      	lsrs	r2, r3, #9
  40a436:	2a04      	cmp	r2, #4
  40a438:	d95b      	bls.n	40a4f2 <_malloc_r+0x41e>
  40a43a:	2a14      	cmp	r2, #20
  40a43c:	f200 80ae 	bhi.w	40a59c <_malloc_r+0x4c8>
  40a440:	f102 015c 	add.w	r1, r2, #92	; 0x5c
  40a444:	00c9      	lsls	r1, r1, #3
  40a446:	325b      	adds	r2, #91	; 0x5b
  40a448:	eb07 0c01 	add.w	ip, r7, r1
  40a44c:	5879      	ldr	r1, [r7, r1]
  40a44e:	f1ac 0c08 	sub.w	ip, ip, #8
  40a452:	458c      	cmp	ip, r1
  40a454:	f000 8088 	beq.w	40a568 <_malloc_r+0x494>
  40a458:	684a      	ldr	r2, [r1, #4]
  40a45a:	f022 0203 	bic.w	r2, r2, #3
  40a45e:	4293      	cmp	r3, r2
  40a460:	d273      	bcs.n	40a54a <_malloc_r+0x476>
  40a462:	6889      	ldr	r1, [r1, #8]
  40a464:	458c      	cmp	ip, r1
  40a466:	d1f7      	bne.n	40a458 <_malloc_r+0x384>
  40a468:	f8dc 200c 	ldr.w	r2, [ip, #12]
  40a46c:	687b      	ldr	r3, [r7, #4]
  40a46e:	60e2      	str	r2, [r4, #12]
  40a470:	f8c4 c008 	str.w	ip, [r4, #8]
  40a474:	6094      	str	r4, [r2, #8]
  40a476:	f8cc 400c 	str.w	r4, [ip, #12]
  40a47a:	e68f      	b.n	40a19c <_malloc_r+0xc8>
  40a47c:	19a1      	adds	r1, r4, r6
  40a47e:	f046 0c01 	orr.w	ip, r6, #1
  40a482:	f042 0601 	orr.w	r6, r2, #1
  40a486:	f8c4 c004 	str.w	ip, [r4, #4]
  40a48a:	4628      	mov	r0, r5
  40a48c:	6179      	str	r1, [r7, #20]
  40a48e:	6139      	str	r1, [r7, #16]
  40a490:	f8c1 e00c 	str.w	lr, [r1, #12]
  40a494:	f8c1 e008 	str.w	lr, [r1, #8]
  40a498:	604e      	str	r6, [r1, #4]
  40a49a:	50e2      	str	r2, [r4, r3]
  40a49c:	f000 f9b8 	bl	40a810 <__malloc_unlock>
  40a4a0:	3408      	adds	r4, #8
  40a4a2:	e6dd      	b.n	40a260 <_malloc_r+0x18c>
  40a4a4:	687b      	ldr	r3, [r7, #4]
  40a4a6:	e679      	b.n	40a19c <_malloc_r+0xc8>
  40a4a8:	f108 0801 	add.w	r8, r8, #1
  40a4ac:	f018 0f03 	tst.w	r8, #3
  40a4b0:	f10c 0c08 	add.w	ip, ip, #8
  40a4b4:	f47f ae85 	bne.w	40a1c2 <_malloc_r+0xee>
  40a4b8:	e02d      	b.n	40a516 <_malloc_r+0x442>
  40a4ba:	68dc      	ldr	r4, [r3, #12]
  40a4bc:	42a3      	cmp	r3, r4
  40a4be:	bf08      	it	eq
  40a4c0:	3002      	addeq	r0, #2
  40a4c2:	f43f ae3e 	beq.w	40a142 <_malloc_r+0x6e>
  40a4c6:	e6bb      	b.n	40a240 <_malloc_r+0x16c>
  40a4c8:	4419      	add	r1, r3
  40a4ca:	461c      	mov	r4, r3
  40a4cc:	684a      	ldr	r2, [r1, #4]
  40a4ce:	68db      	ldr	r3, [r3, #12]
  40a4d0:	f854 6f08 	ldr.w	r6, [r4, #8]!
  40a4d4:	f042 0201 	orr.w	r2, r2, #1
  40a4d8:	604a      	str	r2, [r1, #4]
  40a4da:	4628      	mov	r0, r5
  40a4dc:	60f3      	str	r3, [r6, #12]
  40a4de:	609e      	str	r6, [r3, #8]
  40a4e0:	f000 f996 	bl	40a810 <__malloc_unlock>
  40a4e4:	e6bc      	b.n	40a260 <_malloc_r+0x18c>
  40a4e6:	f103 005c 	add.w	r0, r3, #92	; 0x5c
  40a4ea:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
  40a4ee:	00c3      	lsls	r3, r0, #3
  40a4f0:	e612      	b.n	40a118 <_malloc_r+0x44>
  40a4f2:	099a      	lsrs	r2, r3, #6
  40a4f4:	f102 0139 	add.w	r1, r2, #57	; 0x39
  40a4f8:	00c9      	lsls	r1, r1, #3
  40a4fa:	3238      	adds	r2, #56	; 0x38
  40a4fc:	e7a4      	b.n	40a448 <_malloc_r+0x374>
  40a4fe:	42bc      	cmp	r4, r7
  40a500:	d054      	beq.n	40a5ac <_malloc_r+0x4d8>
  40a502:	68bc      	ldr	r4, [r7, #8]
  40a504:	6862      	ldr	r2, [r4, #4]
  40a506:	f022 0203 	bic.w	r2, r2, #3
  40a50a:	e75d      	b.n	40a3c8 <_malloc_r+0x2f4>
  40a50c:	f859 3908 	ldr.w	r3, [r9], #-8
  40a510:	4599      	cmp	r9, r3
  40a512:	f040 8086 	bne.w	40a622 <_malloc_r+0x54e>
  40a516:	f010 0f03 	tst.w	r0, #3
  40a51a:	f100 30ff 	add.w	r0, r0, #4294967295
  40a51e:	d1f5      	bne.n	40a50c <_malloc_r+0x438>
  40a520:	687b      	ldr	r3, [r7, #4]
  40a522:	ea23 0304 	bic.w	r3, r3, r4
  40a526:	607b      	str	r3, [r7, #4]
  40a528:	0064      	lsls	r4, r4, #1
  40a52a:	429c      	cmp	r4, r3
  40a52c:	f63f aec7 	bhi.w	40a2be <_malloc_r+0x1ea>
  40a530:	2c00      	cmp	r4, #0
  40a532:	f43f aec4 	beq.w	40a2be <_malloc_r+0x1ea>
  40a536:	421c      	tst	r4, r3
  40a538:	4640      	mov	r0, r8
  40a53a:	f47f ae3e 	bne.w	40a1ba <_malloc_r+0xe6>
  40a53e:	0064      	lsls	r4, r4, #1
  40a540:	421c      	tst	r4, r3
  40a542:	f100 0004 	add.w	r0, r0, #4
  40a546:	d0fa      	beq.n	40a53e <_malloc_r+0x46a>
  40a548:	e637      	b.n	40a1ba <_malloc_r+0xe6>
  40a54a:	468c      	mov	ip, r1
  40a54c:	e78c      	b.n	40a468 <_malloc_r+0x394>
  40a54e:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  40a552:	d815      	bhi.n	40a580 <_malloc_r+0x4ac>
  40a554:	0bf3      	lsrs	r3, r6, #15
  40a556:	f103 0078 	add.w	r0, r3, #120	; 0x78
  40a55a:	f103 0e77 	add.w	lr, r3, #119	; 0x77
  40a55e:	00c3      	lsls	r3, r0, #3
  40a560:	e5da      	b.n	40a118 <_malloc_r+0x44>
  40a562:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  40a566:	e6ed      	b.n	40a344 <_malloc_r+0x270>
  40a568:	687b      	ldr	r3, [r7, #4]
  40a56a:	1092      	asrs	r2, r2, #2
  40a56c:	2101      	movs	r1, #1
  40a56e:	fa01 f202 	lsl.w	r2, r1, r2
  40a572:	4313      	orrs	r3, r2
  40a574:	607b      	str	r3, [r7, #4]
  40a576:	4662      	mov	r2, ip
  40a578:	e779      	b.n	40a46e <_malloc_r+0x39a>
  40a57a:	2301      	movs	r3, #1
  40a57c:	6053      	str	r3, [r2, #4]
  40a57e:	e729      	b.n	40a3d4 <_malloc_r+0x300>
  40a580:	f240 5254 	movw	r2, #1364	; 0x554
  40a584:	4293      	cmp	r3, r2
  40a586:	d822      	bhi.n	40a5ce <_malloc_r+0x4fa>
  40a588:	0cb3      	lsrs	r3, r6, #18
  40a58a:	f103 007d 	add.w	r0, r3, #125	; 0x7d
  40a58e:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
  40a592:	00c3      	lsls	r3, r0, #3
  40a594:	e5c0      	b.n	40a118 <_malloc_r+0x44>
  40a596:	f103 0b10 	add.w	fp, r3, #16
  40a59a:	e6ae      	b.n	40a2fa <_malloc_r+0x226>
  40a59c:	2a54      	cmp	r2, #84	; 0x54
  40a59e:	d829      	bhi.n	40a5f4 <_malloc_r+0x520>
  40a5a0:	0b1a      	lsrs	r2, r3, #12
  40a5a2:	f102 016f 	add.w	r1, r2, #111	; 0x6f
  40a5a6:	00c9      	lsls	r1, r1, #3
  40a5a8:	326e      	adds	r2, #110	; 0x6e
  40a5aa:	e74d      	b.n	40a448 <_malloc_r+0x374>
  40a5ac:	4b20      	ldr	r3, [pc, #128]	; (40a630 <_malloc_r+0x55c>)
  40a5ae:	6819      	ldr	r1, [r3, #0]
  40a5b0:	4459      	add	r1, fp
  40a5b2:	6019      	str	r1, [r3, #0]
  40a5b4:	e6b2      	b.n	40a31c <_malloc_r+0x248>
  40a5b6:	f3ca 000b 	ubfx	r0, sl, #0, #12
  40a5ba:	2800      	cmp	r0, #0
  40a5bc:	f47f aeae 	bne.w	40a31c <_malloc_r+0x248>
  40a5c0:	eb08 030b 	add.w	r3, r8, fp
  40a5c4:	68ba      	ldr	r2, [r7, #8]
  40a5c6:	f043 0301 	orr.w	r3, r3, #1
  40a5ca:	6053      	str	r3, [r2, #4]
  40a5cc:	e6ee      	b.n	40a3ac <_malloc_r+0x2d8>
  40a5ce:	207f      	movs	r0, #127	; 0x7f
  40a5d0:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
  40a5d4:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
  40a5d8:	e59e      	b.n	40a118 <_malloc_r+0x44>
  40a5da:	f104 0108 	add.w	r1, r4, #8
  40a5de:	4628      	mov	r0, r5
  40a5e0:	9300      	str	r3, [sp, #0]
  40a5e2:	f000 f9a7 	bl	40a934 <_free_r>
  40a5e6:	9b00      	ldr	r3, [sp, #0]
  40a5e8:	6819      	ldr	r1, [r3, #0]
  40a5ea:	e6df      	b.n	40a3ac <_malloc_r+0x2d8>
  40a5ec:	2001      	movs	r0, #1
  40a5ee:	f04f 0900 	mov.w	r9, #0
  40a5f2:	e6bc      	b.n	40a36e <_malloc_r+0x29a>
  40a5f4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  40a5f8:	d805      	bhi.n	40a606 <_malloc_r+0x532>
  40a5fa:	0bda      	lsrs	r2, r3, #15
  40a5fc:	f102 0178 	add.w	r1, r2, #120	; 0x78
  40a600:	00c9      	lsls	r1, r1, #3
  40a602:	3277      	adds	r2, #119	; 0x77
  40a604:	e720      	b.n	40a448 <_malloc_r+0x374>
  40a606:	f240 5154 	movw	r1, #1364	; 0x554
  40a60a:	428a      	cmp	r2, r1
  40a60c:	d805      	bhi.n	40a61a <_malloc_r+0x546>
  40a60e:	0c9a      	lsrs	r2, r3, #18
  40a610:	f102 017d 	add.w	r1, r2, #125	; 0x7d
  40a614:	00c9      	lsls	r1, r1, #3
  40a616:	327c      	adds	r2, #124	; 0x7c
  40a618:	e716      	b.n	40a448 <_malloc_r+0x374>
  40a61a:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
  40a61e:	227e      	movs	r2, #126	; 0x7e
  40a620:	e712      	b.n	40a448 <_malloc_r+0x374>
  40a622:	687b      	ldr	r3, [r7, #4]
  40a624:	e780      	b.n	40a528 <_malloc_r+0x454>
  40a626:	08f0      	lsrs	r0, r6, #3
  40a628:	f106 0308 	add.w	r3, r6, #8
  40a62c:	e600      	b.n	40a230 <_malloc_r+0x15c>
  40a62e:	bf00      	nop
  40a630:	20008888 	.word	0x20008888

0040a634 <memcpy>:
  40a634:	4684      	mov	ip, r0
  40a636:	ea41 0300 	orr.w	r3, r1, r0
  40a63a:	f013 0303 	ands.w	r3, r3, #3
  40a63e:	d16d      	bne.n	40a71c <memcpy+0xe8>
  40a640:	3a40      	subs	r2, #64	; 0x40
  40a642:	d341      	bcc.n	40a6c8 <memcpy+0x94>
  40a644:	f851 3b04 	ldr.w	r3, [r1], #4
  40a648:	f840 3b04 	str.w	r3, [r0], #4
  40a64c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a650:	f840 3b04 	str.w	r3, [r0], #4
  40a654:	f851 3b04 	ldr.w	r3, [r1], #4
  40a658:	f840 3b04 	str.w	r3, [r0], #4
  40a65c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a660:	f840 3b04 	str.w	r3, [r0], #4
  40a664:	f851 3b04 	ldr.w	r3, [r1], #4
  40a668:	f840 3b04 	str.w	r3, [r0], #4
  40a66c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a670:	f840 3b04 	str.w	r3, [r0], #4
  40a674:	f851 3b04 	ldr.w	r3, [r1], #4
  40a678:	f840 3b04 	str.w	r3, [r0], #4
  40a67c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a680:	f840 3b04 	str.w	r3, [r0], #4
  40a684:	f851 3b04 	ldr.w	r3, [r1], #4
  40a688:	f840 3b04 	str.w	r3, [r0], #4
  40a68c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a690:	f840 3b04 	str.w	r3, [r0], #4
  40a694:	f851 3b04 	ldr.w	r3, [r1], #4
  40a698:	f840 3b04 	str.w	r3, [r0], #4
  40a69c:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6a0:	f840 3b04 	str.w	r3, [r0], #4
  40a6a4:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6a8:	f840 3b04 	str.w	r3, [r0], #4
  40a6ac:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6b0:	f840 3b04 	str.w	r3, [r0], #4
  40a6b4:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6b8:	f840 3b04 	str.w	r3, [r0], #4
  40a6bc:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6c0:	f840 3b04 	str.w	r3, [r0], #4
  40a6c4:	3a40      	subs	r2, #64	; 0x40
  40a6c6:	d2bd      	bcs.n	40a644 <memcpy+0x10>
  40a6c8:	3230      	adds	r2, #48	; 0x30
  40a6ca:	d311      	bcc.n	40a6f0 <memcpy+0xbc>
  40a6cc:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6d0:	f840 3b04 	str.w	r3, [r0], #4
  40a6d4:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6d8:	f840 3b04 	str.w	r3, [r0], #4
  40a6dc:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6e0:	f840 3b04 	str.w	r3, [r0], #4
  40a6e4:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6e8:	f840 3b04 	str.w	r3, [r0], #4
  40a6ec:	3a10      	subs	r2, #16
  40a6ee:	d2ed      	bcs.n	40a6cc <memcpy+0x98>
  40a6f0:	320c      	adds	r2, #12
  40a6f2:	d305      	bcc.n	40a700 <memcpy+0xcc>
  40a6f4:	f851 3b04 	ldr.w	r3, [r1], #4
  40a6f8:	f840 3b04 	str.w	r3, [r0], #4
  40a6fc:	3a04      	subs	r2, #4
  40a6fe:	d2f9      	bcs.n	40a6f4 <memcpy+0xc0>
  40a700:	3204      	adds	r2, #4
  40a702:	d008      	beq.n	40a716 <memcpy+0xe2>
  40a704:	07d2      	lsls	r2, r2, #31
  40a706:	bf1c      	itt	ne
  40a708:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40a70c:	f800 3b01 	strbne.w	r3, [r0], #1
  40a710:	d301      	bcc.n	40a716 <memcpy+0xe2>
  40a712:	880b      	ldrh	r3, [r1, #0]
  40a714:	8003      	strh	r3, [r0, #0]
  40a716:	4660      	mov	r0, ip
  40a718:	4770      	bx	lr
  40a71a:	bf00      	nop
  40a71c:	2a08      	cmp	r2, #8
  40a71e:	d313      	bcc.n	40a748 <memcpy+0x114>
  40a720:	078b      	lsls	r3, r1, #30
  40a722:	d08d      	beq.n	40a640 <memcpy+0xc>
  40a724:	f010 0303 	ands.w	r3, r0, #3
  40a728:	d08a      	beq.n	40a640 <memcpy+0xc>
  40a72a:	f1c3 0304 	rsb	r3, r3, #4
  40a72e:	1ad2      	subs	r2, r2, r3
  40a730:	07db      	lsls	r3, r3, #31
  40a732:	bf1c      	itt	ne
  40a734:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40a738:	f800 3b01 	strbne.w	r3, [r0], #1
  40a73c:	d380      	bcc.n	40a640 <memcpy+0xc>
  40a73e:	f831 3b02 	ldrh.w	r3, [r1], #2
  40a742:	f820 3b02 	strh.w	r3, [r0], #2
  40a746:	e77b      	b.n	40a640 <memcpy+0xc>
  40a748:	3a04      	subs	r2, #4
  40a74a:	d3d9      	bcc.n	40a700 <memcpy+0xcc>
  40a74c:	3a01      	subs	r2, #1
  40a74e:	f811 3b01 	ldrb.w	r3, [r1], #1
  40a752:	f800 3b01 	strb.w	r3, [r0], #1
  40a756:	d2f9      	bcs.n	40a74c <memcpy+0x118>
  40a758:	780b      	ldrb	r3, [r1, #0]
  40a75a:	7003      	strb	r3, [r0, #0]
  40a75c:	784b      	ldrb	r3, [r1, #1]
  40a75e:	7043      	strb	r3, [r0, #1]
  40a760:	788b      	ldrb	r3, [r1, #2]
  40a762:	7083      	strb	r3, [r0, #2]
  40a764:	4660      	mov	r0, ip
  40a766:	4770      	bx	lr

0040a768 <memset>:
  40a768:	b470      	push	{r4, r5, r6}
  40a76a:	0786      	lsls	r6, r0, #30
  40a76c:	d046      	beq.n	40a7fc <memset+0x94>
  40a76e:	1e54      	subs	r4, r2, #1
  40a770:	2a00      	cmp	r2, #0
  40a772:	d041      	beq.n	40a7f8 <memset+0x90>
  40a774:	b2ca      	uxtb	r2, r1
  40a776:	4603      	mov	r3, r0
  40a778:	e002      	b.n	40a780 <memset+0x18>
  40a77a:	f114 34ff 	adds.w	r4, r4, #4294967295
  40a77e:	d33b      	bcc.n	40a7f8 <memset+0x90>
  40a780:	f803 2b01 	strb.w	r2, [r3], #1
  40a784:	079d      	lsls	r5, r3, #30
  40a786:	d1f8      	bne.n	40a77a <memset+0x12>
  40a788:	2c03      	cmp	r4, #3
  40a78a:	d92e      	bls.n	40a7ea <memset+0x82>
  40a78c:	b2cd      	uxtb	r5, r1
  40a78e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40a792:	2c0f      	cmp	r4, #15
  40a794:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  40a798:	d919      	bls.n	40a7ce <memset+0x66>
  40a79a:	f103 0210 	add.w	r2, r3, #16
  40a79e:	4626      	mov	r6, r4
  40a7a0:	3e10      	subs	r6, #16
  40a7a2:	2e0f      	cmp	r6, #15
  40a7a4:	f842 5c10 	str.w	r5, [r2, #-16]
  40a7a8:	f842 5c0c 	str.w	r5, [r2, #-12]
  40a7ac:	f842 5c08 	str.w	r5, [r2, #-8]
  40a7b0:	f842 5c04 	str.w	r5, [r2, #-4]
  40a7b4:	f102 0210 	add.w	r2, r2, #16
  40a7b8:	d8f2      	bhi.n	40a7a0 <memset+0x38>
  40a7ba:	f1a4 0210 	sub.w	r2, r4, #16
  40a7be:	f022 020f 	bic.w	r2, r2, #15
  40a7c2:	f004 040f 	and.w	r4, r4, #15
  40a7c6:	3210      	adds	r2, #16
  40a7c8:	2c03      	cmp	r4, #3
  40a7ca:	4413      	add	r3, r2
  40a7cc:	d90d      	bls.n	40a7ea <memset+0x82>
  40a7ce:	461e      	mov	r6, r3
  40a7d0:	4622      	mov	r2, r4
  40a7d2:	3a04      	subs	r2, #4
  40a7d4:	2a03      	cmp	r2, #3
  40a7d6:	f846 5b04 	str.w	r5, [r6], #4
  40a7da:	d8fa      	bhi.n	40a7d2 <memset+0x6a>
  40a7dc:	1f22      	subs	r2, r4, #4
  40a7de:	f022 0203 	bic.w	r2, r2, #3
  40a7e2:	3204      	adds	r2, #4
  40a7e4:	4413      	add	r3, r2
  40a7e6:	f004 0403 	and.w	r4, r4, #3
  40a7ea:	b12c      	cbz	r4, 40a7f8 <memset+0x90>
  40a7ec:	b2c9      	uxtb	r1, r1
  40a7ee:	441c      	add	r4, r3
  40a7f0:	f803 1b01 	strb.w	r1, [r3], #1
  40a7f4:	429c      	cmp	r4, r3
  40a7f6:	d1fb      	bne.n	40a7f0 <memset+0x88>
  40a7f8:	bc70      	pop	{r4, r5, r6}
  40a7fa:	4770      	bx	lr
  40a7fc:	4614      	mov	r4, r2
  40a7fe:	4603      	mov	r3, r0
  40a800:	e7c2      	b.n	40a788 <memset+0x20>
  40a802:	bf00      	nop

0040a804 <__malloc_lock>:
  40a804:	4801      	ldr	r0, [pc, #4]	; (40a80c <__malloc_lock+0x8>)
  40a806:	f000 b97b 	b.w	40ab00 <__retarget_lock_acquire_recursive>
  40a80a:	bf00      	nop
  40a80c:	200089b0 	.word	0x200089b0

0040a810 <__malloc_unlock>:
  40a810:	4801      	ldr	r0, [pc, #4]	; (40a818 <__malloc_unlock+0x8>)
  40a812:	f000 b977 	b.w	40ab04 <__retarget_lock_release_recursive>
  40a816:	bf00      	nop
  40a818:	200089b0 	.word	0x200089b0

0040a81c <_sbrk_r>:
  40a81c:	b538      	push	{r3, r4, r5, lr}
  40a81e:	4c07      	ldr	r4, [pc, #28]	; (40a83c <_sbrk_r+0x20>)
  40a820:	2300      	movs	r3, #0
  40a822:	4605      	mov	r5, r0
  40a824:	4608      	mov	r0, r1
  40a826:	6023      	str	r3, [r4, #0]
  40a828:	f7fd ff78 	bl	40871c <_sbrk>
  40a82c:	1c43      	adds	r3, r0, #1
  40a82e:	d000      	beq.n	40a832 <_sbrk_r+0x16>
  40a830:	bd38      	pop	{r3, r4, r5, pc}
  40a832:	6823      	ldr	r3, [r4, #0]
  40a834:	2b00      	cmp	r3, #0
  40a836:	d0fb      	beq.n	40a830 <_sbrk_r+0x14>
  40a838:	602b      	str	r3, [r5, #0]
  40a83a:	bd38      	pop	{r3, r4, r5, pc}
  40a83c:	200089c4 	.word	0x200089c4

0040a840 <register_fini>:
  40a840:	4b02      	ldr	r3, [pc, #8]	; (40a84c <register_fini+0xc>)
  40a842:	b113      	cbz	r3, 40a84a <register_fini+0xa>
  40a844:	4802      	ldr	r0, [pc, #8]	; (40a850 <register_fini+0x10>)
  40a846:	f000 b805 	b.w	40a854 <atexit>
  40a84a:	4770      	bx	lr
  40a84c:	00000000 	.word	0x00000000
  40a850:	0040a861 	.word	0x0040a861

0040a854 <atexit>:
  40a854:	2300      	movs	r3, #0
  40a856:	4601      	mov	r1, r0
  40a858:	461a      	mov	r2, r3
  40a85a:	4618      	mov	r0, r3
  40a85c:	f000 b954 	b.w	40ab08 <__register_exitproc>

0040a860 <__libc_fini_array>:
  40a860:	b538      	push	{r3, r4, r5, lr}
  40a862:	4c0a      	ldr	r4, [pc, #40]	; (40a88c <__libc_fini_array+0x2c>)
  40a864:	4d0a      	ldr	r5, [pc, #40]	; (40a890 <__libc_fini_array+0x30>)
  40a866:	1b64      	subs	r4, r4, r5
  40a868:	10a4      	asrs	r4, r4, #2
  40a86a:	d00a      	beq.n	40a882 <__libc_fini_array+0x22>
  40a86c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  40a870:	3b01      	subs	r3, #1
  40a872:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  40a876:	3c01      	subs	r4, #1
  40a878:	f855 3904 	ldr.w	r3, [r5], #-4
  40a87c:	4798      	blx	r3
  40a87e:	2c00      	cmp	r4, #0
  40a880:	d1f9      	bne.n	40a876 <__libc_fini_array+0x16>
  40a882:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40a886:	f000 bb6d 	b.w	40af64 <_fini>
  40a88a:	bf00      	nop
  40a88c:	0040af74 	.word	0x0040af74
  40a890:	0040af70 	.word	0x0040af70

0040a894 <_malloc_trim_r>:
  40a894:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a896:	4f24      	ldr	r7, [pc, #144]	; (40a928 <_malloc_trim_r+0x94>)
  40a898:	460c      	mov	r4, r1
  40a89a:	4606      	mov	r6, r0
  40a89c:	f7ff ffb2 	bl	40a804 <__malloc_lock>
  40a8a0:	68bb      	ldr	r3, [r7, #8]
  40a8a2:	685d      	ldr	r5, [r3, #4]
  40a8a4:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
  40a8a8:	310f      	adds	r1, #15
  40a8aa:	f025 0503 	bic.w	r5, r5, #3
  40a8ae:	4429      	add	r1, r5
  40a8b0:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  40a8b4:	f021 010f 	bic.w	r1, r1, #15
  40a8b8:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  40a8bc:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  40a8c0:	db07      	blt.n	40a8d2 <_malloc_trim_r+0x3e>
  40a8c2:	2100      	movs	r1, #0
  40a8c4:	4630      	mov	r0, r6
  40a8c6:	f7ff ffa9 	bl	40a81c <_sbrk_r>
  40a8ca:	68bb      	ldr	r3, [r7, #8]
  40a8cc:	442b      	add	r3, r5
  40a8ce:	4298      	cmp	r0, r3
  40a8d0:	d004      	beq.n	40a8dc <_malloc_trim_r+0x48>
  40a8d2:	4630      	mov	r0, r6
  40a8d4:	f7ff ff9c 	bl	40a810 <__malloc_unlock>
  40a8d8:	2000      	movs	r0, #0
  40a8da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a8dc:	4261      	negs	r1, r4
  40a8de:	4630      	mov	r0, r6
  40a8e0:	f7ff ff9c 	bl	40a81c <_sbrk_r>
  40a8e4:	3001      	adds	r0, #1
  40a8e6:	d00d      	beq.n	40a904 <_malloc_trim_r+0x70>
  40a8e8:	4b10      	ldr	r3, [pc, #64]	; (40a92c <_malloc_trim_r+0x98>)
  40a8ea:	68ba      	ldr	r2, [r7, #8]
  40a8ec:	6819      	ldr	r1, [r3, #0]
  40a8ee:	1b2d      	subs	r5, r5, r4
  40a8f0:	f045 0501 	orr.w	r5, r5, #1
  40a8f4:	4630      	mov	r0, r6
  40a8f6:	1b09      	subs	r1, r1, r4
  40a8f8:	6055      	str	r5, [r2, #4]
  40a8fa:	6019      	str	r1, [r3, #0]
  40a8fc:	f7ff ff88 	bl	40a810 <__malloc_unlock>
  40a900:	2001      	movs	r0, #1
  40a902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a904:	2100      	movs	r1, #0
  40a906:	4630      	mov	r0, r6
  40a908:	f7ff ff88 	bl	40a81c <_sbrk_r>
  40a90c:	68ba      	ldr	r2, [r7, #8]
  40a90e:	1a83      	subs	r3, r0, r2
  40a910:	2b0f      	cmp	r3, #15
  40a912:	ddde      	ble.n	40a8d2 <_malloc_trim_r+0x3e>
  40a914:	4c06      	ldr	r4, [pc, #24]	; (40a930 <_malloc_trim_r+0x9c>)
  40a916:	4905      	ldr	r1, [pc, #20]	; (40a92c <_malloc_trim_r+0x98>)
  40a918:	6824      	ldr	r4, [r4, #0]
  40a91a:	f043 0301 	orr.w	r3, r3, #1
  40a91e:	1b00      	subs	r0, r0, r4
  40a920:	6053      	str	r3, [r2, #4]
  40a922:	6008      	str	r0, [r1, #0]
  40a924:	e7d5      	b.n	40a8d2 <_malloc_trim_r+0x3e>
  40a926:	bf00      	nop
  40a928:	200005e0 	.word	0x200005e0
  40a92c:	20008888 	.word	0x20008888
  40a930:	200009e8 	.word	0x200009e8

0040a934 <_free_r>:
  40a934:	2900      	cmp	r1, #0
  40a936:	d044      	beq.n	40a9c2 <_free_r+0x8e>
  40a938:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a93c:	460d      	mov	r5, r1
  40a93e:	4680      	mov	r8, r0
  40a940:	f7ff ff60 	bl	40a804 <__malloc_lock>
  40a944:	f855 7c04 	ldr.w	r7, [r5, #-4]
  40a948:	4969      	ldr	r1, [pc, #420]	; (40aaf0 <_free_r+0x1bc>)
  40a94a:	f027 0301 	bic.w	r3, r7, #1
  40a94e:	f1a5 0408 	sub.w	r4, r5, #8
  40a952:	18e2      	adds	r2, r4, r3
  40a954:	688e      	ldr	r6, [r1, #8]
  40a956:	6850      	ldr	r0, [r2, #4]
  40a958:	42b2      	cmp	r2, r6
  40a95a:	f020 0003 	bic.w	r0, r0, #3
  40a95e:	d05e      	beq.n	40aa1e <_free_r+0xea>
  40a960:	07fe      	lsls	r6, r7, #31
  40a962:	6050      	str	r0, [r2, #4]
  40a964:	d40b      	bmi.n	40a97e <_free_r+0x4a>
  40a966:	f855 7c08 	ldr.w	r7, [r5, #-8]
  40a96a:	1be4      	subs	r4, r4, r7
  40a96c:	f101 0e08 	add.w	lr, r1, #8
  40a970:	68a5      	ldr	r5, [r4, #8]
  40a972:	4575      	cmp	r5, lr
  40a974:	443b      	add	r3, r7
  40a976:	d06d      	beq.n	40aa54 <_free_r+0x120>
  40a978:	68e7      	ldr	r7, [r4, #12]
  40a97a:	60ef      	str	r7, [r5, #12]
  40a97c:	60bd      	str	r5, [r7, #8]
  40a97e:	1815      	adds	r5, r2, r0
  40a980:	686d      	ldr	r5, [r5, #4]
  40a982:	07ed      	lsls	r5, r5, #31
  40a984:	d53e      	bpl.n	40aa04 <_free_r+0xd0>
  40a986:	f043 0201 	orr.w	r2, r3, #1
  40a98a:	6062      	str	r2, [r4, #4]
  40a98c:	50e3      	str	r3, [r4, r3]
  40a98e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40a992:	d217      	bcs.n	40a9c4 <_free_r+0x90>
  40a994:	08db      	lsrs	r3, r3, #3
  40a996:	1c58      	adds	r0, r3, #1
  40a998:	109a      	asrs	r2, r3, #2
  40a99a:	684d      	ldr	r5, [r1, #4]
  40a99c:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
  40a9a0:	60a7      	str	r7, [r4, #8]
  40a9a2:	2301      	movs	r3, #1
  40a9a4:	4093      	lsls	r3, r2
  40a9a6:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
  40a9aa:	432b      	orrs	r3, r5
  40a9ac:	3a08      	subs	r2, #8
  40a9ae:	60e2      	str	r2, [r4, #12]
  40a9b0:	604b      	str	r3, [r1, #4]
  40a9b2:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
  40a9b6:	60fc      	str	r4, [r7, #12]
  40a9b8:	4640      	mov	r0, r8
  40a9ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40a9be:	f7ff bf27 	b.w	40a810 <__malloc_unlock>
  40a9c2:	4770      	bx	lr
  40a9c4:	0a5a      	lsrs	r2, r3, #9
  40a9c6:	2a04      	cmp	r2, #4
  40a9c8:	d852      	bhi.n	40aa70 <_free_r+0x13c>
  40a9ca:	099a      	lsrs	r2, r3, #6
  40a9cc:	f102 0739 	add.w	r7, r2, #57	; 0x39
  40a9d0:	00ff      	lsls	r7, r7, #3
  40a9d2:	f102 0538 	add.w	r5, r2, #56	; 0x38
  40a9d6:	19c8      	adds	r0, r1, r7
  40a9d8:	59ca      	ldr	r2, [r1, r7]
  40a9da:	3808      	subs	r0, #8
  40a9dc:	4290      	cmp	r0, r2
  40a9de:	d04f      	beq.n	40aa80 <_free_r+0x14c>
  40a9e0:	6851      	ldr	r1, [r2, #4]
  40a9e2:	f021 0103 	bic.w	r1, r1, #3
  40a9e6:	428b      	cmp	r3, r1
  40a9e8:	d232      	bcs.n	40aa50 <_free_r+0x11c>
  40a9ea:	6892      	ldr	r2, [r2, #8]
  40a9ec:	4290      	cmp	r0, r2
  40a9ee:	d1f7      	bne.n	40a9e0 <_free_r+0xac>
  40a9f0:	68c3      	ldr	r3, [r0, #12]
  40a9f2:	60a0      	str	r0, [r4, #8]
  40a9f4:	60e3      	str	r3, [r4, #12]
  40a9f6:	609c      	str	r4, [r3, #8]
  40a9f8:	60c4      	str	r4, [r0, #12]
  40a9fa:	4640      	mov	r0, r8
  40a9fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40aa00:	f7ff bf06 	b.w	40a810 <__malloc_unlock>
  40aa04:	6895      	ldr	r5, [r2, #8]
  40aa06:	4f3b      	ldr	r7, [pc, #236]	; (40aaf4 <_free_r+0x1c0>)
  40aa08:	42bd      	cmp	r5, r7
  40aa0a:	4403      	add	r3, r0
  40aa0c:	d040      	beq.n	40aa90 <_free_r+0x15c>
  40aa0e:	68d0      	ldr	r0, [r2, #12]
  40aa10:	60e8      	str	r0, [r5, #12]
  40aa12:	f043 0201 	orr.w	r2, r3, #1
  40aa16:	6085      	str	r5, [r0, #8]
  40aa18:	6062      	str	r2, [r4, #4]
  40aa1a:	50e3      	str	r3, [r4, r3]
  40aa1c:	e7b7      	b.n	40a98e <_free_r+0x5a>
  40aa1e:	07ff      	lsls	r7, r7, #31
  40aa20:	4403      	add	r3, r0
  40aa22:	d407      	bmi.n	40aa34 <_free_r+0x100>
  40aa24:	f855 2c08 	ldr.w	r2, [r5, #-8]
  40aa28:	1aa4      	subs	r4, r4, r2
  40aa2a:	4413      	add	r3, r2
  40aa2c:	68a0      	ldr	r0, [r4, #8]
  40aa2e:	68e2      	ldr	r2, [r4, #12]
  40aa30:	60c2      	str	r2, [r0, #12]
  40aa32:	6090      	str	r0, [r2, #8]
  40aa34:	4a30      	ldr	r2, [pc, #192]	; (40aaf8 <_free_r+0x1c4>)
  40aa36:	6812      	ldr	r2, [r2, #0]
  40aa38:	f043 0001 	orr.w	r0, r3, #1
  40aa3c:	4293      	cmp	r3, r2
  40aa3e:	6060      	str	r0, [r4, #4]
  40aa40:	608c      	str	r4, [r1, #8]
  40aa42:	d3b9      	bcc.n	40a9b8 <_free_r+0x84>
  40aa44:	4b2d      	ldr	r3, [pc, #180]	; (40aafc <_free_r+0x1c8>)
  40aa46:	4640      	mov	r0, r8
  40aa48:	6819      	ldr	r1, [r3, #0]
  40aa4a:	f7ff ff23 	bl	40a894 <_malloc_trim_r>
  40aa4e:	e7b3      	b.n	40a9b8 <_free_r+0x84>
  40aa50:	4610      	mov	r0, r2
  40aa52:	e7cd      	b.n	40a9f0 <_free_r+0xbc>
  40aa54:	1811      	adds	r1, r2, r0
  40aa56:	6849      	ldr	r1, [r1, #4]
  40aa58:	07c9      	lsls	r1, r1, #31
  40aa5a:	d444      	bmi.n	40aae6 <_free_r+0x1b2>
  40aa5c:	6891      	ldr	r1, [r2, #8]
  40aa5e:	68d2      	ldr	r2, [r2, #12]
  40aa60:	60ca      	str	r2, [r1, #12]
  40aa62:	4403      	add	r3, r0
  40aa64:	f043 0001 	orr.w	r0, r3, #1
  40aa68:	6091      	str	r1, [r2, #8]
  40aa6a:	6060      	str	r0, [r4, #4]
  40aa6c:	50e3      	str	r3, [r4, r3]
  40aa6e:	e7a3      	b.n	40a9b8 <_free_r+0x84>
  40aa70:	2a14      	cmp	r2, #20
  40aa72:	d816      	bhi.n	40aaa2 <_free_r+0x16e>
  40aa74:	f102 075c 	add.w	r7, r2, #92	; 0x5c
  40aa78:	00ff      	lsls	r7, r7, #3
  40aa7a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
  40aa7e:	e7aa      	b.n	40a9d6 <_free_r+0xa2>
  40aa80:	10aa      	asrs	r2, r5, #2
  40aa82:	2301      	movs	r3, #1
  40aa84:	684d      	ldr	r5, [r1, #4]
  40aa86:	4093      	lsls	r3, r2
  40aa88:	432b      	orrs	r3, r5
  40aa8a:	604b      	str	r3, [r1, #4]
  40aa8c:	4603      	mov	r3, r0
  40aa8e:	e7b0      	b.n	40a9f2 <_free_r+0xbe>
  40aa90:	f043 0201 	orr.w	r2, r3, #1
  40aa94:	614c      	str	r4, [r1, #20]
  40aa96:	610c      	str	r4, [r1, #16]
  40aa98:	60e5      	str	r5, [r4, #12]
  40aa9a:	60a5      	str	r5, [r4, #8]
  40aa9c:	6062      	str	r2, [r4, #4]
  40aa9e:	50e3      	str	r3, [r4, r3]
  40aaa0:	e78a      	b.n	40a9b8 <_free_r+0x84>
  40aaa2:	2a54      	cmp	r2, #84	; 0x54
  40aaa4:	d806      	bhi.n	40aab4 <_free_r+0x180>
  40aaa6:	0b1a      	lsrs	r2, r3, #12
  40aaa8:	f102 076f 	add.w	r7, r2, #111	; 0x6f
  40aaac:	00ff      	lsls	r7, r7, #3
  40aaae:	f102 056e 	add.w	r5, r2, #110	; 0x6e
  40aab2:	e790      	b.n	40a9d6 <_free_r+0xa2>
  40aab4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  40aab8:	d806      	bhi.n	40aac8 <_free_r+0x194>
  40aaba:	0bda      	lsrs	r2, r3, #15
  40aabc:	f102 0778 	add.w	r7, r2, #120	; 0x78
  40aac0:	00ff      	lsls	r7, r7, #3
  40aac2:	f102 0577 	add.w	r5, r2, #119	; 0x77
  40aac6:	e786      	b.n	40a9d6 <_free_r+0xa2>
  40aac8:	f240 5054 	movw	r0, #1364	; 0x554
  40aacc:	4282      	cmp	r2, r0
  40aace:	d806      	bhi.n	40aade <_free_r+0x1aa>
  40aad0:	0c9a      	lsrs	r2, r3, #18
  40aad2:	f102 077d 	add.w	r7, r2, #125	; 0x7d
  40aad6:	00ff      	lsls	r7, r7, #3
  40aad8:	f102 057c 	add.w	r5, r2, #124	; 0x7c
  40aadc:	e77b      	b.n	40a9d6 <_free_r+0xa2>
  40aade:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
  40aae2:	257e      	movs	r5, #126	; 0x7e
  40aae4:	e777      	b.n	40a9d6 <_free_r+0xa2>
  40aae6:	f043 0101 	orr.w	r1, r3, #1
  40aaea:	6061      	str	r1, [r4, #4]
  40aaec:	6013      	str	r3, [r2, #0]
  40aaee:	e763      	b.n	40a9b8 <_free_r+0x84>
  40aaf0:	200005e0 	.word	0x200005e0
  40aaf4:	200005e8 	.word	0x200005e8
  40aaf8:	200009ec 	.word	0x200009ec
  40aafc:	200088b8 	.word	0x200088b8

0040ab00 <__retarget_lock_acquire_recursive>:
  40ab00:	4770      	bx	lr
  40ab02:	bf00      	nop

0040ab04 <__retarget_lock_release_recursive>:
  40ab04:	4770      	bx	lr
  40ab06:	bf00      	nop

0040ab08 <__register_exitproc>:
  40ab08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40ab0c:	4d2c      	ldr	r5, [pc, #176]	; (40abc0 <__register_exitproc+0xb8>)
  40ab0e:	4606      	mov	r6, r0
  40ab10:	6828      	ldr	r0, [r5, #0]
  40ab12:	4698      	mov	r8, r3
  40ab14:	460f      	mov	r7, r1
  40ab16:	4691      	mov	r9, r2
  40ab18:	f7ff fff2 	bl	40ab00 <__retarget_lock_acquire_recursive>
  40ab1c:	4b29      	ldr	r3, [pc, #164]	; (40abc4 <__register_exitproc+0xbc>)
  40ab1e:	681c      	ldr	r4, [r3, #0]
  40ab20:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  40ab24:	2b00      	cmp	r3, #0
  40ab26:	d03e      	beq.n	40aba6 <__register_exitproc+0x9e>
  40ab28:	685a      	ldr	r2, [r3, #4]
  40ab2a:	2a1f      	cmp	r2, #31
  40ab2c:	dc1c      	bgt.n	40ab68 <__register_exitproc+0x60>
  40ab2e:	f102 0e01 	add.w	lr, r2, #1
  40ab32:	b176      	cbz	r6, 40ab52 <__register_exitproc+0x4a>
  40ab34:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  40ab38:	2401      	movs	r4, #1
  40ab3a:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  40ab3e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  40ab42:	4094      	lsls	r4, r2
  40ab44:	4320      	orrs	r0, r4
  40ab46:	2e02      	cmp	r6, #2
  40ab48:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  40ab4c:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  40ab50:	d023      	beq.n	40ab9a <__register_exitproc+0x92>
  40ab52:	3202      	adds	r2, #2
  40ab54:	f8c3 e004 	str.w	lr, [r3, #4]
  40ab58:	6828      	ldr	r0, [r5, #0]
  40ab5a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  40ab5e:	f7ff ffd1 	bl	40ab04 <__retarget_lock_release_recursive>
  40ab62:	2000      	movs	r0, #0
  40ab64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40ab68:	4b17      	ldr	r3, [pc, #92]	; (40abc8 <__register_exitproc+0xc0>)
  40ab6a:	b30b      	cbz	r3, 40abb0 <__register_exitproc+0xa8>
  40ab6c:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40ab70:	f7ff faa0 	bl	40a0b4 <malloc>
  40ab74:	4603      	mov	r3, r0
  40ab76:	b1d8      	cbz	r0, 40abb0 <__register_exitproc+0xa8>
  40ab78:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  40ab7c:	6002      	str	r2, [r0, #0]
  40ab7e:	2100      	movs	r1, #0
  40ab80:	6041      	str	r1, [r0, #4]
  40ab82:	460a      	mov	r2, r1
  40ab84:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  40ab88:	f04f 0e01 	mov.w	lr, #1
  40ab8c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  40ab90:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  40ab94:	2e00      	cmp	r6, #0
  40ab96:	d0dc      	beq.n	40ab52 <__register_exitproc+0x4a>
  40ab98:	e7cc      	b.n	40ab34 <__register_exitproc+0x2c>
  40ab9a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  40ab9e:	430c      	orrs	r4, r1
  40aba0:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  40aba4:	e7d5      	b.n	40ab52 <__register_exitproc+0x4a>
  40aba6:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  40abaa:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  40abae:	e7bb      	b.n	40ab28 <__register_exitproc+0x20>
  40abb0:	6828      	ldr	r0, [r5, #0]
  40abb2:	f7ff ffa7 	bl	40ab04 <__retarget_lock_release_recursive>
  40abb6:	f04f 30ff 	mov.w	r0, #4294967295
  40abba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40abbe:	bf00      	nop
  40abc0:	200009f0 	.word	0x200009f0
  40abc4:	0040af4c 	.word	0x0040af4c
  40abc8:	0040a0b5 	.word	0x0040a0b5
  40abcc:	bd070002 	.word	0xbd070002
	...
  40abd8:	be020002 	.word	0xbe020002
  40abdc:	00000001 	.word	0x00000001
  40abe0:	bf020002 	.word	0xbf020002
  40abe4:	00000001 	.word	0x00000001

0040abe8 <can_bit_time>:
  40abe8:	02020308 02094b03 43020303 0303030a     .....K.....C....
  40abf8:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  40ac08:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  40ac18:	05050510 06114504 47040505 06060512     .....E.....G....
  40ac28:	06134304 44040606 06060714 08154604     .C.....D.....F..
  40ac38:	47040606 07070716 08174404 46040708     ...G.....D.....F
  40ac48:	08080718 08194304 44040808 e0070002     .....C.....D....
  40ac58:	0b1a01ef 00001112 74737953 4d206d65     ........System M
  40ac68:	2e65646f 50562e2e 00000057 74737953     ode...VPW...Syst
  40ac78:	4d206d65 2e65646f 53482e2e 004e4143     em Mode...HSCAN.
  40ac88:	74737953 4d206d65 2e65646f 4f4e2e2e     System Mode...NO
  40ac98:	0000454e c4020002 00000001 746c6946     NE..........Filt
  40aca8:	6e697265 69442067 6c626173 00216465     ering Disabled!.
  40acb8:	6e6e7552 20676e69 746c6946 00217265     Running Filter!.
  40acc8:	b0020002 00000001 b1020002 00000001     ................
  40acd8:	636c6557 20656d6f 654b202d 72656c70     Welcome - Kepler
  40ace8:	62654420 43206775 6f736e6f 2d20656c      Debug Console -
  40acf8:	2e315620 00000030 72616f42 6e492064      V1.0...Board In
  40ad08:	61697469 617a696c 6e6f6974 4f2e2e2e     itialization...O
  40ad18:	0000004b 74737953 43206d65 69666e6f     K...System Confi
  40ad28:	61727567 6e6f6974 4f2e2e2e 0000004b     guration...OK...
  40ad38:	74737953 2e2e6d65 4e55522e 474e494e     System...RUNNING
  40ad48:	00000000 62616e55 7420656c 6573206f     ....Unable to se
  40ad58:	43502074 6e692049 4e414320 74616420     t PCI in CAN dat
  40ad68:	00000061 62616e55 7420656c 6573206f     a...Unable to se
  40ad78:	61702074 616f6c79 656c2064 6874676e     t payload length
  40ad88:	206e6920 204e4143 61746164 00000000      in CAN data....
  40ad98:	62616e55 7420656c 6573206f 43502074     Unable to set PC
  40ada8:	6e692049 72696620 66207473 656d6172     I in first frame
  40adb8:	4e414320 74616420 00000061 72617453      CAN data...Star
  40adc8:	754d2074 6669746c 656d6172 6e655320     t Multiframe Sen
  40add8:	72502064 6465636f 2e657275 2e202e20     d Procedure. . .
  40ade8:	00000000 746e6553 72694620 46207473     ....Sent First F
  40adf8:	656d6172 00000000 74696157 20676e69     rame....Waiting 
  40ae08:	20726f66 202e4346 72617453 676e6974     for FC. Starting
  40ae18:	6d697420 74756f65 6d697420 00217265      timeout timer!.
  40ae28:	74696157 20676e69 6954202d 756f656d     Waiting - Timeou
  40ae38:	69742074 2072656d 6e6e7572 2e676e69     t timer running.
  40ae48:	00002e2e 746e6553 6e6f6320 75636573     ....Sent consecu
  40ae58:	65766974 61726620 7720656d 20687469     tive frame with 
  40ae68:	20716573 203a6469 00000000 746e6553     seq id: ....Sent
  40ae78:	6c756620 6c62206c 206b636f 72206f74      full block to r
  40ae88:	746f6d65 77202c65 69746961 6620676e     emote, waiting f
  40ae98:	6e20726f 20747865 776f6c66 6e6f6320     or next flow con
  40aea8:	6c6f7274 61726620 0000656d 646e6553     trol frame..Send
  40aeb8:	20676e69 7473616c 61726620 7720656d     ing last frame w
  40aec8:	20687469 20716573 203a6469 00000000     ith seq id: ....
  40aed8:	62616e55 7420656c 6573206f 43502074     Unable to set PC
  40aee8:	6e692049 63657320 20646e6f 6d617266     I in second fram
  40aef8:	41432065 6164204e 00006174 62616e55     e CAN data..Unab
  40af08:	7420656c 6573206f 65732074 646e6f63     le to set second
  40af18:	61726620 6e20656d 65626d75 6e692072      frame number in
  40af28:	4e414320 74616420 00000061               CAN data...

0040af34 <reverse_mask>:
  40af34:	e0c08055 fefcf8f0 000000ff              U...........

0040af40 <reverse_mask_xor>:
  40af40:	1f3f7fff 0103070f 00000000              ..?.........

0040af4c <_global_impure_ptr>:
  40af4c:	200001b8                                ... 

0040af50 <_init>:
  40af50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40af52:	bf00      	nop
  40af54:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40af56:	bc08      	pop	{r3}
  40af58:	469e      	mov	lr, r3
  40af5a:	4770      	bx	lr

0040af5c <__init_array_start>:
  40af5c:	0040a841 	.word	0x0040a841

0040af60 <__frame_dummy_init_array_entry>:
  40af60:	0040011d                                ..@.

0040af64 <_fini>:
  40af64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40af66:	bf00      	nop
  40af68:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40af6a:	bc08      	pop	{r3}
  40af6c:	469e      	mov	lr, r3
  40af6e:	4770      	bx	lr

0040af70 <__fini_array_start>:
  40af70:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
2000000a:	b480      	push	{r7}
2000000c:	b089      	sub	sp, #36	; 0x24
2000000e:	af00      	add	r7, sp, #0
20000010:	60f8      	str	r0, [r7, #12]
20000012:	60b9      	str	r1, [r7, #8]
20000014:	607a      	str	r2, [r7, #4]
20000016:	603b      	str	r3, [r7, #0]
	uint32_t *p_ul_data =
			(uint32_t *) ((p_efc == EFC0) ?
			READ_BUFF_ADDR0 : READ_BUFF_ADDR1);
#elif (SAM3S || SAM4S || SAM3N || SAM3U || SAM4E || SAM4N || SAM4C || SAMG || \
	   SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAMS70 || SAME70)
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
20000018:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000001c:	61bb      	str	r3, [r7, #24]
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
2000001e:	683b      	ldr	r3, [r7, #0]
20000020:	2b00      	cmp	r3, #0
20000022:	d101      	bne.n	20000028 <efc_perform_read_sequence+0x1e>
		return EFC_RC_INVALID;
20000024:	2302      	movs	r3, #2
20000026:	e03c      	b.n	200000a2 <efc_perform_read_sequence+0x98>
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000028:	68fb      	ldr	r3, [r7, #12]
2000002a:	681b      	ldr	r3, [r3, #0]
2000002c:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
20000030:	68fb      	ldr	r3, [r7, #12]
20000032:	601a      	str	r2, [r3, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
20000034:	68bb      	ldr	r3, [r7, #8]
20000036:	b2db      	uxtb	r3, r3
20000038:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
2000003c:	68fb      	ldr	r3, [r7, #12]
2000003e:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	68fb      	ldr	r3, [r7, #12]
20000042:	689b      	ldr	r3, [r3, #8]
20000044:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
20000046:	697b      	ldr	r3, [r7, #20]
20000048:	f003 0301 	and.w	r3, r3, #1
2000004c:	2b01      	cmp	r3, #1
2000004e:	d0f7      	beq.n	20000040 <efc_perform_read_sequence+0x36>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000050:	2300      	movs	r3, #0
20000052:	61fb      	str	r3, [r7, #28]
20000054:	e00c      	b.n	20000070 <efc_perform_read_sequence+0x66>
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
20000056:	69fb      	ldr	r3, [r7, #28]
20000058:	009b      	lsls	r3, r3, #2
2000005a:	683a      	ldr	r2, [r7, #0]
2000005c:	4413      	add	r3, r2
2000005e:	69fa      	ldr	r2, [r7, #28]
20000060:	0092      	lsls	r2, r2, #2
20000062:	69b9      	ldr	r1, [r7, #24]
20000064:	440a      	add	r2, r1
20000066:	6812      	ldr	r2, [r2, #0]
20000068:	601a      	str	r2, [r3, #0]
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
2000006a:	69fb      	ldr	r3, [r7, #28]
2000006c:	3301      	adds	r3, #1
2000006e:	61fb      	str	r3, [r7, #28]
20000070:	69fa      	ldr	r2, [r7, #28]
20000072:	6abb      	ldr	r3, [r7, #40]	; 0x28
20000074:	429a      	cmp	r2, r3
20000076:	d3ee      	bcc.n	20000056 <efc_perform_read_sequence+0x4c>
	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000078:	687b      	ldr	r3, [r7, #4]
2000007a:	b2db      	uxtb	r3, r3
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000007c:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR =
20000080:	68fb      	ldr	r3, [r7, #12]
20000082:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000084:	68fb      	ldr	r3, [r7, #12]
20000086:	689b      	ldr	r3, [r3, #8]
20000088:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
2000008a:	697b      	ldr	r3, [r7, #20]
2000008c:	f003 0301 	and.w	r3, r3, #1
20000090:	2b01      	cmp	r3, #1
20000092:	d1f7      	bne.n	20000084 <efc_perform_read_sequence+0x7a>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
20000094:	68fb      	ldr	r3, [r7, #12]
20000096:	681b      	ldr	r3, [r3, #0]
20000098:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2000009c:	68fb      	ldr	r3, [r7, #12]
2000009e:	601a      	str	r2, [r3, #0]

	return EFC_RC_OK;
200000a0:	2300      	movs	r3, #0
}
200000a2:	4618      	mov	r0, r3
200000a4:	3724      	adds	r7, #36	; 0x24
200000a6:	46bd      	mov	sp, r7
200000a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200000ac:	4770      	bx	lr

200000ae <efc_write_fmr>:
 * \param ul_fmr Value of mode register
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
200000ae:	b480      	push	{r7}
200000b0:	b083      	sub	sp, #12
200000b2:	af00      	add	r7, sp, #0
200000b4:	6078      	str	r0, [r7, #4]
200000b6:	6039      	str	r1, [r7, #0]
	p_efc->EEFC_FMR = ul_fmr;
200000b8:	687b      	ldr	r3, [r7, #4]
200000ba:	683a      	ldr	r2, [r7, #0]
200000bc:	601a      	str	r2, [r3, #0]
}
200000be:	bf00      	nop
200000c0:	370c      	adds	r7, #12
200000c2:	46bd      	mov	sp, r7
200000c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200000c8:	4770      	bx	lr

200000ca <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
200000ca:	b480      	push	{r7}
200000cc:	b085      	sub	sp, #20
200000ce:	af00      	add	r7, sp, #0
200000d0:	6078      	str	r0, [r7, #4]
200000d2:	6039      	str	r1, [r7, #0]
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
200000d4:	687b      	ldr	r3, [r7, #4]
200000d6:	683a      	ldr	r2, [r7, #0]
200000d8:	605a      	str	r2, [r3, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
200000da:	687b      	ldr	r3, [r7, #4]
200000dc:	689b      	ldr	r3, [r3, #8]
200000de:	60fb      	str	r3, [r7, #12]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
200000e0:	68fb      	ldr	r3, [r7, #12]
200000e2:	f003 0301 	and.w	r3, r3, #1
200000e6:	2b01      	cmp	r3, #1
200000e8:	d1f7      	bne.n	200000da <efc_perform_fcr+0x10>

	return (ul_status & EEFC_ERROR_FLAGS);
200000ea:	68fb      	ldr	r3, [r7, #12]
200000ec:	f003 030e 	and.w	r3, r3, #14
}
200000f0:	4618      	mov	r0, r3
200000f2:	3714      	adds	r7, #20
200000f4:	46bd      	mov	sp, r7
200000f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200000fa:	4770      	bx	lr

200000fc <udc_device_desc>:
200000fc:	0112 0200 0002 4000 03eb 2404 0100 0000     .......@...$....
2000010c:	0100 0000                                   ....

20000110 <udc_desc_fs>:
20000110:	0209 0043 0102 c000 09fa 0004 0100 0202     ..C.............
20000120:	0001 2405 1000 0401 0224 0502 0624 0100     ...$....$...$...
20000130:	2405 0301 0701 8305 4003 1000 0409 0001     .$.......@......
20000140:	0a02 0000 0700 8105 4002 0000 0507 0202     .........@......
20000150:	0040 0000                                   @...

20000154 <udi_apis>:
20000154:	017c 2000 0190 2000                         |.. ... 

2000015c <udc_config_fs>:
2000015c:	0110 2000 0154 2000                         ... T.. 

20000164 <udc_config>:
20000164:	00fc 2000 015c 2000 0000 0000               ... \.. ....

20000170 <FilterCounter>:
20000170:	0001 0000                                   ....

20000174 <rx_mailbox_num>:
20000174:	0001 0000                                   ....

20000178 <PulseWidthDivisor>:
20000178:	0001 0000                                   ....

2000017c <udi_api_cdc_comm>:
2000017c:	382d 0040 3a4d 0040 3aa1 0040 3b71 0040     -8@.M:@..:@.q;@.
2000018c:	0000 0000                                   ....

20000190 <udi_api_cdc_data>:
20000190:	3959 0040 3a6d 0040 3b61 0040 3b71 0040     Y9@.m:@.a;@.q;@.
200001a0:	3b81 0040                                   .;@.

200001a4 <udc_string_desc_languageid>:
200001a4:	0304 0409                                   ....

200001a8 <udc_string_desc>:
200001a8:	0300                                        ..

200001aa <g_interrupt_enabled>:
200001aa:	0001                                        ..

200001ac <SystemCoreClock>:
200001ac:	0900 003d                                   ..=.

200001b0 <_impure_ptr>:
200001b0:	01b8 2000 0000 0000                         ... ....

200001b8 <impure_data>:
200001b8:	0000 0000 04a4 2000 050c 2000 0574 2000     ....... ... t.. 
	...
20000260:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000270:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

200005e0 <__malloc_av_>:
	...
200005e8:	05e0 2000 05e0 2000 05e8 2000 05e8 2000     ... ... ... ... 
200005f8:	05f0 2000 05f0 2000 05f8 2000 05f8 2000     ... ... ... ... 
20000608:	0600 2000 0600 2000 0608 2000 0608 2000     ... ... ... ... 
20000618:	0610 2000 0610 2000 0618 2000 0618 2000     ... ... ... ... 
20000628:	0620 2000 0620 2000 0628 2000 0628 2000      ..  .. (.. (.. 
20000638:	0630 2000 0630 2000 0638 2000 0638 2000     0.. 0.. 8.. 8.. 
20000648:	0640 2000 0640 2000 0648 2000 0648 2000     @.. @.. H.. H.. 
20000658:	0650 2000 0650 2000 0658 2000 0658 2000     P.. P.. X.. X.. 
20000668:	0660 2000 0660 2000 0668 2000 0668 2000     `.. `.. h.. h.. 
20000678:	0670 2000 0670 2000 0678 2000 0678 2000     p.. p.. x.. x.. 
20000688:	0680 2000 0680 2000 0688 2000 0688 2000     ... ... ... ... 
20000698:	0690 2000 0690 2000 0698 2000 0698 2000     ... ... ... ... 
200006a8:	06a0 2000 06a0 2000 06a8 2000 06a8 2000     ... ... ... ... 
200006b8:	06b0 2000 06b0 2000 06b8 2000 06b8 2000     ... ... ... ... 
200006c8:	06c0 2000 06c0 2000 06c8 2000 06c8 2000     ... ... ... ... 
200006d8:	06d0 2000 06d0 2000 06d8 2000 06d8 2000     ... ... ... ... 
200006e8:	06e0 2000 06e0 2000 06e8 2000 06e8 2000     ... ... ... ... 
200006f8:	06f0 2000 06f0 2000 06f8 2000 06f8 2000     ... ... ... ... 
20000708:	0700 2000 0700 2000 0708 2000 0708 2000     ... ... ... ... 
20000718:	0710 2000 0710 2000 0718 2000 0718 2000     ... ... ... ... 
20000728:	0720 2000 0720 2000 0728 2000 0728 2000      ..  .. (.. (.. 
20000738:	0730 2000 0730 2000 0738 2000 0738 2000     0.. 0.. 8.. 8.. 
20000748:	0740 2000 0740 2000 0748 2000 0748 2000     @.. @.. H.. H.. 
20000758:	0750 2000 0750 2000 0758 2000 0758 2000     P.. P.. X.. X.. 
20000768:	0760 2000 0760 2000 0768 2000 0768 2000     `.. `.. h.. h.. 
20000778:	0770 2000 0770 2000 0778 2000 0778 2000     p.. p.. x.. x.. 
20000788:	0780 2000 0780 2000 0788 2000 0788 2000     ... ... ... ... 
20000798:	0790 2000 0790 2000 0798 2000 0798 2000     ... ... ... ... 
200007a8:	07a0 2000 07a0 2000 07a8 2000 07a8 2000     ... ... ... ... 
200007b8:	07b0 2000 07b0 2000 07b8 2000 07b8 2000     ... ... ... ... 
200007c8:	07c0 2000 07c0 2000 07c8 2000 07c8 2000     ... ... ... ... 
200007d8:	07d0 2000 07d0 2000 07d8 2000 07d8 2000     ... ... ... ... 
200007e8:	07e0 2000 07e0 2000 07e8 2000 07e8 2000     ... ... ... ... 
200007f8:	07f0 2000 07f0 2000 07f8 2000 07f8 2000     ... ... ... ... 
20000808:	0800 2000 0800 2000 0808 2000 0808 2000     ... ... ... ... 
20000818:	0810 2000 0810 2000 0818 2000 0818 2000     ... ... ... ... 
20000828:	0820 2000 0820 2000 0828 2000 0828 2000      ..  .. (.. (.. 
20000838:	0830 2000 0830 2000 0838 2000 0838 2000     0.. 0.. 8.. 8.. 
20000848:	0840 2000 0840 2000 0848 2000 0848 2000     @.. @.. H.. H.. 
20000858:	0850 2000 0850 2000 0858 2000 0858 2000     P.. P.. X.. X.. 
20000868:	0860 2000 0860 2000 0868 2000 0868 2000     `.. `.. h.. h.. 
20000878:	0870 2000 0870 2000 0878 2000 0878 2000     p.. p.. x.. x.. 
20000888:	0880 2000 0880 2000 0888 2000 0888 2000     ... ... ... ... 
20000898:	0890 2000 0890 2000 0898 2000 0898 2000     ... ... ... ... 
200008a8:	08a0 2000 08a0 2000 08a8 2000 08a8 2000     ... ... ... ... 
200008b8:	08b0 2000 08b0 2000 08b8 2000 08b8 2000     ... ... ... ... 
200008c8:	08c0 2000 08c0 2000 08c8 2000 08c8 2000     ... ... ... ... 
200008d8:	08d0 2000 08d0 2000 08d8 2000 08d8 2000     ... ... ... ... 
200008e8:	08e0 2000 08e0 2000 08e8 2000 08e8 2000     ... ... ... ... 
200008f8:	08f0 2000 08f0 2000 08f8 2000 08f8 2000     ... ... ... ... 
20000908:	0900 2000 0900 2000 0908 2000 0908 2000     ... ... ... ... 
20000918:	0910 2000 0910 2000 0918 2000 0918 2000     ... ... ... ... 
20000928:	0920 2000 0920 2000 0928 2000 0928 2000      ..  .. (.. (.. 
20000938:	0930 2000 0930 2000 0938 2000 0938 2000     0.. 0.. 8.. 8.. 
20000948:	0940 2000 0940 2000 0948 2000 0948 2000     @.. @.. H.. H.. 
20000958:	0950 2000 0950 2000 0958 2000 0958 2000     P.. P.. X.. X.. 
20000968:	0960 2000 0960 2000 0968 2000 0968 2000     `.. `.. h.. h.. 
20000978:	0970 2000 0970 2000 0978 2000 0978 2000     p.. p.. x.. x.. 
20000988:	0980 2000 0980 2000 0988 2000 0988 2000     ... ... ... ... 
20000998:	0990 2000 0990 2000 0998 2000 0998 2000     ... ... ... ... 
200009a8:	09a0 2000 09a0 2000 09a8 2000 09a8 2000     ... ... ... ... 
200009b8:	09b0 2000 09b0 2000 09b8 2000 09b8 2000     ... ... ... ... 
200009c8:	09c0 2000 09c0 2000 09c8 2000 09c8 2000     ... ... ... ... 
200009d8:	09d0 2000 09d0 2000 09d8 2000 09d8 2000     ... ... ... ... 

200009e8 <__malloc_sbrk_base>:
200009e8:	ffff ffff                                   ....

200009ec <__malloc_trim_threshold>:
200009ec:	0000 0002                                   ....

200009f0 <__atexit_recursive_mutex>:
200009f0:	89a0 2000                                   ... 
